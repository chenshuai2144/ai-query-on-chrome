# 🧐[问题 | 路由设置access无效，一级菜单显示403,二级菜单仍可以进入

`AI Reply`

### 🧐 问题描述

routes.ts
一级菜单设置权限后显示403
二级设置权限后菜单不进行拦截也不显示403

目前:使用他人的解决方案均无效

### 💻 示例代码

![image](https://user-images.githubusercontent.com/81609796/199877099-0fde7a25-9a18-4616-8bc5-73ed23b17c73.png)
![image](https://user-images.githubusercontent.com/81609796/199877210-e36c755d-5e7a-4ae1-bd57-517209d7f9e4.png)
![1667530977799](https://user-images.githubusercontent.com/81609796/199876195-3a28998f-f087-4b01-a277-02f4a25e2bed.jpg)
![1667531149245](https://user-images.githubusercontent.com/81609796/199876371-642e57ae-f5be-416a-83f1-ee3e605f98cf.jpg)

### 🏞 期望结果

二级菜单隐藏或者403

© 版本信息
Ant Design Pro 版本: "5.2.0",
umi 版本: "^3.5.21",
"@ant-design/pro-layout": "^6.33.1",

浏览器环境
开发环境 window

## wangxing0204

是要升级umi到4版本?

## TmacZhou

Any comment for this bug, I also met this issue...

## wangmeijian

umi3的用户，降级@ant-design/pro-layout 到6.26.0版本可解决

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

你好，感谢你的提问。看起来你的问题是在使用 Ant Design Pro 的权限控制时，一级菜单设置访问权限后显示 403，但二级菜单设置权限后不进行拦截也不显示 403。以下是我的一些想法和建议：

首先，根据你提供的信息，我没有找到任何明显的问题，但有几个可能会影响权限控制的因素需要考虑：

1. 是否在路由表中正确配置了权限字段 `access`？你提供的截图中没有显示完整的路由配置，所以无法确认。

2. 你使用的 `@ant-design/pro-layout` 版本是否与其他依赖项冲突？你提供的信息中列出的版本看起来没有问题，但我建议你检查一下依赖项的版本，并根据需要升级或降级版本以消除潜在的冲突。

3. 是否正确设置了当前用户的权限？在你提供的信息中，没有说明如何设置当前用户的权限。你应该首先验证没有权限的用户是否无法访问受保护的路由。可以在浏览器的开发者工具中查看从 API 返回的权限信息，并确保它们正确反映了你分配给用户的实际权限。

具体地，我建议你检查以下内容：

1. 确认在路由表中配置了访问权限字段 `access`。正确的示例如下：

```javascript
{
  path: '/dashboard',
  name: 'dashboard',
  icon: 'dashboard',
  component: './Dashboard',
  access: 'canAdmin', // 配置访问权限字段
},
```

2. 检查 `Layout` 组件是否正确配置了访问权限 (`Authorized` 组件)。示例：

```javascript
// src/layouts/BasicLayout.tsx
import { useModel } from 'umi';
import { Authorized } from '@@/plugin-authority';

export default (props: BasicLayoutProps) => {
  const { initialState } = useModel('@@initialState');

  return (
    <div>
      <Authorized
        authority={props.route!.access} // 向 Authorized 组件传递权限字段
        noMatch={<Exception type="403" />}
      >
        <p>展示内容</p>
      </Authorized>
    </div>
  );
};
```

注意：通过 `props.route!.access` 传递访问权限字段。在渲染路由组件中，`props.route` 表示当前正在渲染的路由。如果没有给出访问权限字段，则返回 undefined。

3. 确定当前用户的权限正确反映在从 API 中获取的权限信息中。

例如，在你的 `.umi/prod/pages.js` 文件中创建供客户端使用的权限信息：

```javascript
// src/access.ts
export default {
  canAdmin: () => {
    const currentUser = getCurrentUser();
    return currentUser && currentUser.access === "admin";
  },
};
```

在 `.umirc.ts` 中将权限信息传递给 `@plugin-authority` 插件：

```typescript
export default {
  plugins: [['@umijs/plugin-layout', {}], ['@umijs/plugin-antd', {}], ['umi-plugin-react', {}]],
  layout: {
    ...,
    // 将权限信息传递给插件
    authority: {
      // authority 是插件中的关键字
      // 初始化权限
      // 支持 initialState 是一个函数时，进行权限合并或覆盖
      // initialState: { permissions: ['user', 'admin'] },
      // 支持 getCurrentAuthority 是一个函数时，不会进行权限管理
      // getCurrentAuthority: (...args) => Promise<'user' | 'admin'>,
      getInitialState: async () => {
        const fetchUserInfo = async () => {
          return {
            access: 'admin',
            ...,
          };
        };
        const currentUser = await fetchUserInfo();

        return {
          currentUser,
          // 将权限信息传递给插件
          permissions: {
            ...access, // 导入 access.ts 内容
          },
        };
      },
    },
  },
  ...
}
```

然后在你的组件中使用 Authorized 组件来展示内容，示例：

```javascript
import { useModel } from "umi";
import { Authorized } from "@@/plugin-authority";

export default () => {
  const { initialState } = useModel("@@initialState");
  return (
    <div>
      <Authorized authority="canAdmin" noMatch={<Exception type="403" />}>
        <p>可以 admin 访问的内容</p>
      </Authorized>
    </div>
  );
};
```

如果仍然无法解决问题，可能需要更多的信息，例如整个路由表的配置以及实际权限信息。希望这些提示可以为你提供帮助，让你可以更轻松地解决问题。

## wangxing0204

> 对于这个错误的任何评论，我也遇到了这个问题……

我是用的降级@ant-design/pro-layout 到6.26.0版本,解决的

## wangxing0204

> umi3的用户，降级@ant-design/pro-layout 到6.26.0版本可解决

感谢.

## wangxing0204

还有一种方式:通过menuDataRender去处理
export const layout: RunTimeLayoutConfig = ({ initialState, setInitialState }) => {
const accessConfig = access(initialState); // 这里调用权限 传递整个 initialState 对象

const menuDataRender = (menuData) => {
// 遍历菜单数据
return menuData
.map((item) => {
const { access, children, ...rest } = item;
// 判断是否具有权限
if (access && !accessConfig[access]) {
return null; // 没有权限则返回 null
}

        // 处理子菜单
        if (children && children.length > 0) {
          const renderedChildren = menuDataRender(children); // 递归处理子菜单
          // 如果子菜单全部没有权限，则返回 null
          if (renderedChildren.every((child) => child === null)) {
            return null;
          }
          return {
            ...rest,
            children: renderedChildren,
          };
        }

        return rest;
      })
      .filter(Boolean); // 过滤掉为 null 的菜单项

};

return {
rightContentRender: () => <RightContent />,
disableContentMargin: false,
links: [],
menuHeaderRender: undefined,
// 自定义 403 页面
// unAccessible: <div>unAccessible</div>,
// 增加一个 loading 的状态
childrenRender: (children, props) => {
// if (initialState?.loading) return <PageLoading />;
return (
<>
{children}
{!props.location?.pathname?.includes('/login') && (
<SettingDrawer
disableUrlParams
enableDarkTheme
settings={initialState?.settings}
onSettingChange={(settings) => {
setInitialState((preInitialState) => ({
...preInitialState,
settings,
}));
}}
/>
)}
</>
);
},
menuDataRender,
...initialState?.settings,
};
};
