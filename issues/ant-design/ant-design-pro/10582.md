# 升级到v5版本后发送请求400或者500后，再次请求发不出去，只能刷新浏览器重新请求

`AI Reply`

### 🐛 bug 描述

升级到v5版本后发送请求400或者500后，再次请求发不出去，只能刷新浏览器重新请求， v4版本是在errorhandler里面 return response就可以， v5不起作用。

```js
export const errorConfig: RequestConfig = {
  // 错误处理： umi@3 的错误处理方案。
  errorConfig: {
    // 错误抛出
    errorThrower: (res) => {
      const { success, data, errorCode, errorMessage, showType } =
        res as unknown as ResponseStructure;
      if (!success) {
        const error: any = new Error(errorMessage);
        error.name = 'BizError';
        error.info = { errorCode, errorMessage, showType, data };
        throw error; // 抛出自制的错误
      }
    },
    // 错误接收及处理
    errorHandler: (error: any, opts: any) => {
      const { response }: any = error;
      if (opts?.skipErrorHandler) throw error;
      // 我们的 errorThrower 抛出的错误。
      if (error.name === 'BizError') {
        const errorInfo: ResponseStructure | undefined = error.info;
        if (errorInfo) {
          const { errorMessage, errorCode } = errorInfo;
          switch (errorInfo.showType) {
            case ErrorShowType.SILENT:
              // do nothing
              break;
            case ErrorShowType.WARN_MESSAGE:
              message.warning(errorMessage);
              break;
            case ErrorShowType.ERROR_MESSAGE:
              message.error(errorMessage);
              break;
            case ErrorShowType.NOTIFICATION:
              notification.open({
                description: errorMessage,
                message: errorCode,
              });
              break;
            case ErrorShowType.REDIRECT:
              // TODO: redirect
              break;
            default:
              message.error(errorMessage);
          }
        }
      } else if (error.response) {
        // Axios 的错误
        // 请求成功发出且服务器也响应了状态码，但状态代码超出了 2xx 的范围
        message.error(error.response.data?.message || `Response status:${error.response.status}`);
      } else if (error.request) {
        // 请求已经成功发起，但没有收到响应
        // \`error.request\` 在浏览器中是 XMLHttpRequest 的实例，
        // 而在node.js中是 http.ClientRequest 的实例
        message.error('None response! Please retry.');
      } else {
        // 发送请求时出了点问题
        message.error('Request error, please retry.');
      }
      return response;
    },
  },

  // 请求拦截器
  requestInterceptors: [requestInterceptor],

  // 响应拦截器
  responseInterceptors: [success],

};
```

### 📷 复现步骤 | Recurrence steps

直接使用官方脚手架提供的 requestErrorConfig.ts文件

### 🏞 期望结果 | Expected results

期望请求后端返回非200状态后，可以再次正常发送请求

### © 版本信息

- Ant Design Pro 版本: ^5.2.1
- umi 版本： "@umijs/max": "^4.0.33",
- 浏览器环境 chrome
- 开发环境 : mac OS

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

您可以尝试更新您的错误处理程序代码，特别关注从axios错误和业务错误中进行正确处理。如下所示的代码可以是一个参考。

```js
// error handler
const errorHandler = (error: any): any => {
  const { request, response } = error;
  if (response) {
    const { status, data } = response;
    // 业务错误处理
    if (status === 400 || status === 500) {
      // 这里可以根据业务错误code或者其他条件来判断是否需要在此处throw错误，
      // 您也可以加入相关的消息提示或者其他的表现形式来提醒用户错误信息
      throw new Error(data.message);
    }
    return response;
  } else if (request) {
    // 请求已经发出，但是没有收到响应
    message.error('The request was made, but no response was received.');
    return Promise.reject(error);
  } else {
    // 在请求设置时发生了一些错误, 请求没有发送成功
    message.error('Error when setting up the request.');
    return Promise.reject(error);
  }
};

// request Config
const requestConfig: IRequestConfig = {
  errorHandler, // 全局错误处理
};

```

对于getRequest和postRequest这样的自定义请求方法，您可以在错误处理程序中进行相应处理，如下所示。

```js

/**
 * @param {string} url url
 * @param {Object} params request params
 */
const postRequest = async <T = any>(url: string, params?: any) => {
  const { data: response }: AxiosResponse = await request.post(url, params);
  const { success, data, errorCode, errorMessage, showType } = response as any;
  console.log("POST Request Status", response.status);
  if (success) {
    return data as T;
  }
  // 业务错误处理
  if (response.status === 400 || response.status === 500) {
    throw new Error(errorMessage);
  }
};

/**
 *
 * @param {string} url url
 * @param {Object} params request params
 */
const getRequest = async <T = any>(url: string, params?: any) => {
  try {
    const { data: response }: AxiosResponse = await request.get(url, {
      params,
    });
    const { success, data, errorCode, errorMessage, showType } = response as any;
    console.log("GET Request Status: ", response.status);
    if (success) {
      return data as T;
    }
    // 业务错误处理
    if (response.status === 400 || response.status === 500) {
      throw new Error(errorMessage);
    }
  } catch (error) {
    errorHandler(error);
  }
};

```

如果这样的处理仍旧无法解决问题，建议您进一步调查，以排除其他影响请求的可能原因，例如网络问题。

## chenshuai2144

https://axios-http.com/

我们用了这个库，你可以看这个库的文档来处理
