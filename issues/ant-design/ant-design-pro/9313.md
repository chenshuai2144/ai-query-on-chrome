# 👑 [需求] 路由动态过滤以及菜单icon无法显示的解决思路

`😸Documentation`

### 🥰 需求描述

通常在使用框架都会涉及到认证授权功能，系统的功能菜单通过用户登录后，从服务器获取菜单数据后渲染到页面中。
动态路由的获取方式官网已提供相关的方法，https://procomponents.ant.design/components/layout#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8
https://pro.ant.design/zh-CN/docs/advanced-menu

在代码实践中，会遇到两个问题：

1. 系统菜单显示可以按照服务器返回的数据进行显示，但是直接修改浏览器的地址，还是无法防止用户访问
2. 菜单icon无法显示，网上搜索到的方法都是将所有的ant icon全部加载，封装方法获取icon

### 🧐 解决方案

采用ant design pro原生的方法，将所有的页面配置到router.ts，并添加icon，这个时候所有菜单和icon都能够正常显示。

- 解决第二个问题：icon无法显示

使用两个 API, menu.request 和 menu.params，请求服务器获取当前用户菜单，通过参数defaultMenuData获取routers.ts中所有的路由，然后数据过滤，将用户的拥有的菜单过滤出来，并返回新的MenuData.

```
menu: {
      // 每当 initialState?.currentUser?.userid 发生修改时重新执行 request
      params: {
        userId: initialState?.currentUser?.id,
      },
      request: async (params, defaultMenuData) => {
        // initialState.currentUser 中包含了所有用户信息
        const menus = await buildMenus();
        let menuPaths = extractMenuPath(menus);
        // 添加公共的路径
        menuPaths = menuPaths.concat(['/', '/login', '/home', '/403']);
        setInitialState((s) => ({ ...s, menuPaths }));
        if (menuPaths) {
          const menuData = await filterUserMenu(defaultMenuData, menuPaths);
          return menuData;
        }
        return [];
      },
    },
```

方法函数-extractMenuPath

```
/**
 * 提取菜单数据所有的path属性
 *
 * @param data 菜单数据
 * @returns 菜单Path集合
 */
export const extractMenuPath = (data: any[]) => {
  const stack = data.concat();
  const paths = [];
  while (stack.length !== 0) {
    const node = stack.pop();
    if (node?.path) {
      paths.push(node.path);
    }
    if (node?.children) {
      for (let i = node?.children.length - 1; i >= 0; i--) {
        stack.push(node.children[i]);
      }
    }
  }
  return paths;
};
```

方法函数-filterUserMenu

```
/**
 * 根据用户的菜单权限过滤多余的路由
 *
 * @param defaultMenuData 默认routers.ts配置
 * @param menuPaths 服务器返回的所有菜单Path,可以调用extractMenuPath提取
 * @returns 新的菜单数据
 */
export const filterUserMenu = async (defaultMenuData: MenuDataItem[], menuPaths: string[]) => {
  const result: MenuDataItem[] = [];
  defaultMenuData.forEach(async (node) => {
    if (node?.path) {
      if (!matchPath(node?.path, { path: menuPaths, exact: true })) {
        return;
      }
    }

    if (node?.routes) {
      node.routes = await filterUserMenu(node?.routes, menuPaths);
    }
    result.push(node);
  });
  return result;
};
```

以上方法用于使用umi原生渲染出来的routers，icon可以正常显示。

- 接下来解决第二个问题：禁止用户修改浏览器地址进入页面。
  调整onPageChange方法，在进入页面的时候，获取location.pathname并比较服务返回的菜单数据是否匹配，不匹配返回/403。

```
onPageChange: () => {
      const { location } = history;
      // 如果没有登录，重定向到 login
      if (!cookie.load('token') && location.pathname !== loginPath) {
        history.push(loginPath);
      }
      // 用于处理直接修改浏览器地址，进入页面
      if (initialState?.menuPaths) {
        if (!matchPath(location.pathname, { path: initialState.menuPaths, exact: true })) {
          history.push('/403');
        }
      }
    },
```

### 🚑 其他信息

<!--
如截图等其他信息可以贴在这里
-->

## chenshuai2144

社区之光 🎇🎇🎇🎇

## lovesL

这不是动态菜单嘛 没看出哪里路由动态了 菜单是动态的

## thx125

> 这不是动态菜单嘛 没看出哪里路由动态了 菜单是动态的

我的标题不够严谨，我这边可以更正一下

## chenshuai2144

路由不可能动态的。

## zjstudy

这个解决方式比较合理

## KYX1234

我觉得就该这样
