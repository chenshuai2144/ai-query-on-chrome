# `Drawer` will cause mismatch in SSR mode

`ðŸ› Bug`

### Reproduction link

[https://stackblitz.com/edit/nextjs-zxvknz?file=pages/index.js](https://stackblitz.com/edit/nextjs-zxvknz?file=pages/index.js)

### Steps to reproduce

1. create a Next.js app with `Drawer`
2. set the `open` default to `true`
3. > npm run dev

```js
import Head from "next/head";
import styles from "../styles/Home.module.css";
import { Button, Drawer } from "antd";

export default function Home() {
  return (
    <Drawer title="Basic Drawer" placement="right" open={true}>
      <p>Some contents...</p>
      <p>Some contents...</p>
      <p>Some contents...</p>
    </Drawer>
  );
}
```

### What is expected?

No error

### What is actually happening?

Error toast : " Hydration failed because the initial UI does not match what was rendered on the server."
<img width="439" alt="image" src="https://user-images.githubusercontent.com/8624194/222209935-a80e3f8d-5a74-4e1e-b6cc-234fe9fbcc25.png">

| Environment | Info       |
| ----------- | ---------- |
| antd        | 5.2.3      |
| React       | 18.2.0     |
| System      | MacOSX     |
| Browser     | Chrome 109 |

<!-- generated by ant-design-issue-helper. DO NOT REMOVE -->

## AndyBoat

I believe this is due to the hook `useLayoutEffect`. in [rcDrawerL47](https://github.com/react-component/drawer/blob/94a9e58d547f34473bc4f2e631d1d28ba72d04c0/src/Drawer.tsx#L47)

And I need some time to really dig into the reason of why `useLayoutEffect` will cause mismtach between SSR and client. maybe this doc may help : [useeffect-vs-uselayouteffect](https://kentcdodds.com/blog/useeffect-vs-uselayouteffect)

And there is some method to handle this problem in Next.js app now:

I can use [dynamic](https://nextjs.org/docs/advanced-features/dynamic-import) to make this Drawer only render in clent

```js
import dynamic from 'next/dynamic'

const ClientDrawer = dynamic(()=>Promise.resolve(Drawer, {ssr:false})

//...

const SomeApp = ()=>{
  //...
 return <ClientDrawer   />
```

And according to this doc [uselayouteffect-and-ssr](https://medium.com/@alexandereardon/uselayouteffect-and-ssr-192986cdcf7a), create a `useIsomorphicLayoutEffect`may help, but I will look into it later.
If it truly works as we expected, I would make a pull request for `rcDrawer`

```js
// use-isomorphic-layout-effect.js
import { useLayoutEffect, useEffect } from "react";
const useIsomorphicLayoutEffect =
  typeof window !== "undefined" ? useLayoutEffect : useEffect;
export default useIsomorphicLayoutEffect;
```

## AndyBoat

After take a look into the `Portal`, maybe it is due to the inner hook [`useDom` ](https://github.com/react-component/portal/blob/555b158c49a649927807bd7f9b80ac80d2742bad/src/useDom.tsx#L63-L82)

```js
useLayoutEffect(() => {
  if (render) {
    if (queueCreate) {
      queueCreate(append);
    } else {
      append();
    }
  } else {
    cleanup();
  }

  return cleanup;
}, [render]);

useLayoutEffect(() => {
  if (queue.length) {
    queue.forEach((appendFn) => appendFn());
    setQueue(EMPTY_LIST);
  }
}, [queue]);
```

## AndyBoat

The mismatch comes from here: [Portal.tsx#L108-L131](https://github.com/react-component/portal/blob/555b158c49a649927807bd7f9b80ac80d2742bad/src/Portal.tsx#L108-L131)

And I guess this is an expected behavior since it can't inject into dom in server

Maybe we can find a way to tell Component "automatically" decorate iteself as client-only when ssr like `dynamic(()=>Promise.resolve(Component, {ssr:false})`, or we may propose a FAQ about this method under the Drawer reference.

```js
  // ========================= Render ==========================
  // Do not render when nothing need render
  // When innerContainer is `undefined`, it may not ready since user use ref in the same render
  if (!mergedRender || !canUseDom() || innerContainer === undefined) {
    return null;
  }

  // Render inline
  const renderInline = mergedContainer === false || inlineMock();

  let reffedChildren = children;
  if (ref) {
    reffedChildren = React.cloneElement(children as any, {
      ref: mergedRef,
    });
  }

  return (
    <OrderContext.Provider value={queueCreate}>
      {renderInline
        ? reffedChildren
        : createPortal(reffedChildren, mergedContainer)}
    </OrderContext.Provider>
  );
```

## AndyBoat

Minimal reproduction is here : https://stackblitz.com/edit/nextjs-f1tbos?file=pages%2Findex.js

## ccdarvin

to fix this i have used

```
useEffect(() => {
        setOpen(open)
    }, [open])
```

## AndyBoat

> to fix this i have used
>
> ```
> useEffect(() => {
>         setOpen(open)
>     }, [open])
> ```

Am I getting this right ? That you are creating another `state` like `innerOpen`, and use this to trace after the `open` but only will work in client ?

## ccdarvin

> > to fix this i have used
> >
> > ```
> > useEffect(() => {
> >         setOpen(open)
> >     }, [open])
> > ```
>
> Am I getting this right ? That you are creating another `state` like `innerOpen`, and use this to trace after the `open` but only will work in client ?

Yes, it only works on the client, it is not the best solution but work for me
