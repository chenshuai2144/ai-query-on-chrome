# Small watermark optimization

### What problem does this feature solve?

emmmm,I think the watermark code can be optimized.

### What does the proposed API look like?

For example onMutate function

```ts
  const onMutate = useCallback(
    async (mutations: MutationRecord[]) => {
      if (stopObservation.current) {
        return;
      }
      let needRender = false;

      for (const mutation of mutations) {
        if (reRendering(mutation, watermarkRef.current)) {
          needRender = true;
          break; // 直接跳出循环
        }
      }

      if (needRender) {
        destroyWatermark();
        await new Promise((resolve) => requestAnimationFrame(resolve)); // 等待下一次绘制帧之前进行重新渲染
        renderWatermark();
      }
    },
    [destroyWatermark, renderWatermark, reRendering],
  );

<!-- generated by ant-design-issue-helper. DO NOT REMOVE -->


## zombieJ

cc @JarvisArt


## li-jia-nan

> cc @JarvisArt

大佬你艾特错人了，是 @RedJue


## RedJue

没艾特错…😅


## JarvisArt

@xubohuah 有么有例子可以看出实际的性能测试验证。


## xubohuah


1. 使用async/await，在destroyWatermark之后，通过await关键字等待下一次绘制帧之前进行重新渲染，可以减少渲染的频率，提高性能；

2. 使用for...of循环，与forEach相比，for...of循环在遍历数组时效率更高。当mutation满足reRendering条件时，直接跳出循环，不再继续遍历其他元素，减少了不必要的迭代，提高了性能；

3. 使用requestAnimationFrame，在重新渲染水印之前，通过调用requestAnimationFrame，将渲染操作推迟到浏览器的下一次绘制帧之前执行。这可以确保在绘制之前进行渲染，以提高性能和流畅度；

4. 使用useCallback来定义onMutate函数，可以缓存函数实例，避免不必要的重复创建。

   主要是减少不必要的迭代、优化重绘时机。但是优化的效果可能因场景而异。如果DOM变化较少或水印组件本身的渲染开销并不大，那么优化后的性能变化可能相对较小。但在面对频繁的DOM变化或复杂的水印组件情况下，优化后的onMutate函数可能会带来显著的性能提升。但是水印组件应该复杂的dom场景应该比较少哈哈，我也没有具体的测试，可优化可不优化吧。



## zombieJ

https://github.com/ant-design/ant-design/pull/44104  这里一并改成 raf 了

```
