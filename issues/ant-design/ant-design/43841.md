# Tooltip包裹Input, Input disabled时Tooltip失效

`needs-more-info`

### Reproduction link

[https://stackblitz.com/edit/react-i3b7x5?file=demo.tsx](https://stackblitz.com/edit/react-i3b7x5?file=demo.tsx)

### Steps to reproduce

鼠标移入禁用状态输入框, Tooltip未显示

### What is expected?

鼠标移入输入框, Tooltip正常显示

### What is actually happening?

鼠标移入输入框, Tooltip未显示

| Environment | Info                                      |
| ----------- | ----------------------------------------- |
| antd        | 5.7.3                                     |
| React       | 18.2                                      |
| System      | mac 12.6.6                                |
| Browser     | Chrome 114.0.5735.198（正式版本） (arm64) |

<!-- generated by ant-design-issue-helper. DO NOT REMOVE -->

## stackblitz[bot]

<a href='https://stackblitz.com/~/github.com/ant-design/ant-design/issues/43841?repros=react-i3b7x5'><img src='https://developer.stackblitz.com/img/fix_this_issue_small.svg' alt='Fix this issue in StackBlitz Codeflow' align='left' width='117' height='20'></a> _Start a new pull request in [StackBlitz Codeflow](https://stackblitz.com/~/github.com/ant-design/ant-design/issues/43841?repros=react-i3b7x5)._

- [**react-i3b7x5** (Open reproduction)](https://stackblitz.com/edit/react-i3b7x5?issueRepo=ant-design/ant-design&issueNumber=43841)

## MadCcc

包裹一层 span 可以解

## zombieJ

这个是 HTML 原生行为，Hover 事件直接阻拦掉，上层消费不到。只能自己包一层，没什么特别好的办法。

## FloaJa

因为外层使用了Input.Group, 包span会影响样式, 调起来很麻烦, 就写了个hooks在外层管理Tooltip显示状态

```

import { debounce } from 'lodash';
import { useEffect, useRef, useState } from 'react';

interface Options {
  mouseEnterDelay?: number;
}

export const useShowTooltip = (
  element: HTMLInputElement | null | undefined,
  popElement: HTMLDivElement | null | undefined,
  options?: Options,
) => {
  const { mouseEnterDelay = 1e2 } = options || {};
  const [show, setShow] = useState<boolean>(false);
  const mouseoverRef = useRef<boolean>(false);

  useEffect(() => {
    const mouseover = () => {
      mouseoverRef.current = true;
    };
    const toShow = debounce(() => {
      if (mouseoverRef.current) {
        setShow(true);
      }
    }, mouseEnterDelay);

    const toHidden = debounce(() => {
      if (mouseoverRef.current === false) {
        setShow(false);
      }
    }, 1e2);

    const mouseout = () => {
      mouseoverRef.current = false;
      toHidden();
    };

    if (element) {
      element.parentElement?.addEventListener('mouseover', mouseover);
      element.parentElement?.addEventListener('mousemove', toShow);
      element.parentElement?.addEventListener('mouseout', mouseout);
    }
    if (popElement) {
      popElement.addEventListener('mouseover', mouseover);
      popElement.addEventListener('mouseout', mouseout);
    }

    return () => {
      if (element) {
        element.parentElement?.removeEventListener('mouseover', mouseover);
        element.parentElement?.removeEventListener('mousemove', toShow);
        element.parentElement?.removeEventListener('mouseout', toHidden);
      }
      if (popElement) {
        popElement.removeEventListener('mouseover', mouseover);
        popElement.removeEventListener('mouseout', toHidden);
      }
    };
  }, [element, popElement]);

  return show;
};
```

使用方法
`const show = useShowTooltip(inputRef.current?.input, tooltipRef.current?.getContainer());`

## FloaJa

> 这个是 HTML 原生行为，Hover 事件直接阻拦掉，上层消费不到。只能自己包一层，没什么特别好的办法。

还是希望能在组件内部解决掉这个问题, 比如把事件绑定到input外的span上?
