# 👑 [需求]ProTable中的sorter

`table`,`🤷🏼 How to use`,`🎖️  featrue`,`AI Reply`

### 🥰 需求描述

目前ProTable中的sorter，传递参数的方式为Key（sorter.field）、Value（sorter.order）的方式，这个方式与默认的搜索传参方式冲突。

### 🧐 解决方案

建议改为通过sortBy与isAscending两个参数来传值。其中sortBy为排序字段，isAscending为是否升序。

### 🚑 其他信息

无

## chenshuai2144

你这个数据结构表示方式我有点看不懂，有实例吗？

## rockyxiaogang

> 你这个数据结构表示方式我有点看不懂，有实例吗？

现有的：.../node_modules/@ant-design/pro-table/lib/typing.d.ts中

```
/**
* @name 一个获得 dataSource 的方法
*/
request?: (params: U & {
        pageSize?: number;
        current?: number;
        keyword?: string;
    }, sort: Record<string, SortOrder>, filter: Record<string, React.ReactText[]>) => Promise<RequestData<T>>;
```

sort: Record<string, SortOrder>这个参数会与ToolBar中默认的search功能冲突。

比如在同时做title字段的搜索和排序：
a、搜索操作title=keyword
b、升序操作title=ascend
会造成title=ascend覆盖掉title=keyword

希望改进为如下格式：

```
request?: (params: U & {
        pageSize?: number;
        current?: number;
        keyword?: string;
    }, sortBy: string, isAscending:boolean, filter: Record<string, React.ReactText[]>) => Promise<RequestData<T>>;
```

或者

```
request?: (params: U & {
        pageSize?: number;
        current?: number;
        keyword?: string;
    }, sort: string, order:SortOrder, filter: Record<string, React.ReactText[]>) => Promise<RequestData<T>>;
```

## chenshuai2144

还是没搞懂，这样有什么优势，反而多个一个字段

## shanzhaozhen

我觉得目前排序的问题主要是默认取dataIndex字段，但是如果是服务器排序有可能排序的实际字段并不是dataIndex的内容，所以希望可以添加sorterField的字段，可以直接传到request方法中的sorter字段即可，其实改动也不大，只需要 item.dataIndex 改成 item.sorterField || item.dataIndex 即可（还没有详细看过排序哪部分的源码，实际情况还不太了解）。

## lazyboywu

目前 ProTable sorter 的根本原因在于，既然 ProTable 是基于 Table 组件做的，那么为什么要改变 Table 组件之前规定的 sorter 结构？

> sortField: sorter.field,
> sortOrder: sorter.order
> // https://ant.design/components/table-cn/#components-table-demo-ajax

另外着这样做的目的不仅仅是说多一个字段的问题，而是因为field和order是固定名（static name），无论代码中还是参数中识别，都可以方便引用识别，而非是一个动态kv结构

```json
{ "field": "xxxx", "order": "['ascend' | 'descend']" }
```

```json
{ "xxxx": "['ascend' | 'descend']" }
```

看上面的结构就能知道，field和order更易编码和使用，而一个kv就要泛解析（例如用Object.keys/Object.values）

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

明白了，你想要添加的 `sorterField` 字段是为了解决 ProTable 默认取 `dataIndex` 字段，但是有些应用场景需要显式地指定排序的实际字段的问题。

不过，如果这个需求是为了使用服务器进行排序，为什么不能将需要排序的实际字段传到服务端，再让服务端来处理排序呢？如果要这样做的话，你只需要在 request 方法中添加一个 `sortField` 参数即可：

```javascript
request: (params, sorterField, sortOrder, filters) => {
  const query = {...params};
  if (sortField) {
    query.sortField = sorterField;
    query.sortOrder = sortOrder === 'descend' ? 'desc' : 'asc';
  }
  return myApi.getUsers(query, filters);
},
```

在这个例子里，我们通过 query.sortField 和 query.sortOrder 把需要排序的字段和排序方式传到服务端，由服务端进行实际的排序。这个方法还可以直接被 ProTable 的 `sorter` 参数使用。

例如：

```jsx
<ProTable
  columns={columns}
  request={(params, sorter, filters) =>
    request(params, sorter.field, sorter.order, filters)
  }
/>
```

然后在菜单栏中选中 “Name” （即表格的第一个列）排序，就会发送下面的请求到服务端：

```
GET /users?current=1&pageSize=20&sortField=name&sortOrder=asc
```

这样的话就不需要在请求前把 `sorter` 转换成服务器需要的数据结构了。

## chengmaoning

> > TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> > 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。
>
> 明白了，你想要添加的 `sorterField` 字段是为了解决 ProTable 默认取 `dataIndex` 字段，但是有些应用场景需要显式地指定排序的实际字段的问题。
>
> 不过，如果这个需求是为了使用服务器进行排序，为什么不能将需要排序的实际字段传到服务端，再让服务端来处理排序呢？如果要这样做的话，你只需要在 request 方法中添加一个 `sortField` 参数即可：
>
> ```js
> request: (params, sorterField, sortOrder, filters) => {
>   const query = {...params};
>   if (sortField) {
>     query.sortField = sorterField;
>     query.sortOrder = sortOrder === 'descend' ? 'desc' : 'asc';
>   }
>   return myApi.getUsers(query, filters);
> },
> ```
>
> 在这个例子里，我们通过 query.sortField 和 query.sortOrder 把需要排序的字段和排序方式传到服务端，由服务端进行实际的排序。这个方法还可以直接被 ProTable 的 `sorter` 参数使用。
>
> 例如：
>
> ```js
> <ProTable
>   columns={columns}
>   request={(params, sorter, filters) =>
>     request(params, sorter.field, sorter.order, filters)
>   }
> />
> ```
>
> 然后在菜单栏中选中 “Name” （即表格的第一个列）排序，就会发送下面的请求到服务端：
>
> ```
> GET /users?current=1&pageSize=20&sortField=name&sortOrder=asc
> ```
>
> 这样的话就不需要在请求前把 `sorter` 转换成服务器需要的数据结构了。

这个AI回答的不对。
上面已经说了增加filed 和 order独立两个字段是为了后端方便获取，table也是这个数据结构，后端很方便处理。但目前protable改变了这个数据结构，使用{k:v}，这种动态结构，后端不好获取k,和v。
AI说request增加两个参数，问题这个function是组件传入的，跟组件的数据结构设计有关，不是用户写个参数名就有filed和order的？麻烦作者看下是否能继续按照table的sorter数据结构来。

## WuJiY

你这个多列字段排序怎么处理？
