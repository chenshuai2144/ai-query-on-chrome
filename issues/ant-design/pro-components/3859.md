# 🐛[BUG] Pro-Table renderFormItem 在点击重置的时候重新渲染有问题

`⭕️   bug`,`table`,`AI Reply`

### 🐛 bug 描述

在使用 renderFormItem 自定义表单的时候，期望是`campaign`这个表单项根据 `keyAccount`的是否有值动态渲染，但在两者表单都渲染出来后点击重置按钮，表单值有重置到默认值，但`campaign`的表单项没有完全消失，而是留下了一个单 Label

### 📷 复现步骤

1. 填充项目表单值，Campaign表单项显示，填充Campaign表单项值
2. 点击重置按钮
3. 表单重置，但Campaign表单项未完全消失

### 🏞 期望结果

Campaign表单项完全消失

### 💻 复现代码

```
const columns = [{
      title: CampaignMenu.Campaign,
      dataIndex: 'campaign',
      formItemProps: {
        preserve: false,
        shouldUpdate: true,
      },
      search: {
        transform: v => ({ campaignId: v.value }),
      },
      renderFormItem: ({ fieldProps }, _, form) => {
        const keyAccount = form.getFieldValue('keyAccount')
        if (!keyAccount) return null
        return (
          <RemoteSelect
            postData={{ keyAccountId: keyAccount.value }}
            url="/campaign/page"
            deps={[keyAccount.value]}
            {...fieldProps}
          />
        )
      },
      fieldProps: {
        placeholder: t('global.form.select', { name: CampaignMenu.Campaign }),
      },]
```

### © 版本信息

```
"@ant-design/pro-form": "^1.40.0",
   "@ant-design/pro-layout": "^6.25.0",
   "@ant-design/pro-table": "^2.56.2",
"antd": "^4.17.0-alpha.2",Ï
```

### 🚑 其他信息

实测不使用自定义组件，只返回defaultRender或false, 也会有次情况

![image](https://user-images.githubusercontent.com/27920863/137880998-87255b61-6ebf-4cbe-b6c2-88c81cb025f3.png)

## luotongzhou

除非触发 form 表单的 onValuesChange 事件，Campaign表单项才会按照预期消失，但如何触发呢？form.setFeildsValue 不能触发 onValuesChange 事件

## luotongzhou

通过翻阅`SchemaForm`源码发现，renderFormItem 是会每次重新渲染的，但是

```
const domList = useMemo(() => {
    return genItems(columns, updateTime);
  }, [columns, genItems, updateTime]);
```

domList 并没有重新渲染，因为

```
<Form
      formRef={formRef}
      form={form}
      {...rest}
      onInit={(...restValue) => {
        if (needRealUpdate) {
          updateFormRender(updateTime + 1);
        }
        rest?.onInit?.(...restValue);
      }}
      onValuesChange={(...restValue) => {
        if (needRealUpdate) {
          updateFormRender(updateTime + 1);
        }
        rest?.onValuesChange?.(...restValue);
      }}
    >
      {domList}
    </Form>
```

可以看到基本上只有`onValuesChange`才会重新渲染表单，这个时候才会删掉 留下的 Label
相当于valuesChange的时候 forceUpdate了一次，但是没有其他办法从外部 forceUpdate

## luotongzhou

更新：
因为我在代码里用useMemo包裹了 column 项，导致传递到 protable 里 column 一直没有变化，domlist 更新也是依赖 column 的, 所有我在自己代码里维护一个 updateNumber 的 state 并让 useMemo 依赖它，在表单的 reset 的时候去更新 updateNumber 来起到 forceUpdate 的作用

## chenshuai2144

应该修复掉了，你再试试，我们重写了这个渲染器

## luotongzhou

感谢还在关注这个问题，我更新了到了最新版，但有种情况这个BUG还是会复现，就是pro-table 自带表单search的重置按钮, 依然会对renderFormItem return 为null 的表单项留下一个空白label
我也找到了修复这个问题的commit 记录，确实没有对重置按钮点击那块有代码修改。将官网例子里的搜索表单自定义那里的例子改一下就可以复现，columns的值改为如下

```
{
      title: '状态',
      dataIndex: 'state',
      valueType: 'select',
      request: async () => [
        {
          label: '月份',
          value: 1,
        },
        {
          label: '周',
          value: 2,
        },
        {
          label: '自定义',
          value: 3,
        },
        {
          label: '不展示',
          value: 4,
        },
      ],
    },
    {
      title: '动态表单',
      key: 'direction',
      hideInTable: true,
      dataIndex: 'direction',
      renderFormItem: (item, { type, defaultRender, ...rest }, form) => {
        const stateType = form.getFieldValue('state');
        if (!stateType) {
          return null;
        }
        return (
          <MySelect
            {...rest}
            state={{
              type: stateType,
            }}
          />
        );
      },
    },
```

## yzwxk

> 感谢还在关注这个问题，我更新了到了最新版，但有种情况这个BUG还是会复现，就是pro-table 自带表单search的重置按钮, 依然会对renderFormItem return 为null 的表单项留下一个空白label 我也找到了修复这个问题的commit 记录，确实没有对重置按钮点击那块有代码修改。将官网例子里的搜索表单自定义那里的例子改一下就可以复现，columns的值改为如下
>
> ```
> {
>       title: '状态',
>       dataIndex: 'state',
>       valueType: 'select',
>       request: async () => [
>         {
>           label: '月份',
>           value: 1,
>         },
>         {
>           label: '周',
>           value: 2,
>         },
>         {
>           label: '自定义',
>           value: 3,
>         },
>         {
>           label: '不展示',
>           value: 4,
>         },
>       ],
>     },
>     {
>       title: '动态表单',
>       key: 'direction',
>       hideInTable: true,
>       dataIndex: 'direction',
>       renderFormItem: (item, { type, defaultRender, ...rest }, form) => {
>         const stateType = form.getFieldValue('state');
>         if (!stateType) {
>           return null;
>         }
>         return (
>           <MySelect
>             {...rest}
>             state={{
>               type: stateType,
>             }}
>           />
>         );
>       },
>     },
> ```

试了下2.68.3 是可以正常工作的。https://codesandbox.io/s/cha-xun-biao-ge-forked-r6nomp?file=/App.tsx

## luotongzhou

> @yzwxk

还是存在的，你用我上面贴的 columns，修改值让动态表单显示后点重置按钮就能复现

## lovewinders

我也碰到点击重置后，label还在问题

## lovewinders

> 应该修复掉了，你再试试，我们重写了这个渲染器

@chenshuai2144 该问题还存在修改值让动态表单显示后点重置按钮就能复现

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

很抱歉之前的回答有误。这个问题是由于 ProTable 默认使用 `queryFilterOption="replace"` 的方式重置表单，而不是基于 ProForm 组件的方式。本质上它会调用后端来过滤数据。这会导致如果表单项不是由`formValueRender`渲染的（包括`renderFormItem`函数返回值为 null 的表单项），就会产生这个问题，即点击重置后对应表单组件未成功删除。

为了解决这个问题，我们需要在 ProTable 上使用 `manualRequest` 属性来禁用默认的重置行为，转而使用 `ProForm` 的 `resetFields` 组件的行为。在每次调用 `resetFields` 时都会触发 `formValuesChange` 事件，从而完成全部表单项的清空，避免了之前出现的问题。以下代码作为参考：

```js
<ProTable
  // --------------------向上查找到 ProTable 处理---------------------------
  manualRequest={true} // 禁用 ProTable 默认的请求，改用 form resetFields
  // --------------------向上查找到 ProTable 处理---------------------------
/>

<ProForm
  form={form}
  initialValues={{}} // 注入初始值为 {}
  onFormReset={ () => {
    requestRef.current({}) // 手动请求
  }}
/>
```

同时，为了确保在重置时所有表单项目都能被删除而不是停留在空白标签上，我们可以增加一个表单引用实例（`formRef`）的 useEffect react 钩子函数。它将对 ProForm 组件接收到的`onFormChange` 事件做出更改，将所有表格布局元素都删除。下面是完整代码的示例：

```js
import React, { useRef, useEffect, useState } from "react";
import { Button } from "antd";
import ProTable, { ProColumns } from "@ant-design/pro-table";
import { ProForm, ProFormText } from "@ant-design/pro-form";

const columns: ProColumns<API.User>[] = [
  {
    title: "id",
    dataIndex: "id",
  },
  {
    title: "name",
    dataIndex: "name",
    renderFormItem: ({ fieldProps }) => {
      return <ProFormText {...fieldProps} />
    },
  },
  {
    title: "status",
    dataIndex: "status",
    valueEnum: {
      0: { text: "关闭", status: "Default" },
      1: { text: "运行中", status: "Processing" },
      2: { text: "已上线", status: "Success" },
      3: { text: "异常", status: "Error" },
    },
  },
];

export default () => {

  const [dataSource, setDataSource] = useState([])

  const formRef = useRef();

  useEffect(() => {
    requestRef.current({})
  }, []);

  useEffect(() => {  // 用此 useEffect 渲染的 FormItem 在重置时一定会被清空
    formRef.current?.setFields([]);
  }, [formRef]);

  const requestRef = useRef((params, sorter, filter) => {
    return Promise.resolve({
      data:[{"id":1,"name":"mike","status":1}],
      success: true
    });
  });

  return (
    <div>
      <ProTable<API.User>
        manualRequest={true} // 手动使用form resetFields
        columns={columns}
        request={async (
          params = {},
          sort: any,
          filter: any
        ): Promise<API.List<API.User>> => {
          const result = await requestRef.current(params, sort, filter);
          setDataSource(result.data);
          return result
        }}
      />
      <ProForm
        ref={formRef} // 保存表单实例引用
        initialValues={{}} // 初始值为空对象
        onFormReset={() => { // 在 ProForm 重置时 发送请求
          requestRef.current({})
        }}
      />
    </div>
  );
};
```

希望我的回答能够帮到你。

## zh19921205

我也遇见了pro-table，搜索列有3行共9个，最后一个选择框会有联动效果，联动效果用renderFormItem中form.getFieldValue来判断的，出来第10个在第四行第一个，这时候点击重置，就会出现只剩label占位的情况，处理办法是给table设置key，重置onReset事件修改key刷新组件。

`const [refresh, setRefresh] = useState<number>(1);`

`const forceUpdate = () => {
    setRefresh(Math.random());
  };`

`<ProTable
      key={refresh}
      onReset={forceUpdate}
     ...
    />`
