# 🧐[问题] SchemaForm layoutType="StepsForm"时，官方文档并不支持stepsFormRender，submitter属性 但是我写出来后生效了

`🎖️  featrue`,`AI Reply`

提问前先看看：

https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md

### 🧐 问题描述

SchemaForm layoutType="StepsForm"时，官方文档并不支持stepsFormRender，submitter属性 但是我写出来后生效了
在SchemaForm 写出StepsForm的属性能够生效，因为官方文档没写出来，并且ts检测报错，看一层源码，并没有这个属性，请问后面的版本跟新会不会到时我这种写法不生效？

### 💻 示例代码

```
  <BetaSchemaForm
          layoutType="StepsForm"
          steps={[
            {
              title: '第一步',
            },
            {
              title: '第二步',
            },
            {
              title: '第三步',
            },
          ]}

          submitter={{
            render: (
              props: SubmitterProps<Record<string, any>> & {
                step: number;
                onPre: () => void;
                form?: FormInstance<any> | undefined;
              } & {
                submit: () => void;
                reset: () => void;
              },
            ) => {
              if (props.step === 0) {
                return (
                  <Button type="primary" onClick={() => props.onSubmit?.()}>
                    去第二步 {'>'}
                  </Button>
                );
              }
            stepsFormRender={(dom, submitter) => {
                return (
                  <Modal
                    title="分步表单"
                    width={800}
                    onCancel={() => setVisible(false)}
                    visible={visible}
                    footer={submitter}
                    destroyOnClose
                  >
                    {dom}
                  </Modal>
                );
              }}
              if (props.step === 1) {
                return [
                  <Button key="pre" onClick={() => props.onPre?.()}>
                    返回第一步
                  </Button>,
                  <Button type="primary" key="goToTree" onClick={() => props.onSubmit?.()}>
                    去第三步 {'>'}
                  </Button>,
                ];
              }

              return [
                <Button key="gotoTwo" onClick={() => props.onPre?.()}>
                  {'<'} 返回第二步
                </Button>,
                <Button type="primary" key="goToTree" onClick={() => props.onSubmit?.()}>
                  提交 √
                </Button>,
              ];
            },
          }}
          onFinish={async (values) => {
            console.log(values);
          }}
          columns={columnSteps}
        />
```

### 🚑 其他信息

![image](https://user-images.githubusercontent.com/61341868/142750212-e81174be-4384-48ca-90c0-e5d687ebeb48.png)

## Lands-1203

我不太喜欢用html方式写表单，而是倾向于json配置表单

## chenshuai2144

你可以帮忙写个类型和测试用例。有了测试用例的功能就删除不了了

## Lands-1203

> 你可以帮忙写个类型和测试用例。有了测试用例的功能就删除不了了

https://codesandbox.io/s/schema-biao-dan-forked-x8xon?file=/App.tsx
时这个意思嘛？

## chenshuai2144

是把我们的项目拉下来，增加个功能进去

## 8283792

@chenshuai2144 你好，
![image](https://user-images.githubusercontent.com/23225531/154624061-fe983d9c-253b-418d-b40d-849f0067b15d.png)
上述例子中添加formRef属性，formRef里面的方法不生效

## 8283792

@chenshuai2144 我需要实现在步骤表单中每次点击下一步获取当前表单的值

## chenshuai2144

帮忙写个测试用例把，没有这个测试用例，修改的时候就不一定能改对

## Lands-1203

> @chenshuai2144 我需要实现在步骤表单中每次点击下一步获取当前表单的值

写错了

在layoutype=“stepsForm”时，只有通过

```
const formMapRef = useRef<React.MutableRefObject<ProFormInstance<any> | undefined>[]>([]);
  <BetaSchemaForm<Record<string, any>>
      formMapRef={formMapRef}
```

这样才能拿到值，formMapRef.current这里面是一个数组，每个数组对应每个分布表单formRef

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

好的，那我这里提供一个测试用例，你可以在自己的项目里面试试看。

```typescript
import React from "react";
import { mount } from "enzyme";
import { BetaSchemaForm } from "@ant-design/pro-form";
import { Steps } from "antd";

const { Step } = Steps;

describe("BetaSchemaForm StepsForm", () => {
  it("should submit and got all steps form values", async () => {
    const wrapper = mount(
      <BetaSchemaForm
        layoutType="StepsForm"
        steps={[
          {
            title: "Step 1",
            description: "This is a description.",
            // eslint-disable-next-line react/display-name
            subTitleRender: () => {
              return <>Custom SubTitle</>;
            },
          },
          {
            title: "Step 2",
            description: "This is a description.",
          },
          {
            title: "Step 3",
            description: "This is a description.",
          },
        ]}
        onFinish={async (values) => {
          expect(values[0]).toEqual({ name: "name1" });
          expect(values[1]).toEqual({ name: "name2" });
          expect(values[2]).toEqual({ name: "name3" });
        }}
      >
        <Step key="first" name="1">
          <BetaSchemaForm.Item
            name="name"
            index={0}
            label="Step 1"
            rules={[{ required: true }]}
          />
        </Step>
        <Step key="second" name="2">
          <BetaSchemaForm.Item
            name="name"
            index={1}
            label="Step 2"
            rules={[{ required: true }]}
          />
        </Step>
        <Step key="third" name="3">
          <BetaSchemaForm.Item
            name="name"
            index={2}
            label="Step 3"
            rules={[{ required: true }]}
          />
        </Step>
      </BetaSchemaForm>
    );

    const form = wrapper.find('form').at(0);

    // submit first form, check the first value
    wrapper
      .find(".ant-steps-item-title[title='Step 1']")
      .simulate("click");

    form.simulate("submit");
    await new Promise((resolve) => setTimeout(resolve, 0));
    expect(wrapper.find(".ant-form-item-explain").at(0).text()).toContain(
      "请输入 name"
    );

    wrapper
      .find("input")
      .at(0)
      .simulate("change", { target: { value: "name1" } });

    // submit second form, check the second value
    wrapper
      .find(".ant-steps-item-title[title='Step 2']")
      .simulate("click");

    form.simulate("submit");
    await new Promise((resolve) => setTimeout(resolve, 0));
    expect(wrapper.find(".ant-form-item-explain").at(0).text()).toContain(
      "请输入 name"
    );

    wrapper
      .find("input")
      .at(1)
      .simulate("change", { target: { value: "name2" } });

    // submit third form, check the third value
    wrapper
      .find(".ant-steps-item-title[title='Step 3']")
      .simulate("click");

    form.simulate("submit");
    await new Promise((resolve) => setTimeout(resolve, 0));
    expect(wrapper.find(".ant-form-item-explain").at(0).text()).toContain(
      "请输入 name"
    );

    wrapper
      .find("input")
      .at(2)
      .simulate("change", { target: { value: "name3" } });
  });
});
```

如果你的测试用例能够通过了，就代表目前 BetaSchemaForm 的 `StepsForm` 是 ok 的。

在测试用例里我们通过 Mock 的方式，填入每个步骤的 Form.Item，然后设置 `onFinish` 方法去获取每一个步骤表单的值，并进行校验。
