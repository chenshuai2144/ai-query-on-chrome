# 👑 [需求] 希望QueryFilter的响应式断点规则能够自定义

`form`,`🎖️  featrue`,`AI Reply`

### 🥰 需求描述

现有规则如下：
容器宽度断点 | 单行展示表单列数（包含操作区域） | 默认布局
-- | -- | --
≧ 1352px | 4 列 | horizontal
≧ 1062px | 3 列 | horizontal
≧ 701px && < 1063px | 3 列 | horizontal
≧ 513px && < 701px | 2 列 | vertical
< 513px | 1 列 | vertical

希望能够自定义分辨率和列数

## hjqlc

可以用window.addEventListener('resize', callback)配合QueryFilter的span使用就可以了，不要用onResize，多个表单的时候会有问题。

```
import { useState, useEffect, useMemo } from 'react';
import { BetaSchemaForm } from '@ant-design/pro-form';
import { debounce } from 'lodash';

export default (props) => {
  const [span, setSpan] = useState(props.span || 8);
  const [layout, setLayout] = useState(props.layout || 'horizontal');

  const [columns] = useState([
    {
      title: '字段1',
      dataIndex: 'field1',
    },
    {
      title: '字段2',
      dataIndex: 'field2',
    },
    {
      title: '字段3',
      dataIndex: 'field3',
    },
    {
      title: '字段4',
      dataIndex: 'field4',
    },
    {
      title: '字段5',
      dataIndex: 'field5',
    },
    {
      title: '字段6',
      dataIndex: 'field6',
    },
    {
      title: '字段7',
      dataIndex: 'field7',
    },
  ]);

  useEffect(() => {
    const debounceFn = debounce(() => {
      // todo
      let newSpan = span;
      let newLayout = layout;
      const width = window.innerWidth;
      if (width >= 1600) {
        newSpan = 4;
        newLayout = 'horizontal';
      } else if (width >= 1200) {
        newSpan = 6;
        newLayout = 'vertical';
      } else if (width >= 960) {
        newLayout = 'horizontal';
        newSpan = 8;
      } else if (width >= 720) {
        newLayout = 'vertical';
        newSpan = 12;
      } else {
        newLayout = 'horizontal';
        newSpan = 24;
      }
      setSpan(newSpan);
      setLayout(newLayout);
    }, 50);
    window.addEventListener('resize', debounceFn);
    return () => window.removeEventListener('resize', debounceFn);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return useMemo(() => {
    <BetaSchemaForm
      columns={columns}
      span={span}
      layout={layout}
      layoutType="QueryFilter"
    />;
  }, [span, layout, props]);
};
```

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

很棒！你的解决方案非常详细，用到了React Hooks的useState、useEffect和useMemo，同时也考虑到了debounce防抖优化性能。另外，使用事件监听来获取屏幕宽度，避免增加额外的依赖。如果用户需要自定义响应式断点，只需要修改useEffect中的判断条件即可。非常感谢你的回答！
