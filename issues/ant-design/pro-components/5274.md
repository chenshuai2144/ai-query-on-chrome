# 关于ProTable组件的节流阀问题

`table`,`🎖️  featrue`

### 🧐 问题描述

ProTable组件的request，应该是有使用节流阀的。对于数据查询，如果想在onChange事件，就触发request请求，可能会有问题。如果是选择类的，可能不会有问题，但如果是输入类的，像Input类的组件，刚输入时，就触发了request请求，等输入完了，可能就不触发请求了，导致查询的结果会有误，甚至我输入完之后，再点“查询”按钮，也不会再触发request请求。像这种问题，不知该如何处理，还是说就不应该在onChange触发rquest请求。如果只是想要控制查询频率，可以使用防抖动函数，但节流阀会对onChange产生问题，不知像这个问题，该如何处理？

## snowmandxp

应该来说，ProTable的防抖动是有Bug的，在useFetchData的fetchList函数中：

```
if (loading || requesting.current || !getData) {
    return [];
}
```

如果调用request请求，还在loading状态，说明上一次request请求还没有结束，这时直接返回了空数组。这样前一次的调用返回的比后一次调用晚，ProTable显示的是前一次调用的数据，这样真实的表格数据和查询条件是不一致的，出现BUG。当在loading状态时，应该不能直接返回为空的。

## snowmandxp

不知如果改成这样，是否有问题：

```
// fetchList：
    /** 请求数据 */
    const fetchList = async (isPolling) => {

        if(loading || requesting.current) {
            return "loading";
        }

        if(!getData) {
            return [];
        }

// fetchListDebounce：
    const fetchListDebounce = useDebounceFn(async (isPolling) => {
        if (pollingSetTimeRef.current) {
            clearTimeout(pollingSetTimeRef.current);
        }

        const msg = await fetchList(isPolling);

        if(msg === "loading") {
            fetchListDebounce.run(false);
        }
        . . .
```

## starhu521

是有这个问题，监听表单变化，触发submit，这样表格的防抖导致最后发出的请求不是最后的表单数据。比如input输入12345，最后发出的请求可能是123

## chenshuai2144

通过去抖而不是节流来解呢？

## snowmandxp

> 通过去抖而不是节流来解呢？

是我说错了，本身就是去抖，问题的关键不在于去抖，而在于如果正在请求数据，就直接返回了

## starhu521

实际请求那里，我看已经有防抖了，只是上层在请求等待的过程再收到请求会直接返回，导致返回结果和实际查询数据不一致

## chenshuai2144

理论上不会的，最新的数据会覆盖旧的。

## starhu521

>

基本必复现的，只需要把mock请求的数据返回延迟时间加长一点，比如2s，输入框快速输入数据，然后监听form values change，手动触发form submit，就能看到最后发出的请求是输入框数据的一部分，最后的都被取消了

## codedart2018

ref #5822

## linhuiw

这个问题有什么最新进展么？

看起来是这里的代码有问题，tableLoading 的时候，如果这么写，会导致 loading 期间的搜索条件变更输入不触发表格的重新请求。

https://github.com/ant-design/pro-components/blob/3b727d899aeb8fd7d8b8fb3926bd6a037fc54a55/packages/table/src/useFetchData.tsx#L165-L172

## fengliner

不只是loading问题，requesting.current是内部判断当前是否在请求中，只要上次请求没有结束，改变表单的值也不会重新发请求了。

## lxow456

这个问题有解决方案了嘛 @chenshuai2144

## chenshuai2144

现在会销毁了 你试试
