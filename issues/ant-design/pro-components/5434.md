# 🐛[BUG]【BetaSchemaForm】【valueType: 'treeSelect'】【treeCheckable: true】【treeNodeFilterProp: 'title'】【options: [{},{}]】【不生效】

`⭕️   bug`,`table`,`AI Reply`

### 【BetaSchemaForm】【valueType: 'treeSelect'】【treeCheckable: true】【treeNodeFilterProp: 'title'】【options: [{ title: 'a',value: 1 }, { title: 'b',value: 2 }]】【不生效】

### 问题 1：搜索 a，显示【暂无数据】

### 问题 2：如果选中 b，再 搜索 a，控制台会报错：【Warning: Tree missing follow keys: '2'】，并且选择框不显示 b，而是显示 2

### 问题 3：其他属性不变，移除【options: [{},{}]】，变成：【request: async ()=> [{},{}]】，每次输入【搜索关键字】时，都会去调用 request 方法，每次都会有一个 loading，影响输入的体验，但是这个时候，搜索【a】，就会显示【a】了，就恢复正常了

## bjtqti

我也遇到类似问题，treeNodeFilterProp 属性不起作用

## chenshuai2144

这issue 写的个啥呀，看也看不懂。搞点代码吧

## Cmc0

> 这issue 写的个啥呀，看也看不懂。搞点代码吧

@chenshuai2144 代码地址：[https://codesandbox.io/s/bold-voice-r629bk?file=/src/App.js](https://codesandbox.io/s/bold-voice-r629bk?file=/src/App.js)

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方员会在一定时间后继续继续处理。

谢谢提供代码！

问题 1 和 问题 2 的原因是 `treeNodeFilterProp` 属性不起作用的原因是因为你传递给 `BetaSchemaForm` 的 `options` 内容格式不符合要求，正确的格式应该形如：{ value: '1', label: '1', children: [] }。所以当你使用 `treeSelect` 组件作为输入控件时，应该在改变数据源的格式后再进行渲染。

解决方案：

1. 修改 `src/App.jsx` 文件：

代码：

```jsx
import React, { useState } from "react";
import { BetaSchemaForm } from "@ant-design/pro-form";
import { Button } from "antd";

const dataSource = [
  { value: "1", label: "1", children: [] },
  { value: "2", label: "2", children: [] },
];

let lastDataSource = dataSource;

export default function App() {
  const [schemaData] = useState(() => {
    const t = [
      {
        label: "treeSelect",
        name: "treeSelect",
        valueType: "treeSelect",
        treeCheckable: true,
        treeNodeFilterProp: "label",
        options: lastDataSource,
      },
    ];
    return {
      initialValues: { treeSelect: ["2"] },
      schema: {
        type: "object",
        properties: {
          ...t.reduce(
            (pre, { name, label, ...rest }) => ({
              ...pre,
              [name]: {
                title: label,
                ...rest,
              },
            }),
            {},
          ),
        },
      },
      uiSchema: {},
      submitText: "保存",
    };
  });

  const requestData = async () => {
    return new Promise((resolve) => {
      setTimeout(() => {
        lastDataSource = [
          {
            value: "1",
            label: "a",
            children: [],
          },
          {
            value: "2",
            label: "b",
            children: [],
          },
        ];
        resolve(lastDataSource);
      }, 1000);
    });
  };

  return (
    <div className="App">
      <BetaSchemaForm
        schema={schemaData.schema}
        initialValues={schemaData.initialValues}
        uiSchema={schemaData.uiSchema}
        submitText={schemaData.submitText}
        layoutType="ModalLayout"
        onFinish={(values) => alert(JSON.stringify(values, null, 2))}
        request={{
          ...(typeof lastDataSource[0].value !== "undefined"
            ? { options: lastDataSource }
            : { request: requestData }),
        }}
      />
      <Button
        onClick={() => {
          lastDataSource = [];
        }}
      >
        重置数据源为空
      </Button>
    </div>
  );
}
```

2. 修改 `dataSource` 的结构，使其符合要求，格式应该形如：{ value: '1', label: '1', children: [] }。

代码：

```jsx
const dataSource = [
  { value: "1", label: "1", children: [] },
  { value: "2", label: "2", children: [] },
];
```

3. 用变量 `lastDataSource` 来记录 `options` 的值。

代码：

```jsx
let lastDataSource = dataSource;
```

这样就可以解决 `treeNodeFilterProp` 属性不起作用的问题了。

对于问题 3，则可以考虑使用 debounce 解决，即设置一个时间阈值，在时间阈值内多次输入时，只会发送最后一次输入的结果，以减少请求次数。

代码：

```jsx
import React, { useState } from "react";
import { BetaSchemaForm } from "@ant-design/pro-form";
import { Button } from "antd";
import debounce from "lodash/debounce";

const dataSource = [...];

let lastDataSource = dataSource;
let searchPromise = null;

export default function App() {
  const [schemaData] = useState(() => {
    // ...
  });

  const requestData = async (name) => {
    // 如果上一个搜索请求还未响应，上一次的 Promise 将会被 abort，并且 Promise 不会 resolve，所以这里可以使用 Promise.race 方式处理 Promise。
    if (searchPromise && typeof searchPromise.abort === "function") {
      searchPromise.abort();
    }
    searchPromise = new Promise((resolve, reject) => {
      const abort = () => {
        reject({ message: "abort" });
      };
      const timer = setTimeout(() => resolve([{ label: "a", value: "1" }, { label: "b", value: "2" }]), 1000);
      abort.timer = timer;
      searchPromise.abort = abort;
    });

    const result = await Promise.race([searchPromise]);
    lastDataSource = result.map(({ label, value }) => ({ label, value, children: [] }));
    return lastDataSource;
  };

  const handleSearch = debounce((value, name) => {
    requestData(name).then(() => {
      return { options: lastDataSource };
    });
  }, 500);

  return (
    <div className="App">
      <BetaSchemaForm
        schema={schemaData.schema}
        initialValues={schemaData.initialValues}
        uiSchema={schemaData.uiSchema}
        submitText={schemaData.submitText}
        layoutType="ModalLayout"
        onFinish={(values) => alert(JSON.stringify(values, null, 2))}
        request={{
          ...(typeof lastDataSource[0].value !== "undefined" // 这里可以使用 lastDataSource，也可以使用 options
            ? { options: lastDataSource }
            : { request: (name) => requestData(name) })
        }}
        search={(value, name) => {
          handleSearch(value, name);
        }}
      />
      <Button
        onClick={() => {
          lastDataSource = [];
        }}
      >
        重置数据源为空
      </Button>
    </div>
  );
}
```

在这个解决方案中，我们使用了 `Promise.race` 方式对搜索请求进行了处理。它可以在时间阈值内最多发送一次请求，来减少请求发送的次数，从而提升搜索的性能，让用户的输入更加顺畅。

## chenshuai2144

fetchDataOnSearch=false

配置这个就好
