# 🐛[BUG]ModalForm 提前销毁会报Can't perform a React state update on an unmounted component异常

### 🐛 bug 描述

我们的应用场景是在 ModalForm 的 onFinish 事件内调用 props.callbackxxx 返回提交成功的数据给上局组件做后续处理。在上层组件中
ModalForm 通过 boolen && <ModalForm > 做 ModalForm 的 render ，这样在 props.callbackxxx 中如果提前将 render 条件置 false会造成 ModalForm 组件在执行 onFinish 后续流程前被销毁。看了代码 onFinish 后续会做 setLoading 和 setVisible 等操作，这里就会产生 React Can't perform a React state update on an unmounted component 异常

![image](https://user-images.githubusercontent.com/6634875/178646514-a666d372-0d87-495c-86d1-d29b463a3bac.png)

### 📷 复现代码

```
const Main: React.FC<any> = (props) => {
  const [visable, setVisable] = useState(false);
  return (
    <>
      {visable && <M onOK={values => { setVisable(false) }}></M>}
      <h1>测试页面</h1>
      <div onClick={() => { setVisable(true) }}>点击弹出</div>
    </>
  )
}

const M: React.FC<any> = (props) => {
  return (<ModalForm
    visible={true}
    title={"这是ModalForm"}
    onFinish={
      async (values) => {
        props.onOK?.(values);
        return true;
      }
    }
  >
    <div>ModalForm</div>

  </ModalForm>
  )
}
```

### 🏞 我这边暂时做了个修复方案，检测到组件销毁的情况下取消所有后续流程

![image](https://user-images.githubusercontent.com/6634875/178646651-f4f9572a-bebb-4f6d-8fce-9e1fcec7a0b6.png)

![image](https://user-images.githubusercontent.com/6634875/178648028-42f1917a-fb35-4c54-b79d-b56b47c2a7ac.png)

完整代码：

```
export function ModalFormFix<T = Record<string, any>>({
  children,
  trigger,
  onVisibleChange,
  modalProps,
  onFinish,
  submitTimeout,
  title,
  width,
  visible: propVisible,
  ...rest
}: ModalFormProps<T>) {
  noteOnce(
    // eslint-disable-next-line @typescript-eslint/dot-notation
    !rest['footer'] || !modalProps?.footer,
    'ModalForm 是一个 ProForm 的特殊布局，如果想自定义按钮，请使用 submit.render 自定义。',
  );

  const context = useContext(ConfigProvider.ConfigContext);

  const [, forceUpdate] = useState([]);

  const refunmounted = useRef(false);
  useEffect(() => {
    return () => {
      console.log('unmounted');
      refunmounted.current = true;
    };
  }, []);

  const [loading, setLoading] = useState(false);
  const setWrappedLoading = (v: boolean) => {
    console.log(`setLoading=${v} , unmounted=${refunmounted.current}`);
    if (refunmounted.current) {
      return;
    }
    setLoading(v);
  };

  const [visible, setVisible] = useMergedState<boolean>(!!propVisible, {
    value: propVisible,
    onChange: onVisibleChange,
  });
  const setWrappedVisible = (v: boolean) => {
    console.log(`setVisible=${v} , unmounted=${refunmounted.current}`);
    if (refunmounted.current) {
      return;
    }
    setVisible(v);
  };

  const footerRef = useRef<HTMLDivElement | null>(null);

  const footerDomRef: React.RefCallback<HTMLDivElement> = useCallback((element) => {
    if (footerRef.current === null && element) {
      forceUpdate([]);
    }
    footerRef.current = element;
  }, []);

  const formRef = useRef<ProFormInstance>();

  useEffect(() => {
    if (visible && propVisible) {
      onVisibleChange?.(true);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [propVisible, visible]);

  const triggerDom = useMemo(() => {
    if (!trigger) {
      return null;
    }

    return React.cloneElement(trigger, {
      key: 'trigger',
      ...trigger.props,
      onClick: async (e: any) => {
        setWrappedVisible(!visible);
        trigger.props?.onClick?.(e);
      },
    });
  }, [setWrappedVisible, trigger, visible]);

  const submitterConfig = useMemo(() => {
    if (rest.submitter === false) {
      return false;
    }

    return merge(
      {
        searchConfig: {
          submitText: modalProps?.okText ?? context.locale?.Modal?.okText ?? '确认',
          resetText: modalProps?.cancelText ?? context.locale?.Modal?.cancelText ?? '取消',
        },
        resetButtonProps: {
          preventDefault: true,
          // 提交表单loading时，不可关闭弹框
          disabled: submitTimeout ? loading : undefined,
          onClick: (e: any) => {
            setWrappedVisible(false);
            modalProps?.onCancel?.(e);
          },
        },
      },
      rest.submitter,
    );
  }, [
    context.locale?.Modal?.cancelText,
    context.locale?.Modal?.okText,
    modalProps,
    rest.submitter,
    setWrappedVisible,
    loading,
    submitTimeout,
  ]);

  const contentRender = useCallback((formDom: any, submitter: any) => {
    return (
      <>
        {formDom}
        {footerRef.current && submitter ? createPortal(submitter, footerRef.current) : submitter}
      </>
    );
  }, []);

  const onFinishHandle = useCallback(
    async (values: T) => {
      const response = onFinish?.(values);

      if (submitTimeout && response instanceof Promise) {
        setWrappedLoading(true);

        const timer = setTimeout(() => setWrappedLoading(false), submitTimeout);
        response.finally(() => {
          clearTimeout(timer);
          setWrappedLoading(false);
        });
      }
      const result = await response;
      // 返回真值，关闭弹框
      if (result) {
        setWrappedVisible(false);
      }
      return result;
    },
    [onFinish, setWrappedVisible, submitTimeout],
  );

  return (
    <>
      <Modal
        title={title}
        width={width || 800}
        {...modalProps}
        visible={visible}
        onCancel={(e) => {
          // 提交表单loading时，阻止弹框关闭
          if (submitTimeout && loading) return;
          setWrappedVisible(false);
          modalProps?.onCancel?.(e);
        }}
        footer={
          rest.submitter !== false && (
            <div
              ref={footerDomRef}
              style={{
                display: 'flex',
                justifyContent: 'flex-end',
              }}
            />
          )
        }
      >
        <BaseForm
          formComponentType="ModalForm"
          layout="vertical"
          formRef={formRef}
          {...rest}
          submitter={submitterConfig}
          onFinish={async (values) => {
            const result = await onFinishHandle(values);
            console.log('after onFinishHandle', refunmounted.current);
            if (refunmounted.current) {
              return result;
            }
            const form = rest.formRef?.current ?? formRef.current;
            // 返回真值，重置表单
            if (result && form) {
              form.resetFields();
            }
            return result;
          }}
          contentRender={contentRender}
        >
          {children}
        </BaseForm>
      </Modal>
      {triggerDom}
    </>
  );
}
```

## chenshuai2144

react17 是说这个组件解除销毁了，还在setState，一般是异步的时候设置的 不会引起问题的，可以忽略掉。
如果你使用了 react 18 这个warning是不会出现的

## Grart

你意思是 R18 会修复这种组件销毁后setState的问题？

## hsbtr

> react17 是说这个组件解除销毁了，还在setState，一般是异步的时候设置的 不会引起问题的，可以忽略掉。 如果你使用了 react 18 这个warning是不会出现的

LoginForm在onFinish中跳转页面也会报这个错误，也是因为这个原因嘛
