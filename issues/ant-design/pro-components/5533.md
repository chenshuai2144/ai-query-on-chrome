# ğŸ›[BUG]ModalForm æå‰é”€æ¯ä¼šæŠ¥Can't perform a React state update on an unmounted componentå¼‚å¸¸

### ğŸ› bug æè¿°

æˆ‘ä»¬çš„åº”ç”¨åœºæ™¯æ˜¯åœ¨ ModalForm çš„ onFinish äº‹ä»¶å†…è°ƒç”¨ props.callbackxxx è¿”å›æäº¤æˆåŠŸçš„æ•°æ®ç»™ä¸Šå±€ç»„ä»¶åšåç»­å¤„ç†ã€‚åœ¨ä¸Šå±‚ç»„ä»¶ä¸­
ModalForm é€šè¿‡ boolen && <ModalForm > åš ModalForm çš„ render ï¼Œè¿™æ ·åœ¨ props.callbackxxx ä¸­å¦‚æœæå‰å°† render æ¡ä»¶ç½® falseä¼šé€ æˆ ModalForm ç»„ä»¶åœ¨æ‰§è¡Œ onFinish åç»­æµç¨‹å‰è¢«é”€æ¯ã€‚çœ‹äº†ä»£ç  onFinish åç»­ä¼šåš setLoading å’Œ setVisible ç­‰æ“ä½œï¼Œè¿™é‡Œå°±ä¼šäº§ç”Ÿ React Can't perform a React state update on an unmounted component å¼‚å¸¸

![image](https://user-images.githubusercontent.com/6634875/178646514-a666d372-0d87-495c-86d1-d29b463a3bac.png)

### ğŸ“· å¤ç°ä»£ç 

```
const Main: React.FC<any> = (props) => {
  const [visable, setVisable] = useState(false);
  return (
    <>
      {visable && <M onOK={values => { setVisable(false) }}></M>}
      <h1>æµ‹è¯•é¡µé¢</h1>
      <div onClick={() => { setVisable(true) }}>ç‚¹å‡»å¼¹å‡º</div>
    </>
  )
}

const M: React.FC<any> = (props) => {
  return (<ModalForm
    visible={true}
    title={"è¿™æ˜¯ModalForm"}
    onFinish={
      async (values) => {
        props.onOK?.(values);
        return true;
      }
    }
  >
    <div>ModalForm</div>

  </ModalForm>
  )
}
```

### ğŸ æˆ‘è¿™è¾¹æš‚æ—¶åšäº†ä¸ªä¿®å¤æ–¹æ¡ˆï¼Œæ£€æµ‹åˆ°ç»„ä»¶é”€æ¯çš„æƒ…å†µä¸‹å–æ¶ˆæ‰€æœ‰åç»­æµç¨‹

![image](https://user-images.githubusercontent.com/6634875/178646651-f4f9572a-bebb-4f6d-8fce-9e1fcec7a0b6.png)

![image](https://user-images.githubusercontent.com/6634875/178648028-42f1917a-fb35-4c54-b79d-b56b47c2a7ac.png)

å®Œæ•´ä»£ç ï¼š

```
export function ModalFormFix<T = Record<string, any>>({
  children,
  trigger,
  onVisibleChange,
  modalProps,
  onFinish,
  submitTimeout,
  title,
  width,
  visible: propVisible,
  ...rest
}: ModalFormProps<T>) {
  noteOnce(
    // eslint-disable-next-line @typescript-eslint/dot-notation
    !rest['footer'] || !modalProps?.footer,
    'ModalForm æ˜¯ä¸€ä¸ª ProForm çš„ç‰¹æ®Šå¸ƒå±€ï¼Œå¦‚æœæƒ³è‡ªå®šä¹‰æŒ‰é’®ï¼Œè¯·ä½¿ç”¨ submit.render è‡ªå®šä¹‰ã€‚',
  );

  const context = useContext(ConfigProvider.ConfigContext);

  const [, forceUpdate] = useState([]);

  const refunmounted = useRef(false);
  useEffect(() => {
    return () => {
      console.log('unmounted');
      refunmounted.current = true;
    };
  }, []);

  const [loading, setLoading] = useState(false);
  const setWrappedLoading = (v: boolean) => {
    console.log(`setLoading=${v} , unmounted=${refunmounted.current}`);
    if (refunmounted.current) {
      return;
    }
    setLoading(v);
  };

  const [visible, setVisible] = useMergedState<boolean>(!!propVisible, {
    value: propVisible,
    onChange: onVisibleChange,
  });
  const setWrappedVisible = (v: boolean) => {
    console.log(`setVisible=${v} , unmounted=${refunmounted.current}`);
    if (refunmounted.current) {
      return;
    }
    setVisible(v);
  };

  const footerRef = useRef<HTMLDivElement | null>(null);

  const footerDomRef: React.RefCallback<HTMLDivElement> = useCallback((element) => {
    if (footerRef.current === null && element) {
      forceUpdate([]);
    }
    footerRef.current = element;
  }, []);

  const formRef = useRef<ProFormInstance>();

  useEffect(() => {
    if (visible && propVisible) {
      onVisibleChange?.(true);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [propVisible, visible]);

  const triggerDom = useMemo(() => {
    if (!trigger) {
      return null;
    }

    return React.cloneElement(trigger, {
      key: 'trigger',
      ...trigger.props,
      onClick: async (e: any) => {
        setWrappedVisible(!visible);
        trigger.props?.onClick?.(e);
      },
    });
  }, [setWrappedVisible, trigger, visible]);

  const submitterConfig = useMemo(() => {
    if (rest.submitter === false) {
      return false;
    }

    return merge(
      {
        searchConfig: {
          submitText: modalProps?.okText ?? context.locale?.Modal?.okText ?? 'ç¡®è®¤',
          resetText: modalProps?.cancelText ?? context.locale?.Modal?.cancelText ?? 'å–æ¶ˆ',
        },
        resetButtonProps: {
          preventDefault: true,
          // æäº¤è¡¨å•loadingæ—¶ï¼Œä¸å¯å…³é—­å¼¹æ¡†
          disabled: submitTimeout ? loading : undefined,
          onClick: (e: any) => {
            setWrappedVisible(false);
            modalProps?.onCancel?.(e);
          },
        },
      },
      rest.submitter,
    );
  }, [
    context.locale?.Modal?.cancelText,
    context.locale?.Modal?.okText,
    modalProps,
    rest.submitter,
    setWrappedVisible,
    loading,
    submitTimeout,
  ]);

  const contentRender = useCallback((formDom: any, submitter: any) => {
    return (
      <>
        {formDom}
        {footerRef.current && submitter ? createPortal(submitter, footerRef.current) : submitter}
      </>
    );
  }, []);

  const onFinishHandle = useCallback(
    async (values: T) => {
      const response = onFinish?.(values);

      if (submitTimeout && response instanceof Promise) {
        setWrappedLoading(true);

        const timer = setTimeout(() => setWrappedLoading(false), submitTimeout);
        response.finally(() => {
          clearTimeout(timer);
          setWrappedLoading(false);
        });
      }
      const result = await response;
      // è¿”å›çœŸå€¼ï¼Œå…³é—­å¼¹æ¡†
      if (result) {
        setWrappedVisible(false);
      }
      return result;
    },
    [onFinish, setWrappedVisible, submitTimeout],
  );

  return (
    <>
      <Modal
        title={title}
        width={width || 800}
        {...modalProps}
        visible={visible}
        onCancel={(e) => {
          // æäº¤è¡¨å•loadingæ—¶ï¼Œé˜»æ­¢å¼¹æ¡†å…³é—­
          if (submitTimeout && loading) return;
          setWrappedVisible(false);
          modalProps?.onCancel?.(e);
        }}
        footer={
          rest.submitter !== false && (
            <div
              ref={footerDomRef}
              style={{
                display: 'flex',
                justifyContent: 'flex-end',
              }}
            />
          )
        }
      >
        <BaseForm
          formComponentType="ModalForm"
          layout="vertical"
          formRef={formRef}
          {...rest}
          submitter={submitterConfig}
          onFinish={async (values) => {
            const result = await onFinishHandle(values);
            console.log('after onFinishHandle', refunmounted.current);
            if (refunmounted.current) {
              return result;
            }
            const form = rest.formRef?.current ?? formRef.current;
            // è¿”å›çœŸå€¼ï¼Œé‡ç½®è¡¨å•
            if (result && form) {
              form.resetFields();
            }
            return result;
          }}
          contentRender={contentRender}
        >
          {children}
        </BaseForm>
      </Modal>
      {triggerDom}
    </>
  );
}
```

## chenshuai2144

react17 æ˜¯è¯´è¿™ä¸ªç»„ä»¶è§£é™¤é”€æ¯äº†ï¼Œè¿˜åœ¨setStateï¼Œä¸€èˆ¬æ˜¯å¼‚æ­¥çš„æ—¶å€™è®¾ç½®çš„ ä¸ä¼šå¼•èµ·é—®é¢˜çš„ï¼Œå¯ä»¥å¿½ç•¥æ‰ã€‚
å¦‚æœä½ ä½¿ç”¨äº† react 18 è¿™ä¸ªwarningæ˜¯ä¸ä¼šå‡ºç°çš„

## Grart

ä½ æ„æ€æ˜¯ R18 ä¼šä¿®å¤è¿™ç§ç»„ä»¶é”€æ¯åsetStateçš„é—®é¢˜ï¼Ÿ

## hsbtr

> react17 æ˜¯è¯´è¿™ä¸ªç»„ä»¶è§£é™¤é”€æ¯äº†ï¼Œè¿˜åœ¨setStateï¼Œä¸€èˆ¬æ˜¯å¼‚æ­¥çš„æ—¶å€™è®¾ç½®çš„ ä¸ä¼šå¼•èµ·é—®é¢˜çš„ï¼Œå¯ä»¥å¿½ç•¥æ‰ã€‚ å¦‚æœä½ ä½¿ç”¨äº† react 18 è¿™ä¸ªwarningæ˜¯ä¸ä¼šå‡ºç°çš„

LoginFormåœ¨onFinishä¸­è·³è½¬é¡µé¢ä¹Ÿä¼šæŠ¥è¿™ä¸ªé”™è¯¯ï¼Œä¹Ÿæ˜¯å› ä¸ºè¿™ä¸ªåŸå› å˜›
