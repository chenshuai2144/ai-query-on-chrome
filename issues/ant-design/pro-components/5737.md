# 🧐[问题]问题]想请教一下proTable怎么做本地排序

`🤷🏼 How to use`,`AI Reply`

sorter为true的时候点击表格头的排序按钮每次触发request，求教如何本地排序，不去触发request

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方员会在一定时间后继续继续处理。

对于 antd 的 ProTable 组件，可以通过在 columns 中设置 sorter 函数来实现本地排序。sorter 函数会在触发排序时被调用，并提供当前排序状态信息和操作方法。

具体实现如下：

```jsx
import { Table } from "antd";

const dataSource = [
  {
    key: "1",
    name: "John Brown",
    age: 32,
  },
  {
    key: "2",
    name: "Jim Green",
    age: 42,
  },
  {
    key: "3",
    name: "Joe Black",
    age: 32,
  },
  {
    key: "4",
    name: "Jim Red",
    age: 32,
  },
];

const columns = [
  {
    title: "Name",
    dataIndex: "name",
    key: "name",
    sorter: (a, b) => a.name.localeCompare(b.name), // 设置 sorter 函数
  },
  {
    title: "Age",
    dataIndex: "age",
    key: "age",
    sorter: (a, b) => a.age - b.age, // 设置 sorter 函数
  },
];

function App() {
  return <Table dataSource={dataSource} columns={columns} />;
}
```

在以上例子中，表格数据源 dataSource 和列配置 columns 与 antd 官方文档中的例子相同。在列配置中，我们设置了两列的 sorter 函数，分别是按名字排序和按年龄排序，这两个函数分别返回排好序的数据 a 和 b。

如果需要实现多列排序，则需要在对应列的 sorter 函数中实现一样的逻辑。

另外需要注意的是，使用本地排序时需要禁用 ProTable 的 manualRequest 属性，即设置 manualRequest={false}。这样在排序时就不会发送排序相关请求了。

```jsx
import { ProTable } from "@ant-design/pro-table";

const columns = [
  {
    title: "Name",
    dataIndex: "name",
    key: "name",
    sorter: (a, b) => a.name.localeCompare(b.name),
  },
  {
    title: "Age",
    dataIndex: "age",
    key: "age",
    sorter: (a, b) => a.age - b.age,
  },
];

function App() {
  return (
    <ProTable
      columns={columns}
      dataSource={dataSource}
      manualRequest={false} // 关闭 manualRequest
    />
  );
}
```

希望这些能帮到您！更多细节可以查看官方文档 https://ant.design/components/table-cn/#API 。

## dxall

不使用dataSource作为数据源，使用request怎么处理

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

如果你需要使用 `request` 来获取数据，同时又需要实现本地排序的功能，你可以按照下面的方式进行处理：

1. 在 `request` 函数中添加排序功能：在这个函数中通过只有 `params` 参数（包含分页、排序等信息）进行数据的请求。其中 `params.sorter` 即用于记录当前的排序信息，我们可以根据这个信息对数据进行排序，最后返回正确排序的列表数据。示例代码如下：

```jsx
import { request } from "umi";

const fetchTableData = async (params, sort, filters) => {
  const response = await request("/api/tableData", { params });
  let listData = response || [];

  // 如果当前有排序操作，根据 sorter 对 listData 进行排序
  if (params.sorter && params.sorter.field) {
    const { field, order } = params.sorter;
    listData = listData.sort((a, b) => {
      if (order === "ascend") {
        return a[field] - b[field];
      } else {
        return b[field] - a[field];
      }
    });
  }

  // ...

  return {
    data: listData,
    // ...
  };
};
```

在上述代码中，`fetchTableData()` 函数通过调用 `request` 函数从服务器获取表格数据。进行排序之后，我们返回可用于渲染表格的正确排序的列表数据。

2. 在 ProTable 组件中配置请求函数 `request`：在 ProTable 的配置中，你需要传递请求数据的 `request` 函数，同时需要为每个可排序的列设置 `sorter` 属性。当用户点击排序按钮时，`sorter.field` 和 `sorter.order` 将会记录排序列和排序方式，在请求中作为参数传递到 `fetchTableData()` 函数中处理。

```jsx
import ProTable from "@ant-design/pro-table";

const columns = [
  {
    title: "姓名",
    dataIndex: "name",
    key: "name",
    sorter: true, // 允许表格列的排序
  },
  {
    title: "年龄",
    dataIndex: "age",
    key: "age",
    sorter: true, // 允许表格列的排序
  },
  {
    title: "地址",
    dataIndex: "address",
    key: "address",
  },
];

function Page() {
  return (
    <ProTable
      columns={columns}
      request={(params) => fetchTableData(params)} // 配置请求函数
      rowKey="key"
      search={false}
      pagination={{ pageSize: 10 }}
    />
  );
}
```

在上述代码中，我们将请求函数 `fetchTableData` 作为参数传递给了 `ProTable` 组件的 `request` 属性。同时为实现排序功能，将需要进行排序的列的 `sorter` 属性设置为 `true`。

这样当你在页面中运行这段代码时，你应该会发现每次点击该表格头部的可排序列时都会直接对当前分页数据进行排序处理，并且不会触发任何request请求。

## dxall

> > TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> > 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。
>
> 如果你需要使用 `request` 来获取数据，同时又需要实现本地排序的功能，你可以按照下面的方式进行处理：
>
> 1. 在 `request` 函数中添加排序功能：在这个函数中通过只有 `params` 参数（包含分页、排序等信息）进行数据的请求。其中 `params.sorter` 即用于记录当前的排序信息，我们可以根据这个信息对数据进行排序，最后返回正确排序的列表数据。示例代码如下：
>
> ```js
> import { request } from "umi";
>
> const fetchTableData = async (params, sort, filters) => {
>   const response = await request("/api/tableData", { params });
>   let listData = response || [];
>
>   // 如果当前有排序操作，根据 sorter 对 listData 进行排序
>   if (params.sorter && params.sorter.field) {
>     const { field, order } = params.sorter;
>     listData = listData.sort((a, b) => {
>       if (order === "ascend") {
>         return a[field] - b[field];
>       } else {
>         return b[field] - a[field];
>       }
>     });
>   }
>
>   // ...
>
>   return {
>     data: listData,
>     // ...
>   };
> };
> ```
>
> 在上述代码中，`fetchTableData()` 函数通过调用 `request` 函数从服务器获取表格数据。进行排序之后，我们返回可用于渲染表格的正确排序的列表数据。
>
> 2. 在 ProTable 组件中配置请求函数 `request`：在 ProTable 的配置中，你需要传递请求数据的 `request` 函数，同时需要为每个可排序的列设置 `sorter` 属性。当用户点击排序按钮时，`sorter.field` 和 `sorter.order` 将会记录排序列和排序方式，在请求中作为参数传递到 `fetchTableData()` 函数中处理。
>
> ```js
> import ProTable from "@ant-design/pro-table";
>
> const columns = [
>   {
>     title: "姓名",
>     dataIndex: "name",
>     key: "name",
>     sorter: true, // 允许表格列的排序
>   },
>   {
>     title: "年龄",
>     dataIndex: "age",
>     key: "age",
>     sorter: true, // 允许表格列的排序
>   },
>   {
>     title: "地址",
>     dataIndex: "address",
>     key: "address",
>   },
> ];
>
> function Page() {
>   return (
>     <ProTable
>       columns={columns}
>       request={(params) => fetchTableData(params)} // 配置请求函数
>       rowKey="key"
>       search={false}
>       pagination={{ pageSize: 10 }}
>     />
>   );
> }
> ```
>
> 在上述代码中，我们将请求函数 `fetchTableData` 作为参数传递给了 `ProTable` 组件的 `request` 属性。同时为实现排序功能，将需要进行排序的列的 `sorter` 属性设置为 `true`。
>
> 这样当你在页面中运行这段代码时，你应该会发现每次点击该表格头部的可排序列时都会直接对当前分页数据进行排序处理，并且不会触发任何request请求。

fetchTableData的params.sorter不存在

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

如果你的 `params` 中没有 `sorter`，则说明还没有进行排序操作。你可以默认当做是没有排序需求，直接从服务器端获取数据并返回。示例如下：

```js
const fetchTableData = async (params, sort, filters) => {
  const response = await request("/api/tableData", { params });
  const listData = response || [];

  return {
    data: listData,
    current: params.current || 1,
    pageSize: params.pageSize || 10,
    total: 100,
    success: true,
  };
};
```

这样就可以让 ProTable 的分页及搜索功能正常工作，并允许用户对表格列进行排序。

如果 `sorter` 参数存在，我们就可以对获取到的数据进行本地排序。具体实现方法可按前文提到的示例代码中实现。
