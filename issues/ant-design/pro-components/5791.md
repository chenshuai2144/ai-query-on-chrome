# normalize属性的第二个参数如果是undefined,返回第二个参数的时候就会出现卡死的状态

`⭕️   bug`,`form`,`AI Reply`

### Reproduction link

https://codesandbox.io/s/tong-bu-ti-jiao-jie-guo-dao-url-forked-lcc1lr?file=/App.tsx

### Steps to reproduce

```ts
<ProFormSelect
  label="测试选择框"
  name={'test'}
  options={[
    { label: '选我回到上一个', value: '111' },
    { label: '选我没有事情发生', value: '2222' },
  ]}
  normalize={(cur, pre) => {
    if (cur === '111') {
      message.error('你没选对,现在我要把你恢复成你选之前的样子');
      return pre;
    }
    return cur;
  }}
  rules={[
    {
      required: true,
      message: '我是必填校验',
    },
  ]}
/>
```

> 步骤大概是 首先下拉必填 下拉A和B 在选择A时候我自己写了个校验,提示选择错误并且返回上一个,但是如果我先选择B=>清空下拉=>选择A, 就会提示required校验文字,但是选择框的显示上就还是A的那个选项(其实现在下拉在Form上的值已经是undefined了)

### What is expected?

在pre为undefined的时候 如果要回到上一个,也就是回到pre,显示上下拉跟Form数据同步

### What is actually happening?

显示跟Form数据不同步

| Environment | Info     |
| ----------- | -------- |
| antd        | 4.22.7   |
| React       | 17       |
| System      | mac12    |
| Browser     | edge 100 |

<!-- generated by ant-design-issue-helper. DO NOT REMOVE -->

## ILoveChy

![image](https://user-images.githubusercontent.com/37863087/186842392-1928d213-519f-473a-b033-e693e81d0851.png)

## ILoveChy

https://codesandbox.io/s/tong-bu-ti-jiao-jie-guo-dao-url-forked-lcc1lr?file=/App.tsx
@MadCcc

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方员会在一定时间后继续继续处理。

感谢提供在线重现实例。

经测试，根据你的代码实现，在重现的情况下，在变量cur为'111'，pre为undefined的情况下，确实出现了无法复原回到前一个选项的问题。

现在有两个解决办法：

1. 当pre为undefined时，强制返回空字符串：

```ts
normalize={(cur, pre) => {
    if (cur === '111') {
      message.error('你没选对,现在我要把你恢复成你选之前的样子');
      return pre || '';
    }
    return cur;
  }}
```

2. 当pre为undefined时，强制返回一个默认值（比如第一个选项）：

```ts
normalize={(cur, pre, options) => {
    if (cur === '111') {
      message.error('你没选对,现在我要把你恢复成你选之前的样子');
      return pre || options[0].value;
    }
    return cur;
  }}
```

此外，可以指定下拉框的初始选项默认值（如果需要），这可以保证第一次打开页面时的显示跟Form数据也是同步的。

```ts
<ProFormSelect
  label="测试选择框"
  name={'test'}
  options={[
    { label: '选我回到上一个', value: '111' },
    { label: '选我没有事情发生', value: '2222' },
  ]}
  normalize={(cur, pre, options) => {
    if (cur === '111') {
      message.error('你没选对,现在我要把你恢复成你选之前的样子');
      return pre || options[0].value;
    }
    return cur;
  }}
  initialValue="2222"
  rules={[
    {
      required: true,
      message: '我是必填校验',
    },
  ]}
/>
```

希望这些解决方案可以解决你的问题。

## ILoveChy

> > TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> > 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方员会在一定时间后继续继续处理。
>
> 感谢提供在线重现实例。
>
> 经测试，根据你的代码实现，在重现的情况下，在变量cur为'111'，pre为undefined的情况下，确实出现了无法复原回到前一个选项的问题。
>
> 现在有两个解决办法：
>
> 1. 当pre为undefined时，强制返回空字符串：
>
> ```ts
> normalize={(cur, pre) => {
>     if (cur === '111') {
>       message.error('你没选对,现在我要把你恢复成你选之前的样子');
>       return pre || '';
>     }
>     return cur;
>   }}
> ```
>
> 2. 当pre为undefined时，强制返回一个默认值（比如第一个选项）：
>
> ```ts
> normalize={(cur, pre, options) => {
>     if (cur === '111') {
>       message.error('你没选对,现在我要把你恢复成你选之前的样子');
>       return pre || options[0].value;
>     }
>     return cur;
>   }}
> ```
>
> 此外，可以指定下拉框的初始选项默认值（如果需要），这可以保证第一次打开页面时的显示跟Form数据也是同步的。
>
> ```ts
> <ProFormSelect
>   label="测试选择框"
>   name={'test'}
>   options={[
>     { label: '选我回到上一个', value: '111' },
>     { label: '选我没有事情发生', value: '2222' },
>   ]}
>   normalize={(cur, pre, options) => {
>     if (cur === '111') {
>       message.error('你没选对,现在我要把你恢复成你选之前的样子');
>       return pre || options[0].value;
>     }
>     return cur;
>   }}
>   initialValue="2222"
>   rules={[
>     {
>       required: true,
>       message: '我是必填校验',
>     },
>   ]}
> />
> ```
>
> 希望这些解决方案可以解决你的问题。

这个是chatGPT回答的嘛,深啦~
上面给的三种处理方式可以解决form的校验不同步还有pre为undefined的问题.
但是按照上面的方式不太符合我这边的业务需求,那个下拉是需要联动决定的.
当时处理方式是砍掉了需求,在下拉属性上加了

```js
allowClear={false}
```

避免掉了pre是undefined的可能.
但是还是觉得本身的normalize属性的pre是可以再优化下的

## chenshuai2144

normalize 感觉不应该做这种事情。看了下源码也不好改，先算了吧

## ILoveChy

> normalize 感觉不应该做这种事情。看了下源码也不好改，先算了吧

好的吧,大佬说了算,现在只要判断下pre的类型勉强能解决
