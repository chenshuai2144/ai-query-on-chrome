# 🧐[问题] ProFormSelect 通过 request 更新选项以后如何自动清除已选择的数据？

提问前先看看：

https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md

### 🧐 问题描述

<!--
详细地描述问题，让大家都能理解
-->

比如一个城市选择器，跟随用户在另一个选项上选择的省份的变化发起请求，并生成新的城市列表。

如果在用户先选择了 `浙江->杭州`，然后把省份切换到 `广东`，这时候城市选择器更新，城市列表里不再有 `杭州` 一项，但是现实情况是城市选择器未展开的状态下仍然展示着 `杭州`，如果用户不主动切换城市，就会出现 `广东->杭州` 这样的结果。

是否有办法在城市选择器的列表更新时自动把不存在的已选择数据清空，或直接把任何已选择的数据清空也行？

### 💻 示例代码

```tsx
<ProFormSelect
    label="省份"
    name='province'
    request={async () => {
      const res = await getProvinceList();

      return res.rows.map((item) => ({
        label: item.name,
        value: item.id,
      }));
    }}
  />

<ProFormSelect
    label="城市"
    name='city'
    dependencies={province}
    request={async ({ province }) => {
      const res = await getCityList({ province });

      return res.rows.map((item) => ({
        label: item.name,
        value: item.id,
      }));
    }}
  />
```

<!--
如果你有解决方案，在这里清晰地阐述
-->

当然，可以通过 formRef.current.getFieldValue 监听数据变化，并手动写清空的逻辑，但是这样也破坏了dependencies的便利性，最好还是能在ProFormSelect组件内自动实现。

期望这样的效果：

```tsx
<ProFormSelect
  label="城市"
  name="city"
  // 期望这样的选项：
  autoClearInexistenceValue={true}
  // 或者
  autoClearWhenOptionsChange={true}
  dependencies={province}
  request={async ({ province }) => {
    const res = await getCityList({ province });

    return res.rows.map((item) => ({
      label: item.name,
      value: item.id,
    }));
  }}
/>
```

### 🚑 其他信息

<!--
如截图等其他信息可以贴在这里
-->

## chenshuai2144

`用formRef.setFieldValues({ name: null})`

这样设置一下

## mashirozx

但是这样有个问题，就是不方便对form field进行拆分，比如我把上面的省份-城市联动选择权拆分到一个单独的form group组件上，并在多个ProForm上调用这个form group，如果每次都要传一个formRef进去，基本就破坏了原本简便的组件拆分和dependency更新思路

## tanpengsccd

+1 .有类似问题. 设置 汽车型号(品牌-车系-年款-车型) 和 商品类型 也有 类似 问题.

## mashirozx

我最后替代的方法是，不使用dependencies，也不使用request：自己处理请求（useRequest），把数据通过setState传入options，然后通过useWatch监听字段当前数据，并检测options里面的数据是否包含选择的结果，如果不包含则调用setFieldValue清除

## mashirozx

一个业务组件的🌰：

```tsx
import { FormItemProvide, ProFormSelect } from "@ant-design/pro-components";
import { Button, Empty, Typography } from "antd";
import type { ComponentProps, FunctionComponent } from "react";
import { useContext, useLayoutEffect, useMemo } from "react";

import { useFormContext } from "@/hooks/useFormContext";
import { useFormValue } from "@/hooks/useFormValue";
import { useRequest } from "@/hooks/useRequest";

type ProFormAsyncSelectProps = Omit<
  ComponentProps<typeof ProFormSelect>,
  "options" | "request"
> & {
  request: (
    params: any,
    props: any,
  ) => Promise<{ value: string; label: string }[]>;
  /**
   * useRequest 的缓存 key：
   *
   * 请求唯一标识。如果设置了 cacheKey，我们会启用缓存机制。同一个 cacheKey 的数据全局同步。
   *
   * @default undefined
   */
  cacheKey: string;
  /**
   * useRequest 的缓存时间：
   *
   * - 设置缓存数据回收时间。默认缓存数据 5 分钟后回收
   * - 如果设置为 -1, 则表示缓存数据永不过期
   *
   * @default 5 * 60 * 1000
   */
  cacheTime?: number;
  /**
   * useRequest 的缓存数据保持新鲜时间：
   *
   * - 缓存数据保持新鲜时间。在该时间间隔内，认为数据是新鲜的，不会重新发请求
   * - 如果设置为 -1，则表示数据永远新鲜
   *
   * @default -1
   */
  staleTime?: number;
  /**
   * 请求结束后自动清除无效的已选项目回显：适用于选项更新后已选项目已不存在的情况
   *
   * @default true
   */
  autoClear?: boolean;
  /**
   * 已选项目为空时，自动选择选项中的第一项，可配合 `autoClear=false`、`autoSelectCallback` 一起使用
   */
  autoSelect?: boolean;
  /**
   * 自动选择后的回调函数
   */
  autoSelectCallback?: () => void;
  loadingDelay?: number;
  ready?: boolean;
};

const ProFormAsyncSelect: FunctionComponent<ProFormAsyncSelectProps> = ({
  params,
  request,
  cacheKey,
  cacheTime = 5 * 60 * 1000,
  staleTime = 0,
  autoClear = true,
  autoSelect,
  autoSelectCallback,
  loadingDelay,
  ready = true,
  ...proFormSelectProps
}) => {
  const { form } = useFormContext();

  const formItemProvide = useContext(FormItemProvide);

  const fieldName = useMemo(
    () =>
      (proFormSelectProps?.name ?? formItemProvide?.name) as string | undefined,
    [formItemProvide?.name, proFormSelectProps?.name],
  );

  const value = useFormValue<string>(fieldName);

  const { data, loading, error, refreshAsync } = useRequest(
    async () => {
      if (!request) {
        throw new Error("request is required");
      } else {
        const res = await request(params, undefined);

        const enums: Record<string, string> = {};

        res.forEach((item) => {
          enums[item.value] = item.label;
        });

        return enums;
      }
    },
    {
      cacheKey: cacheKey ? `${cacheKey}-${JSON.stringify(params)}` : undefined,
      cacheTime,
      staleTime,
      loadingDelay,
      ready,
      refreshDeps: [params, request],
    },
  );

  // auto clear
  const shouldAutoClear = useMemo(
    () =>
      ready && // useRequest is ready to fetch data
      !loading && // useRequest is not loading
      !error && // useRequest has no error
      data && // data is not empty
      Object.keys(data).length > 0 && // data length is not 0
      autoClear && // autoClear enabled
      !Array.isArray(value) && // won't handle array value
      !["", undefined, null].includes(value), // value is not empty
    [autoClear, data, error, loading, ready, value],
  );

  useLayoutEffect(() => {
    if (!shouldAutoClear || !fieldName) {
      return;
    } else if (value && !Object.hasOwnProperty.call(data, value)) {
      if (autoSelect && data && Object.keys(data).length) {
        // condition: auto select when current selection is invalid
        form?.setFieldValue(fieldName, Object.keys(data)[0]);

        autoSelectCallback?.();
      } else {
        // condition: clear selection when current selection is invalid
        form?.setFieldValue(fieldName, undefined);
      }
    }
  }, [
    autoSelect,
    autoSelectCallback,
    data,
    fieldName,
    form,
    shouldAutoClear,
    value,
  ]);

  // auto select when current selection is empty
  const shouldAutoSelect = useMemo(
    () =>
      ready && // useRequest is ready to fetch data
      !loading && // useRequest is not loading
      !error && // useRequest has no error
      data && // data is not empty
      Object.keys(data).length > 0 && // data length is not 0
      autoSelect && // autoSelect enabled
      ["", undefined, null].includes(value), // current selection is empty
    [autoSelect, data, error, loading, ready, value],
  );

  useLayoutEffect(() => {
    if (!shouldAutoSelect || !fieldName || !data) {
      return;
    } else {
      form?.setFieldValue(fieldName, Object.keys(data)[0]);

      autoSelectCallback?.();
    }
  }, [autoSelectCallback, data, fieldName, form, shouldAutoSelect]);

  return (
    <ProFormSelect
      {...proFormSelectProps}
      valueEnum={data ?? {}}
      params={undefined}
      request={undefined}
      fieldProps={{
        ...proFormSelectProps?.fieldProps,
        loading,
        dropdownRender:
          error || loading || !ready
            ? () => (
                <>
                  {!loading && ready && error && (
                    <Empty
                      description={
                        <Typography.Text type="danger">
                          {error.message}
                        </Typography.Text>
                      }
                    >
                      <Button type="primary" onClick={refreshAsync}>
                        重试
                      </Button>
                    </Empty>
                  )}

                  {(loading || !ready) && (
                    <Empty
                      description={<Typography.Text>加载中...</Typography.Text>}
                    />
                  )}
                </>
              )
            : undefined,
      }}
    />
  );
};

export default ProFormAsyncSelect;
```

## liuJchun

不能通过request的结果来清空，可能会出现接口动态搜索的下拉结果，所选项并不一定在结果列表中，只能分析dependices的字段，在onChange触发
