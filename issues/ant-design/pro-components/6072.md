# ğŸ§[é—®é¢˜] ProFormSelect é€šè¿‡ request æ›´æ–°é€‰é¡¹ä»¥åå¦‚ä½•è‡ªåŠ¨æ¸…é™¤å·²é€‰æ‹©çš„æ•°æ®ï¼Ÿ

æé—®å‰å…ˆçœ‹çœ‹ï¼š

https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md

### ğŸ§ é—®é¢˜æè¿°

<!--
è¯¦ç»†åœ°æè¿°é—®é¢˜ï¼Œè®©å¤§å®¶éƒ½èƒ½ç†è§£
-->

æ¯”å¦‚ä¸€ä¸ªåŸå¸‚é€‰æ‹©å™¨ï¼Œè·Ÿéšç”¨æˆ·åœ¨å¦ä¸€ä¸ªé€‰é¡¹ä¸Šé€‰æ‹©çš„çœä»½çš„å˜åŒ–å‘èµ·è¯·æ±‚ï¼Œå¹¶ç”Ÿæˆæ–°çš„åŸå¸‚åˆ—è¡¨ã€‚

å¦‚æœåœ¨ç”¨æˆ·å…ˆé€‰æ‹©äº† `æµ™æ±Ÿ->æ­å·`ï¼Œç„¶åæŠŠçœä»½åˆ‡æ¢åˆ° `å¹¿ä¸œ`ï¼Œè¿™æ—¶å€™åŸå¸‚é€‰æ‹©å™¨æ›´æ–°ï¼ŒåŸå¸‚åˆ—è¡¨é‡Œä¸å†æœ‰ `æ­å·` ä¸€é¡¹ï¼Œä½†æ˜¯ç°å®æƒ…å†µæ˜¯åŸå¸‚é€‰æ‹©å™¨æœªå±•å¼€çš„çŠ¶æ€ä¸‹ä»ç„¶å±•ç¤ºç€ `æ­å·`ï¼Œå¦‚æœç”¨æˆ·ä¸ä¸»åŠ¨åˆ‡æ¢åŸå¸‚ï¼Œå°±ä¼šå‡ºç° `å¹¿ä¸œ->æ­å·` è¿™æ ·çš„ç»“æœã€‚

æ˜¯å¦æœ‰åŠæ³•åœ¨åŸå¸‚é€‰æ‹©å™¨çš„åˆ—è¡¨æ›´æ–°æ—¶è‡ªåŠ¨æŠŠä¸å­˜åœ¨çš„å·²é€‰æ‹©æ•°æ®æ¸…ç©ºï¼Œæˆ–ç›´æ¥æŠŠä»»ä½•å·²é€‰æ‹©çš„æ•°æ®æ¸…ç©ºä¹Ÿè¡Œï¼Ÿ

### ğŸ’» ç¤ºä¾‹ä»£ç 

```tsx
<ProFormSelect
    label="çœä»½"
    name='province'
    request={async () => {
      const res = await getProvinceList();

      return res.rows.map((item) => ({
        label: item.name,
        value: item.id,
      }));
    }}
  />

<ProFormSelect
    label="åŸå¸‚"
    name='city'
    dependencies={province}
    request={async ({ province }) => {
      const res = await getCityList({ province });

      return res.rows.map((item) => ({
        label: item.name,
        value: item.id,
      }));
    }}
  />
```

<!--
å¦‚æœä½ æœ‰è§£å†³æ–¹æ¡ˆï¼Œåœ¨è¿™é‡Œæ¸…æ™°åœ°é˜è¿°
-->

å½“ç„¶ï¼Œå¯ä»¥é€šè¿‡ formRef.current.getFieldValue ç›‘å¬æ•°æ®å˜åŒ–ï¼Œå¹¶æ‰‹åŠ¨å†™æ¸…ç©ºçš„é€»è¾‘ï¼Œä½†æ˜¯è¿™æ ·ä¹Ÿç ´åäº†dependenciesçš„ä¾¿åˆ©æ€§ï¼Œæœ€å¥½è¿˜æ˜¯èƒ½åœ¨ProFormSelectç»„ä»¶å†…è‡ªåŠ¨å®ç°ã€‚

æœŸæœ›è¿™æ ·çš„æ•ˆæœï¼š

```tsx
<ProFormSelect
  label="åŸå¸‚"
  name="city"
  // æœŸæœ›è¿™æ ·çš„é€‰é¡¹ï¼š
  autoClearInexistenceValue={true}
  // æˆ–è€…
  autoClearWhenOptionsChange={true}
  dependencies={province}
  request={async ({ province }) => {
    const res = await getCityList({ province });

    return res.rows.map((item) => ({
      label: item.name,
      value: item.id,
    }));
  }}
/>
```

### ğŸš‘ å…¶ä»–ä¿¡æ¯

<!--
å¦‚æˆªå›¾ç­‰å…¶ä»–ä¿¡æ¯å¯ä»¥è´´åœ¨è¿™é‡Œ
-->

## chenshuai2144

`ç”¨formRef.setFieldValues({ name: null})`

è¿™æ ·è®¾ç½®ä¸€ä¸‹

## mashirozx

ä½†æ˜¯è¿™æ ·æœ‰ä¸ªé—®é¢˜ï¼Œå°±æ˜¯ä¸æ–¹ä¾¿å¯¹form fieldè¿›è¡Œæ‹†åˆ†ï¼Œæ¯”å¦‚æˆ‘æŠŠä¸Šé¢çš„çœä»½-åŸå¸‚è”åŠ¨é€‰æ‹©æƒæ‹†åˆ†åˆ°ä¸€ä¸ªå•ç‹¬çš„form groupç»„ä»¶ä¸Šï¼Œå¹¶åœ¨å¤šä¸ªProFormä¸Šè°ƒç”¨è¿™ä¸ªform groupï¼Œå¦‚æœæ¯æ¬¡éƒ½è¦ä¼ ä¸€ä¸ªformRefè¿›å»ï¼ŒåŸºæœ¬å°±ç ´åäº†åŸæœ¬ç®€ä¾¿çš„ç»„ä»¶æ‹†åˆ†å’Œdependencyæ›´æ–°æ€è·¯

## tanpengsccd

+1 .æœ‰ç±»ä¼¼é—®é¢˜. è®¾ç½® æ±½è½¦å‹å·(å“ç‰Œ-è½¦ç³»-å¹´æ¬¾-è½¦å‹) å’Œ å•†å“ç±»å‹ ä¹Ÿæœ‰ ç±»ä¼¼ é—®é¢˜.

## mashirozx

æˆ‘æœ€åæ›¿ä»£çš„æ–¹æ³•æ˜¯ï¼Œä¸ä½¿ç”¨dependenciesï¼Œä¹Ÿä¸ä½¿ç”¨requestï¼šè‡ªå·±å¤„ç†è¯·æ±‚ï¼ˆuseRequestï¼‰ï¼ŒæŠŠæ•°æ®é€šè¿‡setStateä¼ å…¥optionsï¼Œç„¶åé€šè¿‡useWatchç›‘å¬å­—æ®µå½“å‰æ•°æ®ï¼Œå¹¶æ£€æµ‹optionsé‡Œé¢çš„æ•°æ®æ˜¯å¦åŒ…å«é€‰æ‹©çš„ç»“æœï¼Œå¦‚æœä¸åŒ…å«åˆ™è°ƒç”¨setFieldValueæ¸…é™¤

## mashirozx

ä¸€ä¸ªä¸šåŠ¡ç»„ä»¶çš„ğŸŒ°ï¼š

```tsx
import { FormItemProvide, ProFormSelect } from "@ant-design/pro-components";
import { Button, Empty, Typography } from "antd";
import type { ComponentProps, FunctionComponent } from "react";
import { useContext, useLayoutEffect, useMemo } from "react";

import { useFormContext } from "@/hooks/useFormContext";
import { useFormValue } from "@/hooks/useFormValue";
import { useRequest } from "@/hooks/useRequest";

type ProFormAsyncSelectProps = Omit<
  ComponentProps<typeof ProFormSelect>,
  "options" | "request"
> & {
  request: (
    params: any,
    props: any,
  ) => Promise<{ value: string; label: string }[]>;
  /**
   * useRequest çš„ç¼“å­˜ keyï¼š
   *
   * è¯·æ±‚å”¯ä¸€æ ‡è¯†ã€‚å¦‚æœè®¾ç½®äº† cacheKeyï¼Œæˆ‘ä»¬ä¼šå¯ç”¨ç¼“å­˜æœºåˆ¶ã€‚åŒä¸€ä¸ª cacheKey çš„æ•°æ®å…¨å±€åŒæ­¥ã€‚
   *
   * @default undefined
   */
  cacheKey: string;
  /**
   * useRequest çš„ç¼“å­˜æ—¶é—´ï¼š
   *
   * - è®¾ç½®ç¼“å­˜æ•°æ®å›æ”¶æ—¶é—´ã€‚é»˜è®¤ç¼“å­˜æ•°æ® 5 åˆ†é’Ÿåå›æ”¶
   * - å¦‚æœè®¾ç½®ä¸º -1, åˆ™è¡¨ç¤ºç¼“å­˜æ•°æ®æ°¸ä¸è¿‡æœŸ
   *
   * @default 5 * 60 * 1000
   */
  cacheTime?: number;
  /**
   * useRequest çš„ç¼“å­˜æ•°æ®ä¿æŒæ–°é²œæ—¶é—´ï¼š
   *
   * - ç¼“å­˜æ•°æ®ä¿æŒæ–°é²œæ—¶é—´ã€‚åœ¨è¯¥æ—¶é—´é—´éš”å†…ï¼Œè®¤ä¸ºæ•°æ®æ˜¯æ–°é²œçš„ï¼Œä¸ä¼šé‡æ–°å‘è¯·æ±‚
   * - å¦‚æœè®¾ç½®ä¸º -1ï¼Œåˆ™è¡¨ç¤ºæ•°æ®æ°¸è¿œæ–°é²œ
   *
   * @default -1
   */
  staleTime?: number;
  /**
   * è¯·æ±‚ç»“æŸåè‡ªåŠ¨æ¸…é™¤æ— æ•ˆçš„å·²é€‰é¡¹ç›®å›æ˜¾ï¼šé€‚ç”¨äºé€‰é¡¹æ›´æ–°åå·²é€‰é¡¹ç›®å·²ä¸å­˜åœ¨çš„æƒ…å†µ
   *
   * @default true
   */
  autoClear?: boolean;
  /**
   * å·²é€‰é¡¹ç›®ä¸ºç©ºæ—¶ï¼Œè‡ªåŠ¨é€‰æ‹©é€‰é¡¹ä¸­çš„ç¬¬ä¸€é¡¹ï¼Œå¯é…åˆ `autoClear=false`ã€`autoSelectCallback` ä¸€èµ·ä½¿ç”¨
   */
  autoSelect?: boolean;
  /**
   * è‡ªåŠ¨é€‰æ‹©åçš„å›è°ƒå‡½æ•°
   */
  autoSelectCallback?: () => void;
  loadingDelay?: number;
  ready?: boolean;
};

const ProFormAsyncSelect: FunctionComponent<ProFormAsyncSelectProps> = ({
  params,
  request,
  cacheKey,
  cacheTime = 5 * 60 * 1000,
  staleTime = 0,
  autoClear = true,
  autoSelect,
  autoSelectCallback,
  loadingDelay,
  ready = true,
  ...proFormSelectProps
}) => {
  const { form } = useFormContext();

  const formItemProvide = useContext(FormItemProvide);

  const fieldName = useMemo(
    () =>
      (proFormSelectProps?.name ?? formItemProvide?.name) as string | undefined,
    [formItemProvide?.name, proFormSelectProps?.name],
  );

  const value = useFormValue<string>(fieldName);

  const { data, loading, error, refreshAsync } = useRequest(
    async () => {
      if (!request) {
        throw new Error("request is required");
      } else {
        const res = await request(params, undefined);

        const enums: Record<string, string> = {};

        res.forEach((item) => {
          enums[item.value] = item.label;
        });

        return enums;
      }
    },
    {
      cacheKey: cacheKey ? `${cacheKey}-${JSON.stringify(params)}` : undefined,
      cacheTime,
      staleTime,
      loadingDelay,
      ready,
      refreshDeps: [params, request],
    },
  );

  // auto clear
  const shouldAutoClear = useMemo(
    () =>
      ready && // useRequest is ready to fetch data
      !loading && // useRequest is not loading
      !error && // useRequest has no error
      data && // data is not empty
      Object.keys(data).length > 0 && // data length is not 0
      autoClear && // autoClear enabled
      !Array.isArray(value) && // won't handle array value
      !["", undefined, null].includes(value), // value is not empty
    [autoClear, data, error, loading, ready, value],
  );

  useLayoutEffect(() => {
    if (!shouldAutoClear || !fieldName) {
      return;
    } else if (value && !Object.hasOwnProperty.call(data, value)) {
      if (autoSelect && data && Object.keys(data).length) {
        // condition: auto select when current selection is invalid
        form?.setFieldValue(fieldName, Object.keys(data)[0]);

        autoSelectCallback?.();
      } else {
        // condition: clear selection when current selection is invalid
        form?.setFieldValue(fieldName, undefined);
      }
    }
  }, [
    autoSelect,
    autoSelectCallback,
    data,
    fieldName,
    form,
    shouldAutoClear,
    value,
  ]);

  // auto select when current selection is empty
  const shouldAutoSelect = useMemo(
    () =>
      ready && // useRequest is ready to fetch data
      !loading && // useRequest is not loading
      !error && // useRequest has no error
      data && // data is not empty
      Object.keys(data).length > 0 && // data length is not 0
      autoSelect && // autoSelect enabled
      ["", undefined, null].includes(value), // current selection is empty
    [autoSelect, data, error, loading, ready, value],
  );

  useLayoutEffect(() => {
    if (!shouldAutoSelect || !fieldName || !data) {
      return;
    } else {
      form?.setFieldValue(fieldName, Object.keys(data)[0]);

      autoSelectCallback?.();
    }
  }, [autoSelectCallback, data, fieldName, form, shouldAutoSelect]);

  return (
    <ProFormSelect
      {...proFormSelectProps}
      valueEnum={data ?? {}}
      params={undefined}
      request={undefined}
      fieldProps={{
        ...proFormSelectProps?.fieldProps,
        loading,
        dropdownRender:
          error || loading || !ready
            ? () => (
                <>
                  {!loading && ready && error && (
                    <Empty
                      description={
                        <Typography.Text type="danger">
                          {error.message}
                        </Typography.Text>
                      }
                    >
                      <Button type="primary" onClick={refreshAsync}>
                        é‡è¯•
                      </Button>
                    </Empty>
                  )}

                  {(loading || !ready) && (
                    <Empty
                      description={<Typography.Text>åŠ è½½ä¸­...</Typography.Text>}
                    />
                  )}
                </>
              )
            : undefined,
      }}
    />
  );
};

export default ProFormAsyncSelect;
```

## liuJchun

ä¸èƒ½é€šè¿‡requestçš„ç»“æœæ¥æ¸…ç©ºï¼Œå¯èƒ½ä¼šå‡ºç°æ¥å£åŠ¨æ€æœç´¢çš„ä¸‹æ‹‰ç»“æœï¼Œæ‰€é€‰é¡¹å¹¶ä¸ä¸€å®šåœ¨ç»“æœåˆ—è¡¨ä¸­ï¼Œåªèƒ½åˆ†ædependicesçš„å­—æ®µï¼Œåœ¨onChangeè§¦å‘
