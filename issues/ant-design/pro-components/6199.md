# EditableProTable 使用formItem模式，并且字段设置了formItemProps的rules时数据会出错🧐[问题]

`AI Reply`

### 🧐 问题描述

EditableProTable 使用formItem模式，并且字段设置了formItemProps的rules时数据会出错。
![1](https://user-images.githubusercontent.com/183884/201242955-c3178025-4f49-4d6f-98df-3c086968b1ba.jpg)
当未开启（注释掉）formItemProps的rules时一切正常，
当开启使用formItemProps的rules时数据会出现错误
具体两种错误
步骤一：规格1 规格2分别新增两个规格值，生成好sku后填写好sku的库存此时有四条数据
![2](https://user-images.githubusercontent.com/183884/201243007-bcaaf2e4-01e3-4fb3-9b29-c189fc5ade40.jpg)
步骤二：新增一个规格2的规格值，现在应该sku的顺序变化了，如果开启了formItemProps的rules，则会清空顺序变化的库存值（预期不变化，因为是根据id判断的，id并没有变）。或者填写新增的sku的库存的时候 也会清空下面一条的值（应该也是顺序问题）
![3](https://user-images.githubusercontent.com/183884/201243072-27da76be-d1c6-4a5e-9e04-c969cf7b7b41.jpg)
![4](https://user-images.githubusercontent.com/183884/201243081-833d3fd8-d990-4a44-b5dd-d37e70d15fd5.jpg)

[示例代码](https://codesandbox.io/s/funny-cherry-ivgg7u?file=/src/App.tsx)

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方员会在一定时间后继续继续处理。

### 🤔 解决方案

这是一个与 Ant Design 组件库一起使用时常见的问题。原因是 Ant Design 表单验证机制会触发表单组件的重新渲染。

为了解决该问题，可以使用 useMemo 或 useCallback 来缓存组件，以避免不必要的重新渲染。

需要注意的是，使用 useMemo 或 useCallback 时，需要把相应的依赖项（dependencies）传递进去，以便它们能够正确地响应数据变化。

```tsx
// 缓存表单组件
const memoFormItem = useCallback(
  (record, dataIndex, form) => {
    const formItemProps = {
      name: [dataIndex, record.id],
      rules: [
        {
          required: true,
          message: `${
            dataIndex.charAt(0).toUpperCase() + dataIndex.slice(1)
          }不能为空`,
        },
      ],
    };
    return (
      <Form.Item {...formItemProps}>
        <Input />
      </Form.Item>
    );
  },
  [], // 这里没有使用任何依赖项
);

// 使用缓存的表单组件
columns.map((column) => {
  const col = {
    ...column,
    // 使用 memoFormItem 代替 column.render
    render: (_, record) => memoFormItem(record, column.dataIndex, form),
    ellipsis: true,
  };
  return col;
});
```

这里使用了 useCallback 来缓存表单组件，然后使用 memoFormItem 代替了 column.render。这样就可以避免 Ant Design 的表单验证机制触发不必要的重新渲染。同时，由于 useCallback 没有使用任何依赖项，这意味着它只会被创建一次，并在整个组件的生命周期中重复使用。
