# 🐛[BUG] EditableProTable组件，联动赋值值被清空

`table`,`📦  Need to reproduce`,`AI Reply`

提问前先看看：

https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md

### 🐛 bug 描述|

EditableProTable组件，联动赋值值被清空

<!--
详细地描述 bug，让大家都能理解
-->

有一个可编辑表格。我需要联动。【第一行】我选择数据A以后。需要赋值数据给【第一行】的其他字段。数据A，我通过renderFormItem，返回一个自定义组件。我在组件onChange里面拿到数据。赋值给【第一行】的其他字段。第一瞬间能获取到。然后里面会被重置为空
![image](https://user-images.githubusercontent.com/20220029/206404188-7100ea81-bd9d-449e-b259-e31c7a367809.png)

![image](https://user-images.githubusercontent.com/20220029/206404341-3d5129e1-09d9-4a5b-8cc6-65f2f2626a97.png)

### 📷 复现步骤

<!--
清晰描述复现步骤，让别人也能看到问题，如果可能，尽量提供可执行代码，
如：https://codesandbox.io/ 在此处创建一个 codesandbox，方便我们更快的排查和复现问题
-->

### 🏞 期望结果

字段联动能正常赋值

<!--
描述你原本期望看到的结果
-->

### 💻 复现代码

<!--
提供可复现的代码，仓库，或线上示例
-->

### © 版本信息

- ProComponents 版本: "@ant-design/pro-components": "^2.3.16",
- umi 版本"umi": "^3.5.0",
- 浏览器环境版本 107.0.5304.87（正式版本） (arm64)
- 开发环境 [e.g. mac OS]

### 🚑 其他信息

<!--
如截图等其他信息可以贴在这里
-->

## chenshuai2144

我感觉是因为你的onchange 被自己使用了，导致 form 没有正确的保存值。最好给个最小重现给我试试

## zhuiluo0987

> 我感觉是因为你的onchange 被自己使用了，导致 form 没有正确的保存值。最好给个最小重现给我试试

https://codesandbox.io/s/adoring-firefly-q2wx5h?file=/src/App.js
这是一个基础列子。我就想第一列改变给第二列设值

## sTeADone

我查了一下，似乎是因为触发`onChange`的列本身也要通过`setFieldValue`来更新表单中自己对应的值，但是它取值在联动操作之前，赋值却在联动操作之后，导致数据被还原。
https://blog.csdn.net/SpicyBoiledFish/article/details/108225749

网上给出的解决方案是用`setTimeout`，强制把联动操作挪到后面。

```
setTimeout(() => {
    formRef.current?.setFieldValue(["some_list", rowIndex, "field2"], "some new value")
}, 100);

```

不知道有没有更好的方案。

从表单外部调用`setFieldValue`倒是没有这个问题，在组件内部`onChange`调用才有。

```
<Button
  onClick={
    () => {
      formRef.current?.setFieldValue(["table", 0, "field2"], "Set by button")
      console.log(formRef.current?.getFieldsValue(true))
    }
  }>
  Set Row0 field2
</Button>
```

### 复现

```
import React, { useState, useRef } from 'react';
import { Button } from "antd"
import { ProForm, EditableProTable } from '@ant-design/pro-components';

const data = [
  { key: "1", field1: "aaa", field2: "field2 default", },
  { key: "2", field1: "bbb", field2: "field2 default", },
]

export default () => {
  const [editableKeys, setEditableRowKeys] = useState(data.map((item, index) => (item.key)))

  const formRef = useRef()
  const tableRef = useRef()

  const columns = [
    {
      title: "field1",
      dataIndex: "field1",
      valueType: 'select',
      fieldProps: (_, { rowIndex }) => ({
        onChange: (values, option) => {
          formRef.current?.setFieldValue(["table", rowIndex, "field2"], option.label)
          // setTimeout(() => {
          //   formRef.current?.setFieldValue(["table", rowIndex, "field2"], option.label)
          // }, 100);
        },
        options: [
          { value: 0, label: "Set by row component value0" },
          { value: 1, label: "Set by row component value1" }
        ]

      }),

    },
    { title: "field2", dataIndex: "field2" },
  ]

  return (
    <>
      <ProForm
        initialValues={{ table: data }}
        formRef={formRef}
        onFinish={(values) => {
          console.log(values)
          console.log(formRef.current?.getFieldsValue(true))
        }}
      >
        <ProForm.Item name="table" shouldUpdate>
          <EditableProTable
            rowKey="key"
            editableFormRef={tableRef}
            columns={columns}
            editable={{
              type: 'multiple',
              editableKeys,
              onChange: setEditableRowKeys,
            }}
            recordCreatorProps={{
              newRecordType: 'dataSource',
              position: 'bottom',
              record: () => ({
                key: Date.now().toString(),
              }),
            }}
            controlled
          />
        </ProForm.Item>
      </ProForm>
      <Button
        onClick={
          () => {
            formRef.current?.setFieldValue(["table", 0, "field2"], "Set by button")
            console.log(formRef.current?.getFieldsValue(true))
          }
        }>
        Set Row0 field2
      </Button>
    </>
  )
}
```

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方员会在一定时间后继续继续处理。

你的思路是正确的，如果是内部`onChange` 导致的情况，可以使用`setTimeout` 来让联动操作延迟执行，以保证最后同步到表单中的值是修改后的。

一般来说，如果内部 `onChange` 修改了表单值，并且会对接下来的其他修改造成影响，那么就需要使用`setTimeout`来让联动操作延迟执行。因为在调用当前 onChange 后，其他的表单控件可能还没来得及更新自己的值，此时修改其他表单控件的值可能会被覆盖。同时，操作越复杂，就越容易出现这种情况，使用`setTimeout` 来避免影响是相对通用的解决方案。

如果你不想使用这种方式，还可以在 columns 中通过自定义 render 去处理。这种方式需要手动改变 data 数据。具体可以看代码示例。

```
import React, { useState, useRef } from 'react';
import { Button } from "antd"
import { ProForm, EditableProTable } from '@ant-design/pro-components';

const data = [
  { key: "1", field1: "aaa", field2: "field2 default", },
  { key: "2", field1: "bbb", field2: "field2 default", },
]

export default () => {
  const [editableKeys, setEditableRowKeys] = useState(data.map((item, index) => (item.key)))

  const formRef = useRef()
  const tableRef = useRef()

  const columns = [
    {
      title: "field1",
      dataIndex: "field1",
      valueType: 'select',
      fieldProps: (_, { rowIndex }) => ({
        options: [
          { value: 0, label: "Set by row component value0" },
          { value: 1, label: "Set by row component value1" }
        ],
        onChange: (values, option) => {
          const dataSource = [...tableRef.current?.dataSource] // 获取当前编辑表格的数据
          const currentItem = dataSource.find(item => item.key === option.key) // 找到修改后的那一行
          currentItem.field1 = option.field1 // 修改 field1 值
          currentItem.field2 = option.field2 // 修改 field2 值
          tableRef.current?.dataSource = dataSource // 将修改后的 dataSource 赋值回去
          tableRef.current?.setState?.({ dataSource }) // 强制渲染一遍
        },
      }),

    },
    { title: "field2", dataIndex: "field2" },
  ]

  return (
    <>
      <ProForm
        initialValues={{ table: data }}
        formRef={formRef}
        onFinish={(values) => {
          console.log(values)
          console.log(formRef.current?.getFieldsValue(true))
        }}
      >
        <ProForm.Item name="table" shouldUpdate>
          <EditableProTable
            rowKey="key"
            editableFormRef={tableRef}
            columns={columns}
            editable={{
              type: 'multiple',
              editableKeys,
              onChange: setEditableRowKeys,
            }}
            recordCreatorProps={{
              newRecordType: 'dataSource',
              position: 'bottom',
              record: () => ({
                key: Date.now().toString(),
              }),
            }}
            controlled
            dataSource={data}
            value={data}
            onChange={(_value) => {
              console.log(_value)
            }}
          />
        </ProForm.Item>
      </ProForm>
      <Button
        onClick={
          () => {
            formRef.current?.setFieldValue(["table", 0, "field2"], "Set by button")
            console.log(formRef.current?.getFieldsValue(true))
          }
        }>
        Set Row0 field2
      </Button>
    </>
  )
}
```

## America-first-melon

current 上 没有 dataSource 这个属性吧？

## chenshuai2144

可以用 getFieldValues('name') 获取。并且注意下 name
