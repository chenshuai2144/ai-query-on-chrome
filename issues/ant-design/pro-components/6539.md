# 🐛[BUG]EditableProTable 使用editableFormRef后，无法用formRef.current.setFieldsValue改变table的值

`AI Reply`

### 🐛 bug 描述

使用editableFormRef后，无法用formRef.current.setFieldsValue改变table的值：

![1](https://user-images.githubusercontent.com/29675005/214486640-2b9af0d0-b3b2-476a-9d1a-a455c4e89996.gif)

### 📷 复现步骤

https://codesandbox.io/s/edittable-7ih3ww?file=/App.tsx

复现代码：

```
import { EditableFormInstance, ProColumns, ProFormInstance, ProFormItem } from '@ant-design/pro-components';
import { EditableProTable, ProForm, ProFormTextArea, ProFormRadio } from '@ant-design/pro-components';
import React, { useRef, useState } from 'react';
import { Button } from 'antd';

const defaultData: any = [
  {
    id: 624748504,
    title: '活动名称一',
    decs: '这个活动真好玩',
    state: 'open',
    created_at: '1590486176000',
    update_at: '1590486176000',
  },
  {
    id: 624748505,
    title: '活动名称一2',
    decs: '这个活动真好玩',
    state: 'open',
    created_at: '1590486176000',
    update_at: '1590486176000',
  },
];

export default () => {
  const [editableKeys, setEditableRowKeys] = useState<React.Key[]>(() => [624748504]);
  const formRef = useRef<any>();
  const editorFormRef = useRef<EditableFormInstance<any>>();
  const columns: ProColumns<any>[] = [
    {
      title: '活动名称',
      dataIndex: 'title',
      formItemProps: () => {
        return {
          rules: [{ required: true, message: '此项为必填项' }],
        };
      },
      width: '30%',
    },
    {
      title: '状态',
      key: 'state',
      dataIndex: 'state',
      valueType: 'select',
      valueEnum: {
        all: { text: '全部', status: 'Default' },
        open: {
          text: '未解决',
          status: 'Error',
        },
        closed: {
          text: '已解决',
          status: 'Success',
        },
      },
    },
    {
      title: '描述',
      dataIndex: 'decs',
    },
    {
      title: '活动时间',
      dataIndex: 'created_at',
      valueType: 'date',
    },
  ];
  return (
    <>
      {' '}
      <Button
        onClick={() => {
          const rowId = Date.now();
          //通过formRef改变值
          formRef.current.setFieldsValue({
            data: [
              {
                id: rowId,
                title: rowId.toString(),
                decs: '这个活动真好玩',
                state: 'open',
                created_at: '1590486176000',
                update_at: '1590486176000',
              },
            ],
          });
          setEditableRowKeys([rowId]);
        }}
      >
        设置Editable值
      </Button>
      <ProForm<{
        table: any;
      }>
        formRef={formRef}
        submitter={false}
        initialValues={{ data: defaultData }}
      >
          <EditableProTable<any>
            rowKey="id"
            scroll={{
              x: 960,
            }}
            editableFormRef={editorFormRef}
            headerTitle="可编辑表格"
            maxLength={5}
            name="data"
            toolBarRender={false}
            columns={columns}
            editable={{
              type: 'multiple',
              editableKeys,
              onChange: setEditableRowKeys,
              actionRender: (row, _, dom) => {
                return [dom.delete];
              },
            }}
          />
      </ProForm>
    </>
  );
};

```

### 🏞 期望结果

能够改变其值

### © 版本信息

- ProComponents 版本: [2.3.52]

### 🚑 其他信息

## XueMeijing

Table外层增加ProFormItem，ProFormItem使用name="data"可以解决这个问题

```
<ProFormItem name="data">
  <EditableProTable<any>
    rowKey="id"
    scroll={{
      x: 960
    }}
    editableFormRef={editorFormRef}
    headerTitle="可编辑表格"
    maxLength={5}
    toolBarRender={false}
    columns={columns}
    editable={{
      type: "multiple",
      editableKeys,
      onChange: setEditableRowKeys,
      actionRender: (row, _, dom) => {
        return [dom.delete];
      }
    }}
  />
</ProFormItem>
```

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方员会在一定时间后继续继续处理。

感谢您提供了解决方案，您提供的方法可以通过在 Table 外层封装一个 ProFormItem，将 Table 绑定到指定 name 上，让 formRef 初始化时初始化对应的数据，但是这种方式会增加代码的嵌套层次，不过能够解决您的问题，代码如下：

```
<ProForm>
  <ProFormItem name="data">
    <EditableProTable<any>
      // 省略其他代码...
    />
  </ProFormItem>
</ProForm>
```

还有一种方法，就是通过对 EditableProTable 组件的开发时初始化表单数据这个阶段绑定一个回调函数，让回调函数的参数就是 form 对象，这区别是不需要在 Table 外增加 ProFormItem 的包装层，但是需要修改组件源码。如果您感兴趣可以自行了解。

## chengmaoning

> Table外层增加ProFormItem，ProFormItem使用name="data"可以解决这个问题
>
> ```
> <ProFormItem name="data">
>   <EditableProTable<any>
>     rowKey="id"
>     scroll={{
>       x: 960
>     }}
>     editableFormRef={editorFormRef}
>     headerTitle="可编辑表格"
>     maxLength={5}
>     toolBarRender={false}
>     columns={columns}
>     editable={{
>       type: "multiple",
>       editableKeys,
>       onChange: setEditableRowKeys,
>       actionRender: (row, _, dom) => {
>         return [dom.delete];
>       }
>     }}
>   />
> </ProFormItem>
> ```

大哥，强，强烈建议官方示例增加ProFormItem包围EditableProTable，以免出现以上问题及其他问题（我在编辑-cancel时候发现，cancel了cell的值就没了。。。）
