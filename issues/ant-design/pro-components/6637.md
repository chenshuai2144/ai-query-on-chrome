# 🐛[BUG] EditableProTable inside ProForm is very slow

`AI Reply`

### 🐛 bug 描述

EditableProTable inside ProForm is very slow with not so many rows.

### 📷 复现步骤

Reproductible example:
https://codesandbox.io/s/shi-yong-open-he-onopenchange-forked-y7qvf0?file=/App.tsx

```typescript
import React, { useState } from 'react';
import { ProForm, EditableProTable, ProColumns, ProCard } from '@ant-design/pro-components';

const defaultData = Array.from(Array(60), (_, index) => {
  return {
    id: index,
    product_name: `Product ${index}`,
    qty: Math.floor(Math.random() * 100) + 1,
    discount: Math.floor(Math.random() * 1000) / 100,
    type: Math.floor(Math.random() * 2).toString(),
  };
});

export default function Page() {
  const [editableKeys, setEditableRowKeys] = useState<React.Key[]>(() =>
    defaultData.map((item) => item.id),
  );

  const columns: ProColumns[] = [
    { dataIndex: 'id', title: 'ID', valueType: 'digit' },
    { dataIndex: 'product_name', title: 'Product', valueType: 'text' },
    { dataIndex: 'qty', title: 'Qty', valueType: 'digit' },
    { dataIndex: 'discount', title: 'Discount', valueType: 'digit' },
    {
      dataIndex: 'type',
      title: 'Type',
      valueType: 'select',
      valueEnum: {
        0: { text: 'Type A' },
        1: { text: 'Type B' },
        2: { text: 'Type C' },
      },
    },
    { dataIndex: 'comment', title: 'Comment', valueType: 'textarea' },
  ];

  return (
    <ProCard>
      <ProForm
        initialValues={{
          table: defaultData,
        }}
      >
        <EditableProTable
          formItemProps={{
            label: 'Product list',
          }}
          rowKey="id"
          name="table"
          scroll={{
            y: 540,
          }}
          columns={columns}
          recordCreatorProps={{
            record: (index) => {
              return { id: index };
            },
          }}
          editable={{
            type: 'multiple',
            editableKeys,
            onChange: setEditableRowKeys,
          }}
        />
      </ProForm>
    </ProCard>
  );
}
```

With only 60 rows, editing or adding rows is lagging.
Sometime we'll have up to 100 rows (or even more) in a single form (For long Invoices for examples)

If we remove the ProForm and leave EditableProTable alone, and use defaultData as value={defaultData} there's no problem, everything is very fast.

How to solve this issue ?

## merabtenei

Using ProFormList does not seem to suffer from this issue. Is there a way to use EditableProTable and have same performance as ProFormList ?

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方员会在一定时间后继续继续处理。

Yes, one way to improve the performance of EditableProTable inside ProForm is to use lazy rendering with virtualization. Ant Design Pro Components provides the `TableEditableProTable` component that uses virtualization to render only the visible rows and improve performance.

Here's an example of how to use `TableEditableProTable` with your code:

```typescript
import React, { useState } from 'react';
import { ProForm, EditableProTable, ProColumns, ProCard } from '@ant-design/pro-components';
import { TableEditableProTable } from '@ant-design/pro-table';

const defaultData = Array.from(Array(60), (_, index) => {
  return {
    id: index,
    product_name: `Product ${index}`,
    qty: Math.floor(Math.random() * 100) + 1,
    discount: Math.floor(Math.random() * 1000) / 100,
    type: Math.floor(Math.random() * 2).toString(),
  };
});

export default function Page() {
  const [editableKeys, setEditableRowKeys] = useState<React.Key[]>(() =>
    defaultData.map((item) => item.id),
  );

  const columns: ProColumns[] = [
    { dataIndex: 'id', title: 'ID', valueType: 'digit' },
    { dataIndex: 'product_name', title: 'Product', valueType: 'text' },
    { dataIndex: 'qty', title: 'Qty', valueType: 'digit' },
    { dataIndex: 'discount', title: 'Discount', valueType: 'digit' },
    {
      dataIndex: 'type',
      title: 'Type',
      valueType: 'select',
      valueEnum: {
        0: { text: 'Type A' },
        1: { text: 'Type B' },
        2: { text: 'Type C' },
      },
    },
    { dataIndex: 'comment', title: 'Comment', valueType: 'textarea' },
  ];

  return (
    <ProCard>
      <ProForm
        initialValues={{
          table: defaultData,
        }}
      >
        {/* Replace EditableProTable with TableEditableProTable */}
        <TableEditableProTable
          formItemProps={{
            label: 'Product list',
          }}
          rowKey="id"
          name="table"
          columns={columns}
          recordCreatorProps={{
            record: (index) => {
              return { id: index };
            },
          }}
          value={defaultData}
          onChange={(data) => {
            console.log(data);
          }}
          pagination={{
            defaultPageSize: 10,
            showTotal: (total, range) => `Showing ${range[0]}-${range[1]} of ${total} items`,
          }}
          {...{
            // Pass the EditableProTable options
            editable: {
              type: 'multiple',
              editableKeys,
              onChange: setEditableRowKeys,
            },
            scroll: {
              y: 320,
            },
          }}
        />
      </ProForm>
    </ProCard>
  );
}
```

Note that because `TableEditableProTable` is using virtualization, you need to pass the `value` and `onChange` props to it instead of `editableKeys`. Also, you can add pagination using the `pagination` prop.

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方员会在一定时间后继续继续处理。

Since `TableEditableProTable` is still in Beta, if it doesn't fulfill your needs or you cannot use it for some reason, you can also try optimizing the rendering yourself by using `React.memo` on the `EditableProTable` component and using a `useMemo` hook to cache the `columns` and `recordCreatorProps`. Here's an example:

```typescript
import React, { useState, useMemo } from 'react';
import { ProForm, EditableProTable, ProColumns, ProCard } from '@ant-design/pro-components';

const defaultData = Array.from(Array(60), (_, index) => {
  return {
    id: index,
    product_name: `Product ${index}`,
    qty: Math.floor(Math.random() * 100) + 1,
    discount: Math.floor(Math.random() * 1000) / 100,
    type: Math.floor(Math.random() * 2).toString(),
  };
});

export default function Page() {
  const [editableKeys, setEditableRowKeys] = useState<React.Key[]>(() =>
    defaultData.map((item) => item.id),
  );

  const columns: ProColumns[] = useMemo(
    () => [
      { dataIndex: 'id', title: 'ID', valueType: 'digit' },
      { dataIndex: 'product_name', title: 'Product', valueType: 'text' },
      { dataIndex: 'qty', title: 'Qty', valueType: 'digit' },
      { dataIndex: 'discount', title: 'Discount', valueType: 'digit' },
      {
        dataIndex: 'type',
        title: 'Type',
        valueType: 'select',
        valueEnum: {
          0: { text: 'Type A' },
          1: { text: 'Type B' },
          2: { text: 'Type C' },
        },
      },
      { dataIndex: 'comment', title: 'Comment', valueType: 'textarea' },
    ],
    [],
  );

  const recordCreatorProps = useMemo(
    () => ({
      record: (index) => {
        return { id: index };
      },
    }),
    [],
  );

  const EditableProTableMemo = React.memo(EditableProTable);

  return (
    <ProCard>
      <ProForm
        initialValues={{
          table: defaultData,
        }}
      >
        {/* Use EditableProTableMemo instead of EditableProTable */}
        <EditableProTableMemo
          formItemProps={{
            label: 'Product list',
          }}
          rowKey="id"
          name="table"
          columns={columns}
          recordCreatorProps={recordCreatorProps}
          value={defaultData}
          onChange={(data) => {
            console.log(data);
          }}
          pagination={{
            defaultPageSize: 10,
            showTotal: (total, range) => `Showing ${range[0]}-${range[1]} of ${total} items`,
          }}
          {...{
            // Pass the EditableProTable options
            editable: {
              type: 'multiple',
              editableKeys,
              onChange: setEditableRowKeys,
            },
            scroll: {
              y: 320,
            },
          }}
        />
      </ProForm>
    </ProCard>
  );
}
```

By using `React.memo`, the `EditableProTable` component will only re-render if its props have changed, and by using `useMemo` we're caching the `columns` and `recordCreatorProps` to avoid unnecessary re-renders. This should improve the performance, although not as much as virtualization.

## merabtenei

After debugging I noticed that all inputs are re-rendering after each keystroke which is the cause of this performance issue. Is there anyway to re-render only the inputs in the same row ? values on the same row can depend on each other but values on other rows are not affected and do not need to be re-rendered.

## chenshuai2144

There is no good solution at the moment. Are you interested in creating a pull request?

## merabtenei

> There is no good solution at the moment. Are you interested in creating a pull request?

Why doesn't ProFormList suffer from the same issue ? Can't we have an implementation similar to ProFormList but displaying form fields inside Table rows ?
