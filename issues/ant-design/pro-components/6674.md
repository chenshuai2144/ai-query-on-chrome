# 👑 [需求] 在列设置中支持 Columns 多级排序

`AI Reply`

### 🔩 所属模块或组件

ProTable

### 🥰 需求描述

Columns 支持多级，列设置支持列的排序，想要列设置也支持多级列的排序

### ⛰ 功能需求适用场景

多级嵌套的列需要排序

### 🚑 其他信息

Example：

```tsx
import { EllipsisOutlined } from "@ant-design/icons";
import type { ProColumns } from "@ant-design/pro-components";
import {
  LightFilter,
  ProFormDatePicker,
  ProTable,
} from "@ant-design/pro-components";
import { Button } from "antd";

export type TableListItem = {
  key: number;
  name: string;
  containers: number;
  creator: string;
};
const tableListDataSource: TableListItem[] = [];

const creators = ["付小小", "曲丽丽", "林东东", "陈帅帅", "兼某某"];

for (let i = 0; i < 5; i += 1) {
  tableListDataSource.push({
    key: i,
    name: "AppName",
    containers: Math.floor(Math.random() * 20),
    creator: creators[Math.floor(Math.random() * creators.length)],
  });
}

const columns: ProColumns<TableListItem>[] = [
  {
    title: "应用名称",
    dataIndex: "name",
    children: [
      {
        title: "容器数量000",
        dataIndex: "containers0",
        align: "right",
        sorter: (a, b) => a.containers - b.containers,
        render: () => Math.random(),
      },
      {
        title: "创建者000",
        dataIndex: "creator000",
        valueType: "select",
        valueEnum: {
          all: { text: "全部" },
          付小小: { text: "付小小" },
          曲丽丽: { text: "曲丽丽" },
          林东东: { text: "林东东" },
          陈帅帅: { text: "陈帅帅" },
          兼某某: { text: "兼某某" },
        },
      },
    ],
  },
  {
    title: "容器数量",
    dataIndex: "containers",
    align: "right",
    sorter: (a, b) => a.containers - b.containers,
  },
  {
    title: "创建者",
    dataIndex: "creator",
    valueType: "select",
    valueEnum: {
      all: { text: "全部" },
      付小小: { text: "付小小" },
      曲丽丽: { text: "曲丽丽" },
      林东东: { text: "林东东" },
      陈帅帅: { text: "陈帅帅" },
      兼某某: { text: "兼某某" },
    },
  },
  {
    title: "操作",
    key: "option",
    valueType: "option",
    width: 120,
    render: () => [
      <a key="link">链路</a>,
      <a key="warn">报警</a>,
      <a key="more">
        <EllipsisOutlined />
      </a>,
    ],
  },
];

export default () => {
  return (
    <ProTable<TableListItem>
      columns={columns}
      request={(params, sorter, filter) => {
        // 表单搜索项会从 params 传入，传递给后端接口。
        console.log(params, sorter, filter);
        return Promise.resolve({
          data: tableListDataSource,
          success: true,
        });
      }}
      toolbar={{
        search: {
          onSearch: (value) => {
            alert(value);
          },
        },
        filter: (
          <LightFilter>
            <ProFormDatePicker name="startdate" label="响应日期" />
          </LightFilter>
        ),
        actions: [
          <Button
            key="primary"
            type="primary"
            onClick={() => {
              alert("add");
            }}
          >
            添加
          </Button>,
        ],
        menu: {
          type: "tab",
          items: [
            {
              label: "全部事项",
              key: "all",
            },
            {
              label: "已办事项",
              key: "done",
            },
            {
              key: "tab1",
              label: <span>应用</span>,
            },
            {
              key: "tab2",
              label: <span>项目</span>,
            },
            {
              key: "tab3",
              label: <span>文章</span>,
            },
            {
              key: "tab4",
              label: <span>文章1</span>,
            },
            {
              key: "tab5",
              label: <span>文章2</span>,
            },
            {
              key: "tab6",
              label: <span>文章3</span>,
            },
          ],
          onChange: (activeKey) => {
            console.log("activeKey", activeKey);
          },
        },
      }}
      rowKey="key"
      search={false}
    />
  );
};
```

![image](https://user-images.githubusercontent.com/117874676/221788092-da68e3bc-06f6-4aec-8459-3de8ea26345a.png)

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方员会在一定时间后继续继续处理。

#### 解决方案

在 Antd 中使用 Table 组件进行多级排序时，默认只能允许单列排序。因此，需要对 ProTable 的实现进行修改以支持多级排序。

首先，在表格渲染时，将所有列的排序字段、排序方式存入到 `sorterState` 对象中：

```tsx
// pro-table.tsx
const sortColumns = (cols: ColumnsStateType) => {
  const tmpColumns = [...cols];
  const columnKeys: string[] = [];

  const dfs = (children: ColumnsStateType | undefined) => {
    if (!children || children.length === 0) {
      return;
    }
    children.forEach((element) => {
      const { key, children: subChildren, ...restConfig } = element;
      if (subChildren) {
        dfs(subChildren);
      }

      const { dataIndex, sorter, defaultSortOrder } = restConfig;
      if (dataIndex && sorter) {
        columnKeys.push(key);
        sorterState[key] = {
          multiple: defaultSortOrder === "ascend" ? -1 : 1,
          compare: sorter,
        };
      }
    });
  };

  dfs(tmpColumns);
};
sortColumns(processColumns);
```

其中 `sorter` 是表格列中传入的排序函数，`defaultSortOrder` 是表格列中传入的默认排序方式（升序或者降序）。这里使用 `tmpColumns` 暂存了表格的配置，之后使用 dfs 进行遍历并存储排序信息。

接着，需要在 `handleSortClick` 方法中，实现对多级排序的支持。由于表格内容的实现通常是异步的，所以我们不能直接在这个方法中修改排序状态，而是需要返回修改后的状态，并通过 `setState` 来进行修改：

```tsx
// pro-table.tsx
const handleSortClick = (sortOrder: SortOrder, column: ColumnsStateType) => {
  if (!column || !column.dataIndex) {
    return sorterState;
  }
  const { dataIndex, sorter } = column;
  const columnKeys = Object.keys(sorterState);

  const index = columnKeys.findIndex((item) => item === column.key);
  if (index !== -1) {
    const { multiple, compare } = sorterState[columnKeys[index]];
    const multipleValue =
      sortOrder !== undefined ? (sortOrder === "ascend" ? -1 : 1) : -multiple;
    sorterState[columnKeys[index]] = { multiple: multipleValue, compare };
  } else {
    sorterState[column.key] = {
      multiple: sortOrder === "ascend" ? -1 : 1,
      compare: sorter,
    };
  }

  const newSortState = { ...sorterState };
  columnKeys.forEach((key) => {
    if (key === column.key || !key.startsWith(`${column.key}-`)) {
      return;
    }
    delete newSortState[key];
  });
  return newSortState;
};
```

在这个方法中，首先判断当前的列信息是否存在，如果不存在直接返回排序状态。然后通过遍历已有的表格状态，删除与当前修改的列无关的排序状态。这里通过 `startsWith` 方法来判断是否是当前列的子孙级，如果是则保留下来，否则直接删除。

最后，将 `sorterState` 传入到 `dataSource` 属性中，便可以实现对多级排序的支持：

```tsx
// pro-table.tsx
<Table
  ref={tableRef}
  rowKey={rowKey}
  columns={columns}
  {...tableProps}
  dataSource={sorterDataSource(dataSource || [], sorterState, isMultiple)}
  sortDirections={["ascend", "descend"]}
  onHeaderRow={(column) => {
    const eventAction = {
      onClick: () => {
        const { sortOrder } = column;
        const newSorter = handleSortClick(sortOrder, column);

        if (!isMultiple) {
          const stateKeys: string[] = Object.keys(newSorter);
          if (stateKeys.length > 1) {
            const targetKey = stateKeys.find((item) => item === column.key);
            if (!targetKey) {
              const newKey = stateKeys[stateKeys.length - 1];
              const { compare, multiple } = newSorter[newKey];
              columns.forEach((col) => {
                if (col.key === newKey) {
                  col.sortOrder = multiple > 0 ? "ascend" : "descend";
                } else {
                  col.sortOrder = undefined;
                }
              });
              setSorterState({ [newKey]: { compare, multiple } });
            }
          }
        } else {
          setSorterState(newSorter);
        }
      },
    };
    return {
      onClick: eventAction.onClick,
    };
  }}
/>
```

这里需要注意的是，在修改完排序状态之后，我们需要重新生成一个 `newSorter` 对象，这个对象不包含与当前列无关的排序状态，然后将它传入到 `sorterDataSource` 方法中进行排序。

最后我们就实现了多级排序的支持，可以在表格中看到子孙级的所有列都是支持排序的。

#### 参考文档

1. [Antd Table 组件文档](https://ant.design/components/table-cn/)

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方员会在一定时间后继续继续处理。

感谢您提供的需求和示例代码。

您的需求是在 ProTable 中，支持表格多级排序。在 Antd 中使用 Table 组件进行多级排序时，默认只能允许单列排序。因此，需要对 ProTable 的实现进行修改以支持多级排序。

具体的解决方案是，将所有列的排序字段、排序方式存入到 `sorterState` 对象中，然后实现对多级排序的支持。最后，将 `sorterState` 传入到 `dataSource` 属性中，便可以实现对多级排序的支持。您可以参考上面的代码实现。

此外，您可以参考 Antd Table 组件文档中的 排序 表格来了解更多相关内容。

希望这些信息能够帮助您解决问题。如果您有任何进一步的问题，欢迎继续提问，我会尽力帮助您。
