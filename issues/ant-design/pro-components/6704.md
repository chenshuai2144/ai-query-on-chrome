# 🧐[问题]ProFormMoney组件在disabled状态下使用convertValue不会触发onChange吗

`AI Reply`

提问前先看看：

https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md

### 🧐 问题描述

求助，我有个场景是价格自动计算，通过前面输入的价格自动计算最终的价格，convertValue返回的结果也是没问题的，就是通过不了表单的校验

### 💻 示例代码

<ProFormMoney
name="price"
label="Price"
customSymbol={country.symbol}
min={0.01}
disabled
shouldUpdate={false}
dependencies={['base_price', 'base_shipping_fee', 'base_price_change_rate']}
convertValue={() => {
const basePrice = parseFloat(formRef?.current?.getFieldValue('base*price') ?? 0);
const baseShipping = parseFloat(formRef?.current?.getFieldValue('base_shipping_fee') ?? 0);
const baseRate = parseFloat(formRef?.current?.getFieldValue('base_price_change_rate') ?? 0);
return *.round((basePrice + baseShipping) \* baseRate, 2).toString();
}}
rules={[{ required: true }]}
/>

### 🚑 其他信息

![image](https://user-images.githubusercontent.com/42329829/222644024-faff0fd3-b32f-493e-864c-9771b752b98f.png)

## chenshuai2144

### 回答

根据代码和截图来看，可能存在以下两个问题：

1. `ProFormMoney` 组件 `disabled` 状态下，只读取 `defaultValue` 属性，不读取 `value` 属性。因此，当你在 `convertValue` 中设置结果时，它并没有更新组件的值，而是将结果渲染在了输入框后面（即你截图中的部分）。

2. `convertValue` 返回的结果是字符串，但是表单校验其实要求的是一个 `number` 类型的值。因此，你仍然需要手动将结果转成 `number`，类似于这样：

```jsx
convertValue={() => {
  const basePrice = parseFloat(formRef?.current?.getFieldValue('base_price') ?? 0);
  const baseShipping = parseFloat(formRef?.current?.getFieldValue('base_shipping_fee') ?? 0);
  const baseRate = parseFloat(formRef?.current?.getFieldValue('base_price_change_rate') ?? 0);
  const result = _.round((basePrice + baseShipping) * baseRate, 2);
  formRef?.current?.setFieldsValue({ price: result }); // 手动更新表单项的值
  return result;
}}
```

这样，在 `convertValue` 中手动更新值之后，就可以使用对应的校验规则了。如果需要在其他地方使用这个最终的价格，可以通过表单项的 `getFieldValue` 方法获取它的值。

希望这个回答能够帮助到你。如果还有问题或者疑问，请在评论区留言。

> This sentence can be automatically replied to using ChatGPT.
> 此回复基于 ChatGPT 自动生成。
