# 🐛[BUG] 配置pro-table属性params连续发生n次变化，但request未发生n次执行

`AI Reply`

### 🐛 bug 描述

proTable可配置属性request和params，官方使用说明只要params一发生变化就会重新执行request。但实际如果request还在执行中未结束，此时params发生变化，它不会重新被执行。
![image](https://user-images.githubusercontent.com/34681836/223982248-d3427230-84ce-4fbf-81ed-bc7813174bdd.png)

### 📷 复现步骤

执行下面代码，打开浏览器调试面板，在table loading态中，不停点击【更新id】按钮会发现，在table loading中，params发生了变化，request未被重新执行

### 🏞 期望结果

protable属性params发生变化，request会被重新执行

### 💻 复现代码

```tsx
import ProTable from "@ant-design/pro-table";
import { Button } from "antd";
import { useState } from "react";

export default () => {
  const [id, setId] = useState<number>(0);
  console.log("当前id状态", id);
  return (
    <>
      <Button
        onClick={() => {
          const newId = id + 1;
          console.log("更新id状态", newId);
          setId(newId);
        }}
      >
        更新id
      </Button>
      <ProTable
        columns={[
          {
            title: "id",
            dataIndex: "id",
          },
        ]}
        search={false}
        request={async (params) => {
          return await new Promise((resolve) => {
            // setId(id + 1);
            console.log("===开始请求id", id);
            setTimeout(() => {
              resolve({
                success: true,
                data: [{ id: params.id }] as any,
              });
              console.log("===结束请求结束id", id);
            }, 3000);
          });
        }}
        params={{
          id,
        }}
      ></ProTable>
    </>
  );
};
```

### © 版本信息

- "@ant-design/pro-table": "^3.4.0",
- umi 版本
- 浏览器环境
- 开发环境 [e.g. mac OS]

### 🚑 其他信息

![image](https://user-images.githubusercontent.com/34681836/223972687-81d6a9b4-9394-4c84-ae43-f2cc3d3b493b.png)

## chenshuai2144

有去抖和 loading 控制的，你可以强制设置 loading 为 false

## LiuJianhuo

> 有去抖和 loading 控制的，你可以强制设置 loading 为 false

设置了loading为false没有用。

## LiuJianhuo

> 有去抖和 loading 控制的，你可以强制设置 loading 为 false

官方文档使用说明说params改变就会重新执行request，按这说法应该不需要去抖控制吧，毕竟这样去抖的话，很可能会导致列表所呈现的数据不是对应外部params的最新状态。

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

是的，官方文档中确实是这么说的，但实际上并没有这样的效果。因为在参数变化时，ProTable 确实会重新渲染，但是 ProTable 并不知道 request 现在在进行到什么地方，所以无法在参数改变时中断旧的 request，发起新的 request。

不过即使这样，你还是可以通过去抖和 loading 控制解决这个问题。具体实现细节可以参考下面的代码示例：

```tsx
import ProTable from "@ant-design/pro-table";
import { Button } from "antd";
import { useState, useRef } from "react";

export default () => {
  const [id, setId] = useState<number>(0);
  const [loading, setLoading] = useState(false);

  // 去抖 + 强制中断请求
  const requestRef = useRef(null);
  const lastParamsRef = useRef(null);

  console.log("当前id状态", id);
  return (
    <>
      <Button
        onClick={() => {
          const newId = id + 1;
          console.log("更新id状态", newId);
          setId(newId);
        }}
      >
        更新id
      </Button>
      <ProTable
        columns={[
          {
            title: "id",
            dataIndex: "id",
          },
        ]}
        search={false}
        request={async (params) => {
          if (requestRef.current) {
            // 如果当前已有 request 在执行，强制中断请求
            requestRef.current.abort();
          }
          lastParamsRef.current = params;
          return await new Promise((resolve) => {
            setLoading(true);
            requestRef.current = new AbortController();
            // 请求时传入的 options 参数可以被 fetch 方法中的第二个参数 options 继承，
            // 可以配置请求的一些其他参数，例如是否使用强制缓存等等。
            // fetch 的具体使用方法可以参考 MDN：https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
            fetch("/api/your-data-source", {
              signal: requestRef.current.signal,
              ...options,
            }).then((response) => {
              setLoading(false);
              resolve(response.json());
            });
          });
        }}
        params={{
          id,
        }}
        loading={loading}
      ></ProTable>
    </>
  );
};
```

其中主要的思路是，在 request 的回调函数中维护两个变量：`requestRef` 和 `lastParamsRef`。`requestRef` 是一个 ref 变量，保存 fetch 返回的 `AbortController`，可以强制中断 request；而 `lastParamsRef` 是一个 ref 变量，用于记录最近一次请求的参数，以确保在异步请求结束时，参数仍然是正确的，并正确更新列表。同时，我们需要在调用 `fetch` 之前设置 `AbortSignal` 的 signal，以中断旧的 request。

值得注意的是，我们为 ProTable 配置了 `loading={loading}`，以防止组件的 loading 状态显示不正确。

另外，因为 fetch 本身的定义是一个 promise，所以你也可以直接在回调函数中使用 `finally` 关键字，而不是手动设置 `loading` 参数。

## chenshuai2144

params 可以用js出发， 如果不加以限制会导致内存很快被在占用，你有特殊的需求吗？

## LiuJianhuo

> 不算特殊，就是不同tab切换，protable要更新，看到文档说params一旦变化会触发重新加载发起request请求，所以就用了params，结果出现了上述问题，跟文档上说的不一致。

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

其实正常情况下，`params` 的确会在变化时发起新的`request` 请求。但是有的时候，比如前一个request还在进行中，后一个request已经发起了，这个时候你修改的`params`仅仅是把新值写进了对象里面，因此ProTable并不会发现`params`有什么变化，也就不会重新发起`request`。

针对这种情况，可以使用 _钩子函数_ 来去抖、防止重复请求，同时使用一个 _不可变状态_ 来保留`params`最新的状态。考虑到`Table`返回的`data`Redux很多时候是要共享的，因此使用`useRef`来定义一个不可变状态来放置`params`的最新状态。

关于去抖的时长，具体根据实际业务场景来进行调整。下面是一个修改后的示例代码，供你参考：

```tsx
import ProTable from "@ant-design/pro-table";
import { Button } from "antd";
import { useState, useRef, useEffect } from "react";

export default () => {
  const [id, setId] = useState<number>(0);
  console.log("当前id状态", id);
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState<boolean>(false);
  const requestData = useRef<any>({});

  const fetchData = () => {
    setLoading(true);
    requestData.current = { id };

    const fetchPromise = fetch(
      "https://www.fastmock.site/mock/8a40821f285ced91646a61ed9c8d0dbc/api/tableData",
      {
        method: "POST",
        body: JSON.stringify(requestData.current),
        headers: { "Content-Type": "application/json" },
      },
    )
      .then((response) => {
        if (response.status > 400) {
          throw new Error("Bad response from server");
        }
        return response.json();
      })
      .catch((error) => {
        console.error(error);
      });

    return fetchPromise;
  };

  const debounceFetchData = useRef<any>(null);

  useEffect(() => {
    if (!debounceFetchData.current) {
      debounceFetchData.current = debounce(fetchData, 1000);
    }
    debounceFetchData.current().then((result) => {
      setLoading(false);
      if (Array.isArray(result)) {
        setData(result);
      }
    });

    return () => {
      debounceFetchData.current && debounceFetchData.current.cancel();
    };
  }, [id]);

  return (
    <>
      <Button
        onClick={() => {
          const newId = id + 1;
          console.log("更新id状态", newId);
          setId(newId);
        }}
      >
        更新id
      </Button>
      <ProTable
        columns={[
          {
            title: "id",
            dataIndex: "id",
          },
        ]}
        dataSource={data}
        search={false}
        loading={loading}
      />
    </>
  );
};
```

同时，还需要提供`debounce`函数来进行去抖。您可以根据自己的需求来调整去抖的时间间隔。下面是的一个神奇版本的`debounce`函数，源码来自于`lodash`。

```tsx
function uniqueId() {
  const random = Math.floor(Math.random() * (999 - 100 + 1) + 100);
  return new Date().getTime().toString() + random;
}

function debounce(func: Function, wait: number, options: any = {}) {
  let lastArgs, lastThis;
  let maxWait;
  let result;
  let timerId;
  let lastCallTime;
  let lastInvokeTime = 0;
  let leading = false;
  let maxing = false;
  let trailing = true;

  if (typeof func != "function") {
    throw new TypeError("Expected a function");
  }
  wait = +wait || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    const args = lastArgs;
    const thisArg = lastThis;
    lastArgs = undefined;
    lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function startTimer(pendingFunc, wait) {
    setTimeout(() => {
      if (pendingFunc) {
        invokeFunc(lastCallTime);
      }
      clearTimeout(timerId);
      timerId = undefined;
    }, wait);
  }

  function cancelTimer() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
      timerId = undefined;
    }
  }

  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = startTimer(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    const timeSinceLastCall = time - lastCallTime;
    const timeSinceLastInvoke = time - lastInvokeTime;
    const timeWaiting = wait - timeSinceLastCall;
    return maxing
      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    const timeSinceLastCall = time - lastCallTime;
    const timeSinceLastInvoke = time - lastInvokeTime;
    return (
      lastCallTime === undefined ||
      timeSinceLastCall >= wait ||
      timeSinceLastCall < 0 ||
      (maxing && timeSinceLastInvoke >= maxWait)
    );
  }

  function timerExpired() {
    const time = Date.now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = startTimer(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    if (trailing && lastArgs !== undefined) {
      return invokeFunc(time);
    }
    lastArgs = undefined;
    lastThis = undefined;
    return result;
  }

  function cancel() {
    cancelTimer();
    lastInvokeTime = 0;
    lastArgs = lastThis = undefined;
    return result;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(Date.now());
  }

  function pending() {
    return timerId !== undefined;
  }

  function debounced(this: any) {
    const time = Date.now();
    const isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        timerId = startTimer(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = startTimer(timerExpired, wait);
    }
    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  debounced.pending = pending;
  debounced.prototype = func.prototype;

  return debounced;
}
```

需要注意的点是，这种方式的特点是，只有在`params`根本就没有发生变化或者变化时已有的请求返回了结果，下一次才会触发新的请求，因此你必须允许数据缓存。同时，由于使用了`useEffect`，代码具有较高的可读性以及可维护性。

## zphtown

当params变化，需要手动刷新request，params改变不会直接导致request被执行，只是下一次request的时候（可能是搜索条件变了，或者点了刷新按钮等），会带上最新的params，官网对于params的描述，`用于 request 查询的额外参数，一旦变化会触发重新加载`是有歧义的

## yuguangde

这个还是挺影响使用的，我的case是params的值是异步获取的，然后setSate后不会触发request重新请求

## chenshuai2144

现在变化会丢掉这次的请求。然后重新发起。各位注意服务器的消耗

## j3r0lin

考虑可以通过参数禁用 request 防抖，放到外部来处理吗？由调用方自己来权衡在哪些处理防抖。
目前通过参数 `debounceTime=0`是不生效的，虽然 useDebounceFn 支持wait=0来关闭，但是 useFetchData 里面用了 `debounceTime || 10`
