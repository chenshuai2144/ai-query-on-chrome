# ğŸ›[BUG] é…ç½®pro-tableå±æ€§paramsè¿ç»­å‘ç”Ÿnæ¬¡å˜åŒ–ï¼Œä½†requestæœªå‘ç”Ÿnæ¬¡æ‰§è¡Œ

`AI Reply`

### ğŸ› bug æè¿°

proTableå¯é…ç½®å±æ€§requestå’Œparamsï¼Œå®˜æ–¹ä½¿ç”¨è¯´æ˜åªè¦paramsä¸€å‘ç”Ÿå˜åŒ–å°±ä¼šé‡æ–°æ‰§è¡Œrequestã€‚ä½†å®é™…å¦‚æœrequestè¿˜åœ¨æ‰§è¡Œä¸­æœªç»“æŸï¼Œæ­¤æ—¶paramså‘ç”Ÿå˜åŒ–ï¼Œå®ƒä¸ä¼šé‡æ–°è¢«æ‰§è¡Œã€‚
![image](https://user-images.githubusercontent.com/34681836/223982248-d3427230-84ce-4fbf-81ed-bc7813174bdd.png)

### ğŸ“· å¤ç°æ­¥éª¤

æ‰§è¡Œä¸‹é¢ä»£ç ï¼Œæ‰“å¼€æµè§ˆå™¨è°ƒè¯•é¢æ¿ï¼Œåœ¨table loadingæ€ä¸­ï¼Œä¸åœç‚¹å‡»ã€æ›´æ–°idã€‘æŒ‰é’®ä¼šå‘ç°ï¼Œåœ¨table loadingä¸­ï¼Œparamså‘ç”Ÿäº†å˜åŒ–ï¼Œrequestæœªè¢«é‡æ–°æ‰§è¡Œ

### ğŸ æœŸæœ›ç»“æœ

protableå±æ€§paramså‘ç”Ÿå˜åŒ–ï¼Œrequestä¼šè¢«é‡æ–°æ‰§è¡Œ

### ğŸ’» å¤ç°ä»£ç 

```tsx
import ProTable from "@ant-design/pro-table";
import { Button } from "antd";
import { useState } from "react";

export default () => {
  const [id, setId] = useState<number>(0);
  console.log("å½“å‰idçŠ¶æ€", id);
  return (
    <>
      <Button
        onClick={() => {
          const newId = id + 1;
          console.log("æ›´æ–°idçŠ¶æ€", newId);
          setId(newId);
        }}
      >
        æ›´æ–°id
      </Button>
      <ProTable
        columns={[
          {
            title: "id",
            dataIndex: "id",
          },
        ]}
        search={false}
        request={async (params) => {
          return await new Promise((resolve) => {
            // setId(id + 1);
            console.log("===å¼€å§‹è¯·æ±‚id", id);
            setTimeout(() => {
              resolve({
                success: true,
                data: [{ id: params.id }] as any,
              });
              console.log("===ç»“æŸè¯·æ±‚ç»“æŸid", id);
            }, 3000);
          });
        }}
        params={{
          id,
        }}
      ></ProTable>
    </>
  );
};
```

### Â© ç‰ˆæœ¬ä¿¡æ¯

- "@ant-design/pro-table": "^3.4.0",
- umi ç‰ˆæœ¬
- æµè§ˆå™¨ç¯å¢ƒ
- å¼€å‘ç¯å¢ƒ [e.g. mac OS]

### ğŸš‘ å…¶ä»–ä¿¡æ¯

![image](https://user-images.githubusercontent.com/34681836/223972687-81d6a9b4-9394-4c84-ae43-f2cc3d3b493b.png)

## chenshuai2144

æœ‰å»æŠ–å’Œ loading æ§åˆ¶çš„ï¼Œä½ å¯ä»¥å¼ºåˆ¶è®¾ç½® loading ä¸º false

## LiuJianhuo

> æœ‰å»æŠ–å’Œ loading æ§åˆ¶çš„ï¼Œä½ å¯ä»¥å¼ºåˆ¶è®¾ç½® loading ä¸º false

è®¾ç½®äº†loadingä¸ºfalseæ²¡æœ‰ç”¨ã€‚

## LiuJianhuo

> æœ‰å»æŠ–å’Œ loading æ§åˆ¶çš„ï¼Œä½ å¯ä»¥å¼ºåˆ¶è®¾ç½® loading ä¸º false

å®˜æ–¹æ–‡æ¡£ä½¿ç”¨è¯´æ˜è¯´paramsæ”¹å˜å°±ä¼šé‡æ–°æ‰§è¡Œrequestï¼ŒæŒ‰è¿™è¯´æ³•åº”è¯¥ä¸éœ€è¦å»æŠ–æ§åˆ¶å§ï¼Œæ¯•ç«Ÿè¿™æ ·å»æŠ–çš„è¯ï¼Œå¾ˆå¯èƒ½ä¼šå¯¼è‡´åˆ—è¡¨æ‰€å‘ˆç°çš„æ•°æ®ä¸æ˜¯å¯¹åº”å¤–éƒ¨paramsçš„æœ€æ–°çŠ¶æ€ã€‚

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> æ­¤å›å¤åŸºäº ChatGPT è‡ªåŠ¨ç”Ÿæˆï¼Œå¯ä»¥å°è¯•ä¸‹æ–¹æ¡ˆï¼Œå®˜æ–¹äººå‘˜ä¼šåœ¨ä¸€å®šæ—¶é—´åç»§ç»­ç»§ç»­å¤„ç†ã€‚

æ˜¯çš„ï¼Œå®˜æ–¹æ–‡æ¡£ä¸­ç¡®å®æ˜¯è¿™ä¹ˆè¯´çš„ï¼Œä½†å®é™…ä¸Šå¹¶æ²¡æœ‰è¿™æ ·çš„æ•ˆæœã€‚å› ä¸ºåœ¨å‚æ•°å˜åŒ–æ—¶ï¼ŒProTable ç¡®å®ä¼šé‡æ–°æ¸²æŸ“ï¼Œä½†æ˜¯ ProTable å¹¶ä¸çŸ¥é“ request ç°åœ¨åœ¨è¿›è¡Œåˆ°ä»€ä¹ˆåœ°æ–¹ï¼Œæ‰€ä»¥æ— æ³•åœ¨å‚æ•°æ”¹å˜æ—¶ä¸­æ–­æ—§çš„ requestï¼Œå‘èµ·æ–°çš„ requestã€‚

ä¸è¿‡å³ä½¿è¿™æ ·ï¼Œä½ è¿˜æ˜¯å¯ä»¥é€šè¿‡å»æŠ–å’Œ loading æ§åˆ¶è§£å†³è¿™ä¸ªé—®é¢˜ã€‚å…·ä½“å®ç°ç»†èŠ‚å¯ä»¥å‚è€ƒä¸‹é¢çš„ä»£ç ç¤ºä¾‹ï¼š

```tsx
import ProTable from "@ant-design/pro-table";
import { Button } from "antd";
import { useState, useRef } from "react";

export default () => {
  const [id, setId] = useState<number>(0);
  const [loading, setLoading] = useState(false);

  // å»æŠ– + å¼ºåˆ¶ä¸­æ–­è¯·æ±‚
  const requestRef = useRef(null);
  const lastParamsRef = useRef(null);

  console.log("å½“å‰idçŠ¶æ€", id);
  return (
    <>
      <Button
        onClick={() => {
          const newId = id + 1;
          console.log("æ›´æ–°idçŠ¶æ€", newId);
          setId(newId);
        }}
      >
        æ›´æ–°id
      </Button>
      <ProTable
        columns={[
          {
            title: "id",
            dataIndex: "id",
          },
        ]}
        search={false}
        request={async (params) => {
          if (requestRef.current) {
            // å¦‚æœå½“å‰å·²æœ‰ request åœ¨æ‰§è¡Œï¼Œå¼ºåˆ¶ä¸­æ–­è¯·æ±‚
            requestRef.current.abort();
          }
          lastParamsRef.current = params;
          return await new Promise((resolve) => {
            setLoading(true);
            requestRef.current = new AbortController();
            // è¯·æ±‚æ—¶ä¼ å…¥çš„ options å‚æ•°å¯ä»¥è¢« fetch æ–¹æ³•ä¸­çš„ç¬¬äºŒä¸ªå‚æ•° options ç»§æ‰¿ï¼Œ
            // å¯ä»¥é…ç½®è¯·æ±‚çš„ä¸€äº›å…¶ä»–å‚æ•°ï¼Œä¾‹å¦‚æ˜¯å¦ä½¿ç”¨å¼ºåˆ¶ç¼“å­˜ç­‰ç­‰ã€‚
            // fetch çš„å…·ä½“ä½¿ç”¨æ–¹æ³•å¯ä»¥å‚è€ƒ MDNï¼šhttps://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
            fetch("/api/your-data-source", {
              signal: requestRef.current.signal,
              ...options,
            }).then((response) => {
              setLoading(false);
              resolve(response.json());
            });
          });
        }}
        params={{
          id,
        }}
        loading={loading}
      ></ProTable>
    </>
  );
};
```

å…¶ä¸­ä¸»è¦çš„æ€è·¯æ˜¯ï¼Œåœ¨ request çš„å›è°ƒå‡½æ•°ä¸­ç»´æŠ¤ä¸¤ä¸ªå˜é‡ï¼š`requestRef` å’Œ `lastParamsRef`ã€‚`requestRef` æ˜¯ä¸€ä¸ª ref å˜é‡ï¼Œä¿å­˜ fetch è¿”å›çš„ `AbortController`ï¼Œå¯ä»¥å¼ºåˆ¶ä¸­æ–­ requestï¼›è€Œ `lastParamsRef` æ˜¯ä¸€ä¸ª ref å˜é‡ï¼Œç”¨äºè®°å½•æœ€è¿‘ä¸€æ¬¡è¯·æ±‚çš„å‚æ•°ï¼Œä»¥ç¡®ä¿åœ¨å¼‚æ­¥è¯·æ±‚ç»“æŸæ—¶ï¼Œå‚æ•°ä»ç„¶æ˜¯æ­£ç¡®çš„ï¼Œå¹¶æ­£ç¡®æ›´æ–°åˆ—è¡¨ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬éœ€è¦åœ¨è°ƒç”¨ `fetch` ä¹‹å‰è®¾ç½® `AbortSignal` çš„ signalï¼Œä»¥ä¸­æ–­æ—§çš„ requestã€‚

å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬ä¸º ProTable é…ç½®äº† `loading={loading}`ï¼Œä»¥é˜²æ­¢ç»„ä»¶çš„ loading çŠ¶æ€æ˜¾ç¤ºä¸æ­£ç¡®ã€‚

å¦å¤–ï¼Œå› ä¸º fetch æœ¬èº«çš„å®šä¹‰æ˜¯ä¸€ä¸ª promiseï¼Œæ‰€ä»¥ä½ ä¹Ÿå¯ä»¥ç›´æ¥åœ¨å›è°ƒå‡½æ•°ä¸­ä½¿ç”¨ `finally` å…³é”®å­—ï¼Œè€Œä¸æ˜¯æ‰‹åŠ¨è®¾ç½® `loading` å‚æ•°ã€‚

## chenshuai2144

params å¯ä»¥ç”¨jså‡ºå‘ï¼Œ å¦‚æœä¸åŠ ä»¥é™åˆ¶ä¼šå¯¼è‡´å†…å­˜å¾ˆå¿«è¢«åœ¨å ç”¨ï¼Œä½ æœ‰ç‰¹æ®Šçš„éœ€æ±‚å—ï¼Ÿ

## LiuJianhuo

> ä¸ç®—ç‰¹æ®Šï¼Œå°±æ˜¯ä¸åŒtabåˆ‡æ¢ï¼Œprotableè¦æ›´æ–°ï¼Œçœ‹åˆ°æ–‡æ¡£è¯´paramsä¸€æ—¦å˜åŒ–ä¼šè§¦å‘é‡æ–°åŠ è½½å‘èµ·requestè¯·æ±‚ï¼Œæ‰€ä»¥å°±ç”¨äº†paramsï¼Œç»“æœå‡ºç°äº†ä¸Šè¿°é—®é¢˜ï¼Œè·Ÿæ–‡æ¡£ä¸Šè¯´çš„ä¸ä¸€è‡´ã€‚

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> æ­¤å›å¤åŸºäº ChatGPT è‡ªåŠ¨ç”Ÿæˆï¼Œå¯ä»¥å°è¯•ä¸‹æ–¹æ¡ˆï¼Œå®˜æ–¹äººå‘˜ä¼šåœ¨ä¸€å®šæ—¶é—´åç»§ç»­ç»§ç»­å¤„ç†ã€‚

å…¶å®æ­£å¸¸æƒ…å†µä¸‹ï¼Œ`params` çš„ç¡®ä¼šåœ¨å˜åŒ–æ—¶å‘èµ·æ–°çš„`request` è¯·æ±‚ã€‚ä½†æ˜¯æœ‰çš„æ—¶å€™ï¼Œæ¯”å¦‚å‰ä¸€ä¸ªrequestè¿˜åœ¨è¿›è¡Œä¸­ï¼Œåä¸€ä¸ªrequestå·²ç»å‘èµ·äº†ï¼Œè¿™ä¸ªæ—¶å€™ä½ ä¿®æ”¹çš„`params`ä»…ä»…æ˜¯æŠŠæ–°å€¼å†™è¿›äº†å¯¹è±¡é‡Œé¢ï¼Œå› æ­¤ProTableå¹¶ä¸ä¼šå‘ç°`params`æœ‰ä»€ä¹ˆå˜åŒ–ï¼Œä¹Ÿå°±ä¸ä¼šé‡æ–°å‘èµ·`request`ã€‚

é’ˆå¯¹è¿™ç§æƒ…å†µï¼Œå¯ä»¥ä½¿ç”¨ _é’©å­å‡½æ•°_ æ¥å»æŠ–ã€é˜²æ­¢é‡å¤è¯·æ±‚ï¼ŒåŒæ—¶ä½¿ç”¨ä¸€ä¸ª _ä¸å¯å˜çŠ¶æ€_ æ¥ä¿ç•™`params`æœ€æ–°çš„çŠ¶æ€ã€‚è€ƒè™‘åˆ°`Table`è¿”å›çš„`data`Reduxå¾ˆå¤šæ—¶å€™æ˜¯è¦å…±äº«çš„ï¼Œå› æ­¤ä½¿ç”¨`useRef`æ¥å®šä¹‰ä¸€ä¸ªä¸å¯å˜çŠ¶æ€æ¥æ”¾ç½®`params`çš„æœ€æ–°çŠ¶æ€ã€‚

å…³äºå»æŠ–çš„æ—¶é•¿ï¼Œå…·ä½“æ ¹æ®å®é™…ä¸šåŠ¡åœºæ™¯æ¥è¿›è¡Œè°ƒæ•´ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªä¿®æ”¹åçš„ç¤ºä¾‹ä»£ç ï¼Œä¾›ä½ å‚è€ƒï¼š

```tsx
import ProTable from "@ant-design/pro-table";
import { Button } from "antd";
import { useState, useRef, useEffect } from "react";

export default () => {
  const [id, setId] = useState<number>(0);
  console.log("å½“å‰idçŠ¶æ€", id);
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState<boolean>(false);
  const requestData = useRef<any>({});

  const fetchData = () => {
    setLoading(true);
    requestData.current = { id };

    const fetchPromise = fetch(
      "https://www.fastmock.site/mock/8a40821f285ced91646a61ed9c8d0dbc/api/tableData",
      {
        method: "POST",
        body: JSON.stringify(requestData.current),
        headers: { "Content-Type": "application/json" },
      },
    )
      .then((response) => {
        if (response.status > 400) {
          throw new Error("Bad response from server");
        }
        return response.json();
      })
      .catch((error) => {
        console.error(error);
      });

    return fetchPromise;
  };

  const debounceFetchData = useRef<any>(null);

  useEffect(() => {
    if (!debounceFetchData.current) {
      debounceFetchData.current = debounce(fetchData, 1000);
    }
    debounceFetchData.current().then((result) => {
      setLoading(false);
      if (Array.isArray(result)) {
        setData(result);
      }
    });

    return () => {
      debounceFetchData.current && debounceFetchData.current.cancel();
    };
  }, [id]);

  return (
    <>
      <Button
        onClick={() => {
          const newId = id + 1;
          console.log("æ›´æ–°idçŠ¶æ€", newId);
          setId(newId);
        }}
      >
        æ›´æ–°id
      </Button>
      <ProTable
        columns={[
          {
            title: "id",
            dataIndex: "id",
          },
        ]}
        dataSource={data}
        search={false}
        loading={loading}
      />
    </>
  );
};
```

åŒæ—¶ï¼Œè¿˜éœ€è¦æä¾›`debounce`å‡½æ•°æ¥è¿›è¡Œå»æŠ–ã€‚æ‚¨å¯ä»¥æ ¹æ®è‡ªå·±çš„éœ€æ±‚æ¥è°ƒæ•´å»æŠ–çš„æ—¶é—´é—´éš”ã€‚ä¸‹é¢æ˜¯çš„ä¸€ä¸ªç¥å¥‡ç‰ˆæœ¬çš„`debounce`å‡½æ•°ï¼Œæºç æ¥è‡ªäº`lodash`ã€‚

```tsx
function uniqueId() {
  const random = Math.floor(Math.random() * (999 - 100 + 1) + 100);
  return new Date().getTime().toString() + random;
}

function debounce(func: Function, wait: number, options: any = {}) {
  let lastArgs, lastThis;
  let maxWait;
  let result;
  let timerId;
  let lastCallTime;
  let lastInvokeTime = 0;
  let leading = false;
  let maxing = false;
  let trailing = true;

  if (typeof func != "function") {
    throw new TypeError("Expected a function");
  }
  wait = +wait || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    const args = lastArgs;
    const thisArg = lastThis;
    lastArgs = undefined;
    lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function startTimer(pendingFunc, wait) {
    setTimeout(() => {
      if (pendingFunc) {
        invokeFunc(lastCallTime);
      }
      clearTimeout(timerId);
      timerId = undefined;
    }, wait);
  }

  function cancelTimer() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
      timerId = undefined;
    }
  }

  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = startTimer(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    const timeSinceLastCall = time - lastCallTime;
    const timeSinceLastInvoke = time - lastInvokeTime;
    const timeWaiting = wait - timeSinceLastCall;
    return maxing
      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    const timeSinceLastCall = time - lastCallTime;
    const timeSinceLastInvoke = time - lastInvokeTime;
    return (
      lastCallTime === undefined ||
      timeSinceLastCall >= wait ||
      timeSinceLastCall < 0 ||
      (maxing && timeSinceLastInvoke >= maxWait)
    );
  }

  function timerExpired() {
    const time = Date.now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = startTimer(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    if (trailing && lastArgs !== undefined) {
      return invokeFunc(time);
    }
    lastArgs = undefined;
    lastThis = undefined;
    return result;
  }

  function cancel() {
    cancelTimer();
    lastInvokeTime = 0;
    lastArgs = lastThis = undefined;
    return result;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(Date.now());
  }

  function pending() {
    return timerId !== undefined;
  }

  function debounced(this: any) {
    const time = Date.now();
    const isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        timerId = startTimer(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = startTimer(timerExpired, wait);
    }
    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  debounced.pending = pending;
  debounced.prototype = func.prototype;

  return debounced;
}
```

éœ€è¦æ³¨æ„çš„ç‚¹æ˜¯ï¼Œè¿™ç§æ–¹å¼çš„ç‰¹ç‚¹æ˜¯ï¼Œåªæœ‰åœ¨`params`æ ¹æœ¬å°±æ²¡æœ‰å‘ç”Ÿå˜åŒ–æˆ–è€…å˜åŒ–æ—¶å·²æœ‰çš„è¯·æ±‚è¿”å›äº†ç»“æœï¼Œä¸‹ä¸€æ¬¡æ‰ä¼šè§¦å‘æ–°çš„è¯·æ±‚ï¼Œå› æ­¤ä½ å¿…é¡»å…è®¸æ•°æ®ç¼“å­˜ã€‚åŒæ—¶ï¼Œç”±äºä½¿ç”¨äº†`useEffect`ï¼Œä»£ç å…·æœ‰è¾ƒé«˜çš„å¯è¯»æ€§ä»¥åŠå¯ç»´æŠ¤æ€§ã€‚

## zphtown

å½“paramså˜åŒ–ï¼Œéœ€è¦æ‰‹åŠ¨åˆ·æ–°requestï¼Œparamsæ”¹å˜ä¸ä¼šç›´æ¥å¯¼è‡´requestè¢«æ‰§è¡Œï¼Œåªæ˜¯ä¸‹ä¸€æ¬¡requestçš„æ—¶å€™ï¼ˆå¯èƒ½æ˜¯æœç´¢æ¡ä»¶å˜äº†ï¼Œæˆ–è€…ç‚¹äº†åˆ·æ–°æŒ‰é’®ç­‰ï¼‰ï¼Œä¼šå¸¦ä¸Šæœ€æ–°çš„paramsï¼Œå®˜ç½‘å¯¹äºparamsçš„æè¿°ï¼Œ`ç”¨äºÂ requestÂ æŸ¥è¯¢çš„é¢å¤–å‚æ•°ï¼Œä¸€æ—¦å˜åŒ–ä¼šè§¦å‘é‡æ–°åŠ è½½`æ˜¯æœ‰æ­§ä¹‰çš„

## yuguangde

è¿™ä¸ªè¿˜æ˜¯æŒºå½±å“ä½¿ç”¨çš„ï¼Œæˆ‘çš„caseæ˜¯paramsçš„å€¼æ˜¯å¼‚æ­¥è·å–çš„ï¼Œç„¶åsetSateåä¸ä¼šè§¦å‘requesté‡æ–°è¯·æ±‚

## chenshuai2144

ç°åœ¨å˜åŒ–ä¼šä¸¢æ‰è¿™æ¬¡çš„è¯·æ±‚ã€‚ç„¶åé‡æ–°å‘èµ·ã€‚å„ä½æ³¨æ„æœåŠ¡å™¨çš„æ¶ˆè€—

## j3r0lin

è€ƒè™‘å¯ä»¥é€šè¿‡å‚æ•°ç¦ç”¨ request é˜²æŠ–ï¼Œæ”¾åˆ°å¤–éƒ¨æ¥å¤„ç†å—ï¼Ÿç”±è°ƒç”¨æ–¹è‡ªå·±æ¥æƒè¡¡åœ¨å“ªäº›å¤„ç†é˜²æŠ–ã€‚
ç›®å‰é€šè¿‡å‚æ•° `debounceTime=0`æ˜¯ä¸ç”Ÿæ•ˆçš„ï¼Œè™½ç„¶ useDebounceFn æ”¯æŒwait=0æ¥å…³é—­ï¼Œä½†æ˜¯ useFetchData é‡Œé¢ç”¨äº† `debounceTime || 10`
