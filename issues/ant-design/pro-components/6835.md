# [In mobile]: The page content dose not overflow over the PageContainer.

`AI Reply`

### 🧐 Problem Description

At present, we are utilizing ProLayout from antd-pro. I have enclosed the content with a PageContainer wrapper, which functions well on larger screens. However, on mobile screens, it does not work as intended, as the content overflows the PageContainer.

![image](https://user-images.githubusercontent.com/3382355/220844542-efd2f1ed-38ce-4460-b55b-08fec7f124d6.png)

### What is expected?

The page content does not need to overflow over the PageContainer, as the PageContainer wrapper must automatically adjust the sizing.

### 💻 Sample code

```
export const ReactTable = (props: IReactTableInterface) => {
    const { columns, data, pageOptions, showPagination, pageNumber, pages, pageSizeCount, setPageSizeCount,
        setPageNumber, noDataText } = props;
    const [pageNum, setPageNum] = useState(1);
    const {
        getTableProps,
        getTableBodyProps,
        headerGroups,
        prepareRow,
        page,
        canPreviousPage,
        canNextPage,
        pageCount,
        gotoPage,
        nextPage,
        previousPage,
        setPageSize,
        state: { pageIndex, pageSize },
    } = useTable(
        {
            columns,
            data,
            initialState: {
                pageIndex: pageNumber || 0,
                pageSize: pageSizeCount || 10,
                pageCount: pages
            },
        },
        usePagination
    );

    useEffect(() => {
        setPageNum(pageNumber + 1);
    }, [pageNumber]);

    useEffect(() => {
        if (setPageNumber && pageIndex > -1) {
            setPageNumber(pageIndex);
        }
    }, [pageIndex]);

    useEffect(() => {
        if (setPageSizeCount) {
            setPageSizeCount(pageSize);
        }
    }, [pageSize]);

    // Render the UI for your table
    return (
        <>
            <table {...getTableProps()} className={css(StyleSheet.table)}>
                <thead>
                    {headerGroups.map(headerGroup => (
                        <tr {...headerGroup.getHeaderGroupProps()}>
                            {headerGroup.headers.map(column => (
                                <th {...column.getHeaderProps()}>{column.render('Header')}</th>
                            ))}
                        </tr>
                    ))}
                </thead>
                <tbody {...getTableBodyProps()}>
                    {page.length ? (
                        page.map((row, i) => {
                            prepareRow(row)
                            return (
                                <tr {...row.getRowProps()}>
                                    {row.cells.map(cell => {
                                        return <td {...cell.getCellProps()}>{cell.render('Cell')}</td>
                                    })}
                                </tr>
                            )
                        })
                    ) : (
                        <tr className={css(StyleSheet.noData)}>
                            <div className={'no-data-text'}>
                                {noDataText || 'No Data'}
                            </div>
                        </tr>
                    )}
                </tbody>
            </table>
            {(showPagination && page.length) ? (
                <div className={css(StyleSheet.pagination)}>
                    <div className={css(StyleSheet.btn)}>
                        <Button
                            size={'large'}
                            onClick={() => previousPage()}
                            disabled={!canPreviousPage}
                        >Previous</Button>
                    </div>
                    <div className={css(StyleSheet.pageChange)}>
                        <div>
                            <span>{`Page `}</span>
                            <Input
                                size={'large'}
                                type={'number'}
                                className={css(StyleSheet.input)}
                                value={pageNum}
                                min={1}
                                max={pageCount}
                                onChange={e => {
                                    const page = e.target.value && Number(e.target.value)
                                    setPageNum(page);
                                }}
                                onBlur={e => gotoPage(pageNum - 1)}
                            />
                            <span>{` of ${pageCount}`}</span>
                        </div>
                        <div>
                            <Select
                                size={'large'}
                                value={pageSize}
                                onChange={value => setPageSize(value)}
                                options={(pageOptions || [10, 15, 20, 25]).map((value) => ({ value, label: `${value} rows` }))}
                            />
                        </div>
                    </div>
                    <div className={css(StyleSheet.btn, StyleSheet.next)}>
                        <Button
                            size={'large'}
                            onClick={() => nextPage()}
                            disabled={!canNextPage}
                        >Next</Button>
                    </div>
                </div>
            ) : null}
        </>
    );
}

const StyleSheet: any = {
    table: {
        width: '100%',
        border: '1px solid rgba(0,0,0,0.1) !important',
        '> thead': {
            backgroundColor: 'rgb(245, 245, 245)',
            boxShadow: '0 2px 15px 0 rgb(0 0 0 / 15%)',
            '> tr': {
                '> th': {
                    padding: '5px 10px',
                    borderRight: '1px solid rgba(0,0,0,0.05)',
                    textAlign: 'left'
                },
            }
        },
        '> tbody': {
            '> tr': {
                borderBottom: 'solid 1px rgba(0,0,0,0.05)',
                '> td': {
                    borderRight: '1px solid rgba(0,0,0,0.02)',
                    whiteSpace: 'nowrap',
                    textOverflow: 'ellipsis',
                    padding: '10px 7px',
                    overflow: 'hidden',
                }
            },
        }
    },
    pagination: {
        border: '1px solid rgba(0,0,0,0.1)',
        display: 'flex',
        padding: '5px'
    },
    next: {
        marginLeft: 'auto',
        marginRight: '0px',
    },
    pageChange: {
        margin: 'auto',
        display: 'flex',
        gap: '100px'
    },
    btn: {
        '& .ant-btn': {
            width: '200px',
            color: 'rgba(0,0,0,0.6)',
            background: 'rgba(0,0,0,0.1)',
            borderColor: 'transparent !important',
            ':hover': {
                background: 'rgba(0,0,0,0.3)',
                color: '#fff'
            },
        },
        '& .ant-btn[disabled]': {
            width: '200px',
            color: 'rgba(0,0,0,0.6)',
            background: 'rgba(0,0,0,0.1)',
            borderColor: 'transparent !important',
            opacity: 0.5
        }
    },
    input: {
        width: '60px'
    },
    noData: {
        height: '100px',
        '& .no-data-text': {
            color: '#00000080',
            margin: '40px 0',
            width: '100%',
            textAlign: 'center',
            position: 'absolute',
        }
    }
}
```

### 🚑 Other information

| Environment | Info              |
| ----------- | ----------------- |
| antd        | 5.1.1             |
| React       | "react": "18.0.0" |
| System      | ubuntu 20         |
| Browser     | Google Chrome     |

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

One possible solution to this problem is to add the following CSS to the PageContainer wrapper:

```
overflow-x: hidden;
```

This will prevent horizontal scrolling on smaller screens and ensure that the content is always within the bounds of the container. Additionally, you can specify a `max-width` property for the PageContainer to limit the width on larger screens.

```
<PageContainer style={{ maxWidth: '1200px', overflowX: 'hidden' }} >
    // Content goes here
</PageContainer>
```

You can learn more about `overflow` here: [CSS overflow property](https://www.w3schools.com/cssref/pr_pos_overflow.asp).

If this solution doesn't work or if you have any further questions, please feel free to provide more details or code snippets.
