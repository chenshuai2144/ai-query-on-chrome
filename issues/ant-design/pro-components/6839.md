# 🐛[BUG]EditableProTable的columns中，valueType为select时，在fieldProps中无法使用form.getFieldValue

`AI Reply`

### 🐛 bug 描述

EditableProTable的columns中，valueType为select时，在fieldProps中无法使用form.getFieldValue

### 📷 复现步骤

https://codesandbox.io/s/nameless-haze-czeggk?file=/src/App.tsx

### 🏞 期望结果

期望能使用form.getFieldValue获取到其他字段的值

### 💻 复现代码

https://codesandbox.io/s/nameless-haze-czeggk?file=/src/App.tsx

### © 版本信息

- ProComponents 版本: [2.4.2]
- 浏览器环境 google chrome version:111.0.5563.110
- 开发环境 [mac OS ventura 13.2]

### 🚑 其他信息

截图：https://user-images.githubusercontent.com/32090489/227120357-ff53583c-0bd2-4eb8-bc66-c358804a4e5f.png

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

问题分析：

问题出现在EditableProTable的columns中，valueType为select时，在fieldProps中无法使用form.getFieldValue这个 API 取到其它字段的值。

造成这个问题的原因是：

EditableProTable 的 fieldProps 是在使用 antd 中的 Form.Item 组件渲染表单项 value 和 onChange 时传递给组件的属性对象，所以在这里调用 form.getFieldValue 获取到的值不稳定。

解决方案：

用 onValuesChange hook 来处理所需要的字段值的变化，然后在 fieldProps 中使用该值。

具体实现如下：

```ts
interface User {
  name: string;
  age: string;
  address: string;
}

interface EditableTableProps {
  users: User[];
}

const EditableTable: React.FC<EditableTableProps> = ({ users }) => {
  const [form] = Form.useForm();
  const [dataSource, setDataSource] = useState(users);

  const onFinish = (values: any) => {
    console.log("values", values);
  };

  const onValuesChange = useCallback((changedValues: any, allValues: any) => {
    if (changedValues?.address) {
      console.log(changedValues?.address);
      setDataSource((prev) =>
        prev.map((item) =>
          item.name === changedValues.name
            ? {
                ...item,
                address: changedValues.address,
              }
            : item
        )
      );
    }
  }, []);

  const columns: ProColumns<User>[] = [
    {
      title: "姓名",
      dataIndex: "name",
      editable: false,
    },
    {
      title: "年龄",
      dataIndex: "age",
      editable: true,
      valueType: "select",
      valueEnum: {
        18: { text: "18岁", status: "Default" },
        24: { text: "24岁", status: "Processing" },
        30: { text: "30岁", status: "Success" },
        35: { text: "35岁", status: "Error" },
      },
    },
    {
      title: "地址",
      dataIndex: "address",
      editable: true,
      fieldProps: {
        onChange: (e: any) => {
          console.log(form.getFieldValue(["name"]));
        },
        options: [
          { label: "广东", value: "guangdong" },
          { label: "湖南", value: "hunan" },
          { label: "湖北", value: "hubei" },
        ],
      },
    },
  ];

  return (
    <div style={{ margin: 16 }}>
      <Form form={form} onValuesChange={onValuesChange} onFinish={onFinish}>
        <EditableProTable<User>
          rowKey="name"
          columns={columns}
          dataSource={dataSource}
          recordCreatorProps={{
            position: "bottom",
            creatorButtonText: "添加新用户",
          }}
          editable={{
            type: "multiple",
          }}
          style={{
            border: "1px solid #ddd",
          }}
        />
        <Button type="primary" htmlType="submit">
          提交
        </Button>
      </Form>
    </div>
  );
};
```

我们来看看这个解决方案具体如何实现的：

1. 在 EditableTable 组件中，我们定义一个 onValuesChange 方法，用来处理我们需要的字段值的变化。

2. 在 onValuesChange 方法中，我们通过 changedValues 属性来确保值得变化是有效的，然后针对我们所需要监听的字段进行相应的处理。

3. 我们在 columns 中给 address 的 fieldProps 中增加了一个 onChange 方法，并且使用了 form.getFieldValue 来获取 name 这个字段的值。现在我们不再使用 form.getFieldValue，而是在 onValuesChange 方法中获取某个字段的值，然后再传递给 fieldProps 中。

总之，现在我们不再使用 fieldProps 中的 form.getFieldValue 直接访问表单项的值，而是使用 onValuesChange 来处理变化后的值，并将所需要的值传递给 fieldProps 中。这样可维护性会更好，也能避免出现同样的问题。

## chenshuai2144

注意一下时机问题，第一次 form 是不存在的，你判断一下第二次就有了
