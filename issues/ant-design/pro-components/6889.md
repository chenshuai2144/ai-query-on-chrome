# 🧐[问题] 关于loading状态的问题

`AI Reply`

一般业务都会在最后一列增加一些编辑或者删除操作，按理说在进行删除操作的时候，是要让table整个进入loading状态，然后在操作完刷新一下table把。
如下，模拟一下业务耗时的方法

```
{
    title: '操作',
    valueType: 'option',
    align: 'center',
    render: (_, record, idx, action) => <>
        <Popconfirm
            placement="topRight"
            title='确认删除？'
            onConfirm={async () => {
                setLoading(true);
                await new Promise(resolve => setTimeout(resolve, 1500));
                action?.reload();
                setLoading(false);
            }
            onCancel={() => {
            }}
        >
            <a onClick={() => { }}>删除</a>
        </Popconfirm>
    </>
}
```

protable的request默认托管了loading状态，现在改为手动管理之后。通过table的request默认的loading状态就没了。
这样查询、翻页的时候都需要手动进行loading状态管理。
但是没找到比较合适的地方统一设置状态，在onSubmit里开启loading对翻页无效果，这样又得在pagination里的onchange再设置一次。而且没有合适的地方设置关闭loading？试了下由onSubmit里开启loading后，在postData和request里都没法关闭loading。

想问问有没有什么优雅的方式能兼顾这些情况呢。

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

🤔[思路] 对于loading状态的优雅解决方案

你可以试试使用useEffect钩子函数，与局部的状态变量来解决该问题。具体思路可以这样实现：

1. 在组件顶部定义一个useState，用于控制loading状态。
2. 将这个useState状态变量作为prop传递给每一列的操作组件。
3. 在操作组件里通过父组件传递的变量来控制loading状态。
4. 使用useEffect钩子函数，在组件didMount时设置table的loading状态为当前的loading状态变量。
5. 在组件willUnmount时，同步卸载loading状态变量。

通过这个方式可以使得loading状态在内部操作数据时被自动管理，而在查询、翻页操作中可以通过useState手动调节loading状态，并通过useEffect自动的同步到Table中去。

具体的代码实现可以参考下面的示例：

```jsx
import React, { useState, useEffect } from "react";
import { Table, Popconfirm } from "antd";

const data = [
  { name: "Alice", age: 23 },
  { name: "Bob", age: 24 },
];

const columns = [
  {
    title: "Name",
    dataIndex: "name",
  },
  {
    title: "Age",
    dataIndex: "age",
  },
  {
    title: "Action",
    align: "center",
    render: (text, record, index) => (
      <Action
        index={index}
        setLoading={setLoading}
        onDelete={() => {
          // Simulate a long time operation
          setLoading(true);
          setTimeout(() => {
            setData(data.filter((d, i) => i !== index));
            setLoading(false);
          }, 1500);
        }}
      />
    ),
  },
];

const Action = ({ index, setLoading, onDelete }) => (
  <Popconfirm title="Are you sure to delete?" onConfirm={onDelete}>
    <a onClick={() => setLoading(true)}>Delete</a>
  </Popconfirm>
);

const MyTable = () => {
  const [loading, setLoading] = useState(false);
  const [data, setData] = useState([]);

  useEffect(() => {
    setLoading(loading);
  }, [loading]);

  return <Table loading={loading} dataSource={data} columns={columns} />;
};

export default MyTable;
```

希望这个方案可以解决你的问题。

## adi291

我现在是采用如下方式解决的

```tsx
const Demo: React.FC = () => {
  const actionRef = useRef<ActionType>();
  const [loading, setLoading] = useState<boolean>(false);

  const columns: ProColumns<GithubIssueItem>[] = [
    {
      dataIndex: "index",
      valueType: "indexBorder",
      width: 48,
    },
    {
      title: "操作",
      valueType: "option",
      key: "option",
      render: (text, record, _, action) => [
        <Popconfirm
          title="确定删除？"
          onConfirm={async () => {
            setLoading(true); // 1
            await new Promise((resolve) => setTimeout(resolve, 2000));
            setLoading(false); // 2
            action?.reload();
          }}
        >
          <a>删除</a>
        </Popconfirm>,
      ],
    },
  ];

  return (
    <ProTable<GithubIssueItem>
      actionRef={actionRef}
      columns={columns}
      loading={loading}
      request={async (params = {}, sort, filter) => {
        setLoading(true); // 3
        // if (!loading) setLoading(true); // 4
        let data;
        try {
          data = await request<{ data: GithubIssueItem[] }>(
            "https://proapi.azurewebsites.net/github/issues",
            { params },
          );
        } catch (reason) {
          // showError...
          data = { success: true, data: [] };
        }
        setLoading(false); // 5
        return data;
      }}
      rowKey="id"
      cardBordered
      search={{ labelWidth: "auto" }}
      pagination={{ pageSize: 5 }}
      headerTitle="高级表格"
    />
  );
};
```

目前这种方式唯一的遗憾是实际上是两次状态的变更，删除的方法执行时一次，reload更新表的时候一次，从用户感受上来说可能会疑惑会什么出现两次加载，但从代码上来看是合理的，本来就是两块单独的逻辑。
当初尝试发现无法关闭是我想当然的想让它只有一次加载状态，代码是去掉 2、3，加上了4，所以实际上在删除后没有关闭loading从而导致根本没有进入reload。

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

你这种方案对于解决表格中的操作中的loading是没问题的。但是你在request中的loading状态的管理上有些问题，导致了第一次删除时loading状态是没被更新的，可能影响到用户体验。为了更精细地管理loading状态，我们建议使用 Promise.finally，这样可以保证无论 Promise 状态最终如何，我们都可以完成状态管理。具体的代码可以参考下面的示例：

```tsx
const Demo: React.FC = () => {
  const actionRef = useRef<ActionType>();
  const [loading, setLoading] = useState<boolean>(false);

  const columns: ProColumns<GithubIssueItem>[] = [
    {
      dataIndex: "index",
      valueType: "indexBorder",
      width: 48,
    },
    {
      title: "操作",
      valueType: "option",
      key: "option",
      render: (_, record, idx, action) => (
        <>
          <Popconfirm
            title="确定删除？"
            onConfirm={() => {
              setLoading(true);
              new Promise((resolve) => setTimeout(resolve, 2000)).finally(
                () => {
                  action?.reload();
                  setLoading(false);
                },
              );
            }}
          >
            <a>删除</a>
          </Popconfirm>
        </>
      ),
    },
  ];

  return (
    <ProTable<GithubIssueItem>
      actionRef={actionRef}
      columns={columns}
      loading={loading}
      request={async (params = {}, sort, filter) => {
        setLoading(true);
        try {
          const data = await request<{ data: GithubIssueItem[] }>(
            "https://proapi.azurewebsites.net/github/issues",
            { params },
          );
          return { data, success: true };
        } catch (reason) {
          // showError...
          return { success: false, data: [] };
        } finally {
          setLoading(false);
        }
      }}
      rowKey="id"
      cardBordered
      search={{ labelWidth: "auto" }}
      pagination={{ pageSize: 5 }}
      headerTitle="高级表格"
    />
  );
};
```

具体来说，在删除处理方法的最后，通过 finally 块统一更新 loading，这样即使 delete 操作本身就始终处于 pending 状态，用户也不会感到比较迷惑了，同时代码更简洁清晰。在request中的loading状态管理上，通过try-catch-finally的方式，将数据请求的逻辑和办理loading状态的逻辑分别放在不同的块中，更加容易理解和维护。

## adi291

> > TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> > 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。
>
> 你这种方案对于解决表格中的操作中的loading是没问题的。但是你在request中的loading状态的管理上有些问题，导致了第一次删除时loading状态是没被更新的，可能影响到用户体验。为了更精细地管理loading状态，我们建议使用 Promise.finally，这样可以保证无论 Promise 状态最终如何，我们都可以完成状态管理。具体的代码可以参考下面的示例：
>
> ```tsx
> const Demo: React.FC = () => {
>   const actionRef = useRef<ActionType>();
>   const [loading, setLoading] = useState<boolean>(false);
>
>   const columns: ProColumns<GithubIssueItem>[] = [
>     {
>       dataIndex: "index",
>       valueType: "indexBorder",
>       width: 48,
>     },
>     {
>       title: "操作",
>       valueType: "option",
>       key: "option",
>       render: (_, record, idx, action) => (
>         <>
>           <Popconfirm
>             title="确定删除？"
>             onConfirm={() => {
>               setLoading(true);
>               new Promise((resolve) => setTimeout(resolve, 2000)).finally(
>                 () => {
>                   action?.reload();
>                   setLoading(false);
>                 },
>               );
>             }}
>           >
>             <a>删除</a>
>           </Popconfirm>
>         </>
>       ),
>     },
>   ];
>
>   return (
>     <ProTable<GithubIssueItem>
>       actionRef={actionRef}
>       columns={columns}
>       loading={loading}
>       request={async (params = {}, sort, filter) => {
>         setLoading(true);
>         try {
>           const data = await request<{ data: GithubIssueItem[] }>(
>             "https://proapi.azurewebsites.net/github/issues",
>             { params },
>           );
>           return { data, success: true };
>         } catch (reason) {
>           // showError...
>           return { success: false, data: [] };
>         } finally {
>           setLoading(false);
>         }
>       }}
>       rowKey="id"
>       cardBordered
>       search={{ labelWidth: "auto" }}
>       pagination={{ pageSize: 5 }}
>       headerTitle="高级表格"
>     />
>   );
> };
> ```
>
> 具体来说，在删除处理方法的最后，通过 finally 块统一更新 loading，这样即使 delete 操作本身就始终处于 pending 状态，用户也不会感到比较迷惑了，同时代码更简洁清晰。在request中的loading状态管理上，通过try-catch-finally的方式，将数据请求的逻辑和办理loading状态的逻辑分别放在不同的块中，更加容易理解和维护。

这样确实更严谨些。
问一下这是GPT哪个版本的模型，下次直接问GPT好了。

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

这是OpenAI的 GPT-3 模型。ChatGPT 是 GPT-3 的一个变种，可以使用对话式方式回答提问。
