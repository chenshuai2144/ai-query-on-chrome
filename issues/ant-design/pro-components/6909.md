# 🧐[问题]ProTable 多列排序

`AI Reply`

### 🧐 问题描述

在使用ProTable，对多列开启排序功能，如创建时间、加入群的数量、互动时间，都设置了sorter: true， 即使用了服务端排序。
但当某一列如创建时间排序的状态（升序/降序），点击另外一列，如加入的群数量，一直显示在升序的状态，无法变成降序或者取消排序。
并且对于sortOrder控件状态，使用了umi的useRequest params参数中对应的排序状态值来控制。

### 💻 示例代码

<img width="839" alt="image" src="https://user-images.githubusercontent.com/23149314/230758052-a2ebedef-ba30-4418-8345-d3d3db983b04.png">

<!--
如果你有解决方案，在这里清晰地阐述
-->

### 🚑 其他信息

<!--
如截图等其他信息可以贴在这里
-->

## hexiaomin496

请问如何解决无法同时进行多列且为服务端排序的问题

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

在使用 `ProTable` 处理多列且使用服务端排序时，需要注意当一个列处于排序状态时，点击其他列时需要正确修改 `sortOrder` 和 `sortType` 这两个状态值。

根据您的代码截图，`sortOrder` 和 `sortType` 是由 `useRequest` 钩子的 `params` 对象控制的，所以我们需要正确修改 `params.sorter` 对象来实现多列排序。以下是示例代码，请根据您的具体情况进行修改：

```typescript
import React, { useRef } from 'react';
import ProTable, { ProColumns } from '@ant-design/pro-table';
import { useRequest } from 'umi';

export default function Demo() {
  const tableRef = useRef();
  const { data, params, run } = useRequest(
    ({ pageSize, current: page, sorter }) => {
      const { field, order } = sorter || {};

      // 将多列排序的相关信息发送给服务端
      const multiSorter = [];
      if (field) {
        multiSorter.push({
          field,
          order,
        });
      }
      if (params.sorter) {
        params.sorter.forEach(item => {
          if (item.field !== field) {
            multiSorter.push(item);
          }
        });
      }

      return service.fetch({
        pageSize,
        page,
        multiSorter,
      });
    },
    {
      paginated: true,
      defaultPageSize: 20,
    }
  );

  const columns: ProColumns<DataType>[] = [
    {
      title: '创建时间',
      dataIndex: 'createdAt',
      sorter: true,
    },
    {
      title: '加入的群数量',
      dataIndex: 'groupCount',
      sorter: true,
    },
    {
      title: '互动时间',
      dataIndex: 'interactionTime',
      sorter: true,
    },
  ];

  const handleTableChange = (pagination, filters, sorter) => {
    // 更新 `params` 对象
    const newParams = {
      ...params,
      sorter: [],
    };
    if (sorter.field) {
      newParams.sorter.push({
        field: sorter.field,
        order: sorter.order,
      });
    }
    tableRef.current.setParams(newParams);

    run({
      // 分页信息
      pageSize: pagination.pageSize,
      current: pagination.current,
      // 排序信息
      sorter,
    });
  };

  return (
    <ProTable
      columns={columns}
      dataSource={data?.list}
      pagination={{
        ...data?.pagination,
        showQuickJumper: true,
        showSizeChanger: true,
      }}
      onChange={handleTableChange}
      search={false}
      options={{
        reloadBtn: true,
        fullScreen: true,
      }}
      tableAlertRender={false}
      rowKey="id"
      ref={tableRef}
    />
  );
}
```

这里我们在请求数据时，通过 `multiSorter` 对象将服务端需要使用的多列排序信息发送出去，修改表格状态时也需要使用多列排序信息来判断当前状态。修改 `params` 对象采用了浅拷贝的方式，保证了对原始 `params` 的修改不会破坏其它状态。不过需要注意，这种方法不适用于后端不支持多列排序的情况。

希望这个解决方案能够帮到你，如有疑问，欢迎讨论！

## hexiaomin496

> > TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> > 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。
>
> 在使用 `ProTable` 处理多列且使用服务端排序时，需要注意当一个列处于排序状态时，点击其他列时需要正确修改 `sortOrder` 和 `sortType` 这两个状态值。
>
> 根据您的代码截图，`sortOrder` 和 `sortType` 是由 `useRequest` 钩子的 `params` 对象控制的，所以我们需要正确修改 `params.sorter` 对象来实现多列排序。以下是示例代码，请根据您的具体情况进行修改：
>
> ```ts
> import React, { useRef } from 'react';
> import ProTable, { ProColumns } from '@ant-design/pro-table';
> import { useRequest } from 'umi';
>
> export default function Demo() {
>   const tableRef = useRef();
>   const { data, params, run } = useRequest(
>     ({ pageSize, current: page, sorter }) => {
>       const { field, order } = sorter || {};
>
>       // 将多列排序的相关信息发送给服务端
>       const multiSorter = [];
>       if (field) {
>         multiSorter.push({
>           field,
>           order,
>         });
>       }
>       if (params.sorter) {
>         params.sorter.forEach(item => {
>           if (item.field !== field) {
>             multiSorter.push(item);
>           }
>         });
>       }
>
>       return service.fetch({
>         pageSize,
>         page,
>         multiSorter,
>       });
>     },
>     {
>       paginated: true,
>       defaultPageSize: 20,
>     }
>   );
>
>   const columns: ProColumns<DataType>[] = [
>     {
>       title: '创建时间',
>       dataIndex: 'createdAt',
>       sorter: true,
>     },
>     {
>       title: '加入的群数量',
>       dataIndex: 'groupCount',
>       sorter: true,
>     },
>     {
>       title: '互动时间',
>       dataIndex: 'interactionTime',
>       sorter: true,
>     },
>   ];
>
>   const handleTableChange = (pagination, filters, sorter) => {
>     // 更新 `params` 对象
>     const newParams = {
>       ...params,
>       sorter: [],
>     };
>     if (sorter.field) {
>       newParams.sorter.push({
>         field: sorter.field,
>         order: sorter.order,
>       });
>     }
>     tableRef.current.setParams(newParams);
>
>     run({
>       // 分页信息
>       pageSize: pagination.pageSize,
>       current: pagination.current,
>       // 排序信息
>       sorter,
>     });
>   };
>
>   return (
>     <ProTable
>       columns={columns}
>       dataSource={data?.list}
>       pagination={{
>         ...data?.pagination,
>         showQuickJumper: true,
>         showSizeChanger: true,
>       }}
>       onChange={handleTableChange}
>       search={false}
>       options={{
>         reloadBtn: true,
>         fullScreen: true,
>       }}
>       tableAlertRender={false}
>       rowKey="id"
>       ref={tableRef}
>     />
>   );
> }
> ```
>
> 这里我们在请求数据时，通过 `multiSorter` 对象将服务端需要使用的多列排序信息发送出去，修改表格状态时也需要使用多列排序信息来判断当前状态。修改 `params` 对象采用了浅拷贝的方式，保证了对原始 `params` 的修改不会破坏其它状态。不过需要注意，这种方法不适用于后端不支持多列排序的情况。
>
> 希望这个解决方案能够帮到你，如有疑问，欢迎讨论！

好的 谢谢~我这就去实践一下！感谢您

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

不客气，祝您实践愉快！如有疑问，欢迎随时再来询问。

## chenshuai2144

<img width="818" alt="image" src="https://github.com/ant-design/pro-components/assets/8186664/537bbf3f-62ed-4407-9184-478ac1bc4803">

对某一列数据进行筛选，使用列的 filters 属性来指定需要筛选菜单的列，onFilter 用于筛选当前数据，filterMultiple 用于指定多选和单选。
对某一列数据进行排序，通过指定列的 sorter 函数即可启动排序按钮。sorter: function(rowA, rowB) { ... }， rowA、rowB 为比较的两个行数据。
sortDirections: ['ascend' | 'descend']改变每列可用的排序方式，切换排序时按数组内容依次切换，设置在 table props 上时对所有列生效。你可以通过设置 ['ascend', 'descend', 'ascend'] 禁止排序恢复到默认状态。
使用 defaultSortOrder 属性，设置列的默认排序顺序。
