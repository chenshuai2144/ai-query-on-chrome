# 🐛[BUG]StepsForm.StepForm不能拆分组件

`form`,`🎖️  featrue`,`AI Reply`

提问前先看看：

https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md

### 🐛 bug 描述

每一步骤需要填写的资料比较多，放在同一个文件里会导致文件过大，不方便维护，在拆分的时候，只有第一步可以提交，后面会出现caught TypeError: Cannot read properties of undefined (reading 'current')的错误

### 📷 复现步骤

`// index.tsx
 <StepsForm>
          <A />
          <B />
        </StepsForm>`
`// A.tsx
<StepsForm.StepForm
        name="a"
        onFinish={async () => {
          return true;
        }}
      >
        <ProFormText name="aa" />
      </StepsForm.StepForm>`
`// B.tsx
<StepsForm.StepForm
        name="b"
        onFinish={async () => {
          return true;
        }}
      >
        <ProFormText name="bb" />
      </StepsForm.StepForm>`

### 🏞 期望结果

form可以提交

### © 版本信息

- ProComponents 版本: 2.4.4
- umi 版本 @umijs/max 4.0.33
- 浏览器环境 谷歌浏览器
- 开发环境 mac OS

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

这个问题看起来是因为拆分组件后有多个StepsForm.StepForm，而当第二个StepsForm.StepForm渲染时，它的ref还没有被存储到StepsForm组件内部的formRefs属性中。

可以尝试在StepsForm组件内部添加一个formRefs属性来存储子组件的ref，并在每个StepsForm.StepForm组件中调用Props的onFormReady方法来将ref存储到StepsForm组件内部的formRefs属性中。

具体代码如下：

```jsx
import React, { Component } from "react";
import { Steps, Button, message } from "antd";
import { StepsForm } from "@ant-design/pro-form";
import ProForm, { ProFormText } from "@ant-design/pro-form";

const { Step } = Steps;

class MyStepForm extends Component {
  formRef = React.createRef();

  handleFormReady = (formValue) => {
    const { name, children } = this.props;
    const { formRefs } = this.props;

    formRefs[name] = this.formRef.current;

    const fn = this.props.onFormReady;

    if (fn) {
      fn({
        [name]: formValue || {},
        children,
        name: this.props.name,
      });
    }
  };

  render() {
    const { children } = this.props;

    return (
      <div ref={this.formRef}>
        <ProForm onFinish={async () => true} onReady={this.handleFormReady}>
          {children}
        </ProForm>
      </div>
    );
  }
}

class MyStepsForm extends Component {
  formRefs = {};

  handleSubmit = async () => {
    const { onFinish } = this.props;

    let values = [];
    let error = false;

    for (let i = 0; i < React.Children.count(this.props.children); i++) {
      const child = React.Children.toArray(this.props.children)[i];

      if (this.formRefs[child.props.name]) {
        const formValue =
          await this.formRefs[child.props.name].validateFields();

        if (!error) {
          values.push(formValue);
        }

        if (!(await this.formRefs[child.props.name].submit())) {
          error = true;
          message.error("错误红框提示");
        }
      }
    }

    if (!error) {
      onFinish(values);
    }
  };

  render() {
    let currStep = 0;

    return (
      <div>
        <Steps>
          {React.Children.map(this.props.children, (child, i) => {
            currStep++;
            return (
              <Step
                title={`步骤${currStep}`}
                key={`step-${child.props.name}`}
              />
            );
          })}
        </Steps>
        {React.Children.map(this.props.children, (child, i) => {
          return (
            <div key={child.props.name}>
              {React.cloneElement(child, {
                onFormReady: this.handleFormReady,
                formRefs: this.formRefs,
              })}
            </div>
          );
        })}
        <Button type="primary" onClick={this.handleSubmit}>
          提交
        </Button>
      </div>
    );
  }
}

MyStepsForm.StepForm = MyStepForm;

export default MyStepsForm;
```

使用上述代码，需要将旧的StepsForm和StepsForm.StepForm替换为MyStepsForm和MyStepsForm.StepForm。

使用方式和之前的方法相同，只是多了一个形参:

```jsx
<MyStepsForm onFinish={this.handleSubmit}>
  <MyStepsForm.StepForm name="a">
    <ProFormText name="aa" />
  </MyStepsForm.StepForm>
  <MyStepsForm.StepForm name="b">
    <ProFormText name="bb" />
  </MyStepsForm.StepForm>
</MyStepsForm>
```

## 95zz

> > TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> > 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。
>
> 这个问题看起来是因为拆分组件后有多个StepsForm.StepForm，而当第二个StepsForm.StepForm渲染时，它的ref还没有被存储到StepsForm组件内部的formRefs属性中。
>
> 可以尝试在StepsForm组件内部添加一个formRefs属性来存储子组件的ref，并在每个StepsForm.StepForm组件中调用Props的onFormReady方法来将ref存储到StepsForm组件内部的formRefs属性中。
>
> 具体代码如下：
>
> ```js
> import React, { Component } from "react";
> import { Steps, Button, message } from "antd";
> import { StepsForm } from "@ant-design/pro-form";
> import ProForm, { ProFormText } from "@ant-design/pro-form";
>
> const { Step } = Steps;
>
> class MyStepForm extends Component {
>   formRef = React.createRef();
>
>   handleFormReady = (formValue) => {
>     const { name, children } = this.props;
>     const { formRefs } = this.props;
>
>     formRefs[name] = this.formRef.current;
>
>     const fn = this.props.onFormReady;
>
>     if (fn) {
>       fn({
>         [name]: formValue || {},
>         children,
>         name: this.props.name,
>       });
>     }
>   };
>
>   render() {
>     const { children } = this.props;
>
>     return (
>       <div ref={this.formRef}>
>         <ProForm onFinish={async () => true} onReady={this.handleFormReady}>
>           {children}
>         </ProForm>
>       </div>
>     );
>   }
> }
>
> class MyStepsForm extends Component {
>   formRefs = {};
>
>   handleSubmit = async () => {
>     const { onFinish } = this.props;
>
>     let values = [];
>     let error = false;
>
>     for (let i = 0; i < React.Children.count(this.props.children); i++) {
>       const child = React.Children.toArray(this.props.children)[i];
>
>       if (this.formRefs[child.props.name]) {
>         const formValue =
>           await this.formRefs[child.props.name].validateFields();
>
>         if (!error) {
>           values.push(formValue);
>         }
>
>         if (!(await this.formRefs[child.props.name].submit())) {
>           error = true;
>           message.error("错误红框提示");
>         }
>       }
>     }
>
>     if (!error) {
>       onFinish(values);
>     }
>   };
>
>   render() {
>     let currStep = 0;
>
>     return (
>       <div>
>         <Steps>
>           {React.Children.map(this.props.children, (child, i) => {
>             currStep++;
>             return (
>               <Step
>                 title={`步骤${currStep}`}
>                 key={`step-${child.props.name}`}
>               />
>             );
>           })}
>         </Steps>
>         {React.Children.map(this.props.children, (child, i) => {
>           return (
>             <div key={child.props.name}>
>               {React.cloneElement(child, {
>                 onFormReady: this.handleFormReady,
>                 formRefs: this.formRefs,
>               })}
>             </div>
>           );
>         })}
>         <Button type="primary" onClick={this.handleSubmit}>
>           提交
>         </Button>
>       </div>
>     );
>   }
> }
>
> MyStepsForm.StepForm = MyStepForm;
>
> export default MyStepsForm;
> ```
>
> 使用上述代码，需要将旧的StepsForm和StepsForm.StepForm替换为MyStepsForm和MyStepsForm.StepForm。
>
> 使用方式和之前的方法相同，只是多了一个形参:
>
> ```js
> <MyStepsForm onFinish={this.handleSubmit}>
>   <MyStepsForm.StepForm name="a">
>     <ProFormText name="aa" />
>   </MyStepsForm.StepForm>
>   <MyStepsForm.StepForm name="b">
>     <ProFormText name="bb" />
>   </MyStepsForm.StepForm>
> </MyStepsForm>
> ```

1. 页面会多出来 【提交】【重置】，请问是怎么解决
2. Step1与Step2内容都显示在了同一页面上了

## wyhooo

+1。现在一个文件堆了 500+ 行。。。

## ChinaMrAlvin

const formInstance = Form.useFormInstance()；可以拿到form实例
