# 需要完整的自定义valueType的例子

`AI Reply`

需要一个完整的自定义valueType的例子，需求是定义一个单独的组件，自定义valueType，可以和原始组件一样，用在表格columns或者schema表单中，不需要在columns中单独写render及renderFormItem。

## Teeoo

```tsx
const valueTypeMap: Record<string, ProRenderFieldPropsType> = {
		html: {
			renderFormItem(text, props) {
				return <ProFormHtml value={text} {...props} />
			}
		},
		upload: {
			renderFormItem: (text, props) => {
				return <ProFormUpload value={text} {...props} />
			}
		}
	}
<ProConfigProvider valueTypeMap={valueTypeMap}>
	<Outlet />
</ProConfigProvider>
```

```tsx
export const ProFormHtml: FC<ProFieldFCRenderProps> = (props) => {
  return (
    <ProForm.Item>
      <WangeEitor {...props.fieldProps} />
    </ProForm.Item>
  );
};

export const ProFormUpload: FC<ProFieldFCRenderProps> = (props) => {
  const { value } = props;
  const { initialState, setInitialState } = useModel("@@initialState");

  const [fileList, setFileList] = useState<Record<string, UploadFile[]>>({});

  useEffect(() => {
    const fetchData = async () => {
      const { data } = await UPLOAD_TOKEN();
      storage.set("qiniu", data, data.expire);
      setInitialState((s) => ({ ...s, qiniu: data }));
    };
    if (!initialState?.qiniu) {
      fetchData();
    }
  }, []);

  useEffect(() => {
    if (Object.keys(fileList).length !== 0) {
      props.fieldProps.onChange?.(fileList[props.fieldProps.id]);
    }
  }, [fileList]);

  useEffect(() => {
    const item: any = {};
    if (!value) {
      item[props.fieldProps.id] = [];
    } else {
      if (Array.isArray(value) && value.length !== 0) {
        item[props.fieldProps.id] = value;
      } else if (typeof value === "string") {
        item[props.fieldProps.id] = [
          {
            uid: uuid(),
            name: value.split("/").at(-1) || "",
            status: "done",
            url: value,
          },
        ];
      } else {
        // PS:不出意外的话上传会走到这里,但是下边已经处理了所以这里不做处理
      }
    }
    setFileList((pre: any) => ({ ...pre, ...item }));
  }, [value]);

  const fileName = (file: File) => {
    const suffix = uuid();
    const curr = formatDate(new Date(), "YYYYMMDD");
    const fileName = file.name || "";
    const exp = fileName.split(".");
    const ext = exp.length >= 2 ? exp.at(-1) : "";
    return encodeURI(
      `${props.fieldProps.directory || "default"}/${curr}/${suffix}.${ext}`,
    );
  };

  const customRequest = async ({ file, onSuccess }: UploadRequestOption) => {
    const observable = qiniu.upload(
      file as File,
      fileName(file as File),
      initialState?.qiniu?.token || "",
    );
    observable.subscribe({
      next: ({ total }) => {
        message.loading({
          content: `开始上传文件\n进度：${parseInt(String(total.percent))}%`,
          key: "qiniu",
        });
      },
      error: (err) => {
        message.error({ content: err.message, key: "qiniu" });
      },
      complete: (res) => {
        onSuccess!(res);
        const tmp: Record<string, UploadFile<any>[]> = {};
        if (!fileList[props.fieldProps.id]) {
          tmp[props.fieldProps.id] = [
            {
              uid: uuid(),
              name: (file as File).name,
              status: "done",
              url: `${initialState?.qiniu?.cdn_url}/${res.key}`,
            },
          ];
        } else {
          tmp[props.fieldProps.id] = [
            ...fileList[props.fieldProps.id],
            {
              uid: uuid(),
              name: (file as File).name,
              status: "done",
              url: `${initialState?.qiniu?.cdn_url}/${res.key}`,
            },
          ];
        }
        setFileList((prev: any) => ({ ...prev, ...tmp }));
        message.success({ content: `文件上成功`, key: "qiniu" });
      },
    });
  };

  const onRemove = (file: UploadFile) => {
    const item: any = {};
    // xxx
    setFileList((pre: any) => ({ ...pre, ...item }));
  };

  return (
    <ProFormUploadButton
      {...props?.fieldProps}
      fileList={fileList[props.fieldProps.id] || []}
      fieldProps={{
        customRequest,
        onRemove,
        progress: {
          strokeColor: {
            "0%": "#108ee9",
            "100%": "#87d068",
          },
          strokeWidth: 3,
          format: (percent) => percent && `${parseFloat(percent.toFixed(2))}%`,
        },
      }}
    />
  );
};
```

```tsx
[
  {
    valueType: "group",
    columns: [
      {
        title: "商品描述",
        dataIndex: "product_describe",
        valueType: "html",
        width: "xl",
      },
    ],
  },
  {
    valueType: "group",
    columns: [
      {
        title: "商品详情轮播图",
        dataIndex: "covers",
        valueType: "upload",
        width: "md",
        fieldProps: {
          listType: "picture-card",
          max: 3,
          directory: "product",
        },
      },
    ],
  },
];
```

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

感谢您提出的问题，以下是一个完整的自定义valueType的例子：

```tsx
import React, { FC, useEffect, useState } from "react";
import {
  ProConfigProvider,
  ProFieldFCRenderProps,
  ProRenderFieldPropsType,
  ProFormUploadButton,
  ProForm,
} from "@ant-design/pro-utils";
import { message, UploadFile } from "antd";
import qiniu from "qiniu-js";
import { v4 as uuid } from "uuid";
import { formatDate } from "@/utils/utils";
import { useModel } from "@/models";
import { UPLOAD_TOKEN } from "@/services";

/**
 * 自定义 valueMap
 */
const valueTypeMap: Record<string, ProRenderFieldPropsType> = {
  html: {
    renderFormItem(text, props) {
      return <ProFormHtml value={text} {...props} />;
    },
  },
  upload: {
    renderFormItem: (text, props) => {
      return <ProFormUpload value={text} {...props} />;
    },
  },
};

/**
 * 初始化 qiniu
 */
const initQiniu = async (setInitialState: Function) => {
  const { data } = await UPLOAD_TOKEN();
  localStorage.setItem("qiniu", JSON.stringify(data));
  setInitialState((s) => ({ ...s, qiniu: data }));
};

/**
 * 自定义 Html 组件
 */
export const ProFormHtml: FC<ProFieldFCRenderProps> = (props) => {
  return (
    <ProForm.Item>
      <WangeEitor {...props.fieldProps} />
    </ProForm.Item>
  );
};

/**
 * 自定义 Upload 组件
 */
export const ProFormUpload: FC<ProFieldFCRenderProps> = (props) => {
  const { value } = props;
  const { initialState, setInitialState } = useModel("@@initialState");

  const [fileList, setFileList] = useState<Record<string, UploadFile[]>>({});

  useEffect(() => {
    if (!initialState?.qiniu) {
      initQiniu(setInitialState);
    }
  }, []);

  useEffect(() => {
    if (Object.keys(fileList).length !== 0) {
      props.fieldProps.onChange?.(fileList[props.fieldProps.id]);
    }
  }, [fileList]);

  useEffect(() => {
    const item: any = {};
    if (!value) {
      item[props.fieldProps.id] = [];
    } else {
      if (Array.isArray(value) && value.length !== 0) {
        item[props.fieldProps.id] = value;
      } else if (typeof value === "string") {
        item[props.fieldProps.id] = [
          {
            uid: uuid(),
            name: value.split("/").at(-1) || "",
            status: "done",
            url: value,
          },
        ];
      } else {
        // PS:不出意外的话上传会走到这里,但是下边已经处理了所以这里不做处理
      }
    }
    setFileList((pre: any) => ({ ...pre, ...item }));
  }, [value]);

  /**
   * 生成文件名（此处逻辑根据实际需求自行修改）
   */
  const fileName = (file: File) => {
    const suffix = uuid();
    const curr = formatDate(new Date(), "YYYYMMDD");
    const fileName = file.name || "";
    const exp = fileName.split(".");
    const ext = exp.length >= 2 ? exp.at(-1) : "";
    return encodeURI(
      `${props.fieldProps.directory || "default"}/${curr}/${suffix}.${ext}`,
    );
  };

  /**
   * 自定义上传方法
   */
  const customRequest = async ({ file, onSuccess }: UploadRequestOption) => {
    const observable = qiniu.upload(
      file as File,
      fileName(file as File),
      initialState?.qiniu?.token || "",
    );
    observable.subscribe({
      next: ({ total }) => {
        message.loading({
          content: `开始上传文件\n进度：${parseInt(String(total.percent))}%`,
          key: "qiniu",
        });
      },
      error: (err) => {
        message.error({ content: err.message, key: "qiniu" });
      },
      complete: (res) => {
        onSuccess!(res);
        const tmp: Record<string, UploadFile<any>[]> = {};
        if (!fileList[props.fieldProps.id]) {
          tmp[props.fieldProps.id] = [
            {
              uid: uuid(),
              name: (file as File).name,
              status: "done",
              url: `${initialState?.qiniu?.cdn_url}/${res.key}`,
            },
          ];
        } else {
          tmp[props.fieldProps.id] = [
            ...fileList[props.fieldProps.id],
            {
              uid: uuid(),
              name: (file as File).name,
              status: "done",
              url: `${initialState?.qiniu?.cdn_url}/${res.key}`,
            },
          ];
        }
        setFileList((prev: any) => ({ ...prev, ...tmp }));
        message.success({ content: `文件上成功`, key: "qiniu" });
      },
    });
  };

  const onRemove = (file: UploadFile) => {
    const item: any = {};
    item[props.fieldProps.id] = fileList[props.fieldProps.id].filter(
      (f: any) => f.uid !== file.uid,
    );
    setFileList((pre: any) => ({ ...pre, ...item }));
  };

  return (
    <ProFormUploadButton
      {...props?.fieldProps}
      fileList={fileList[props.fieldProps.id] || []}
      fieldProps={{
        customRequest,
        onRemove,
        progress: {
          strokeColor: {
            "0%": "#108ee9",
            "100%": "#87d068",
          },
          strokeWidth: 3,
          format: (percent) => percent && `${parseFloat(percent.toFixed(2))}%`,
        },
      }}
    />
  );
};

const App = () => {
  return (
    <>
      <ProConfigProvider valueTypeMap={valueTypeMap}>
        {/* 此处为表格/表单等组件 */}
      </ProConfigProvider>
    </>
  );
};
```

需要注意的是，对于上传组件，需要自行引入`qiniu-js`和`uuid`。此外，自定义组件需要提供的参数可以根据实际需求自行调整。
