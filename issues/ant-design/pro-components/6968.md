# EditableProTable通过ProFormCheckbox控制行，每新增一行页面焦点会直接定位到表单第一个输入框🧐[问题]

`AI Reply`

提问前先看看：

https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md

### 🧐 问题描述

ProForm嵌套EditableProTable，通过ProFormCheckbox控制EditableProTable的行，每新增一行页面焦点会直接定位到表单第一个输入框，且同页面的两个ProFormCheckbox会闪动

<!--
详细地描述问题，让大家都能理解
-->

### 💻 示例代码

import React, { useEffect, useRef, useState } from 'react';
import { message } from 'antd';
import { history } from 'umi';
import {
ProForm,
ProFormText,
ProFormSelect,
PageContainer,
ProCard,
ProFormDependency,
ProFormDateRangePicker,
ProFormCheckbox,
ProFormDatePicker,
EditableProTable,
FooterToolbar,
} from '@ant-design/pro-components';
import type { ProFormInstance, ProColumns, EditableFormInstance } from '@ant-design/pro-components';
import { defaultStatusEnum, paperSpecsEnum } from '@/enumerate';
import {
getExaminationDetailById,
addExamination,
updateExamination,
} from '@/services/systemConfig';
import { areaList } from '@/services/api';
import { IntegerRegExp } from '@/utils/regExp';

const Index: React.FC = ({}) => {
// 页面类型
const { pathname, query } = history.location;
const pageType = pathname.split('/').slice(-1)[0];
const { id } = query as any;
const props: API.ProFieldProps = {
readonly: pageType === 'detail',
colProps: { md: 12, xl: 12 },
labelAlign: 'left',
labelCol: { span: 5 },
wrapperCol: { span: 17 },
};
const formRef = useRef<ProFormInstance>();
const editorFormRef = useRef<EditableFormInstance<API.SubjectsItem>>();
const [editableKeys, setEditableRowKeys] = useState<React.Key[]>([]);

const onSubmit = async (values: API.ExaminationParams) => {
await formRef.current?.validateFieldsReturnFormatValue?.();
console.log('校验表单并返回格式化后的所有数据：', values);
let res;
if (!id) {
res = await addExamination({ ...values });
} else {
res = await updateExamination({ ...values, id });
}
// 请求成功
if (res) {
message.success(id ? '编辑成功' : '添加成功');
history.push('/systemConfig/examManage');
}
};

const columns: ProColumns<API.SubjectsItem>[] = [
{
title: '科目',
dataIndex: 'subjectName',
readonly: true,
width: 60,
},
{
title: '考试时间',
dataIndex: 'examTime',
valueType: 'dateTime',
fieldProps: {
format: 'YYYY-MM-DD HH:mm',
minuteStep: 30,
},
formItemProps: {
rules: [
{
required: true,
message: '此项是必填项',
},
],
},
},
{
title: '配送时间',
dataIndex: 'deliveryTime',
valueType: 'dateTime',
// valueType: 'dateTimeRange',
fieldProps: {
format: 'YYYY-MM-DD HH:mm',
minuteStep: 30,
transform: (value: any) => {
console.log(value);
return {};
},
},
formItemProps: {
rules: [
{
required: true,
message: '此项是必填项',
},
],
},
},
{
title: '拣货日',
dataIndex: 'pickTime',
valueType: 'date',
formItemProps: {
rules: [
{
required: true,
message: '此项是必填项',
},
],
},
},
{
title: '晚发拣货日',
dataIndex: 'lateHairPickTime',
valueType: 'date',
formItemProps: {
rules: [
{
required: true,
message: '此项是必填项',
},
],
},
},
{
title: '30份/袋/卡克重',
dataIndex: 'cardThirtyWeight',
width: 100,
formItemProps: {
rules: [
// {
// required: true,
// message: '此项是必填项',
// },
{ pattern: IntegerRegExp },
],
},
},
{
title: '30份/袋/纸克重',
dataIndex: 'paperThirtyWeight',
width: 100,
formItemProps: {
rules: [
// {
// required: true,
// message: '此项是必填项',
// },
{ pattern: IntegerRegExp },
],
},
},
{
title: '10份/袋/卡克重',
dataIndex: 'cardTenWeight',
width: 100,
formItemProps: {
rules: [
// {
// required: true,
// message: '此项是必填项',
// },
{ pattern: IntegerRegExp },
],
},
},
{
title: '10份/袋/纸克重',
dataIndex: 'paperTenWeight',
width: 100,
formItemProps: {
rules: [
// {
// required: true,
// message: '此项是必填项',
// },
{ pattern: IntegerRegExp },
],
},
},
];

const init = async () => {
const res = await getExaminationDetailById({ id });
const subject: any = res?.subjectsList?.map((item) => item.subjectId);
formRef.current?.setFieldsValue({
...res,
examinationTime: [res?.examinationStartTime, res?.examinationEndTime],
reserveTime: [res?.reserveStartTime, res?.reserveEndTime],
subject,
cityCode: res.cityCode?.split(','),
});
if (pageType === 'edit') {
setEditableRowKeys([...subject]);
}
};

useEffect(() => {
if (id) {
init();
}
// eslint-disable-next-line react-hooks/exhaustive-deps
}, [id]);

return (
<PageContainer>
<ProCard>
<ProForm
autoFocusFirstInput
grid
initialValues={{ status: 1 }}
formRef={formRef}
layout="horizontal"
onFinish={onSubmit}
submitter={{
            render: (_, dom) =>
              pageType !== 'detail' && (
                <FooterToolbar className="footer-box-space">{dom}</FooterToolbar>
              ),
          }} >
<ProForm.Group>
<ProFormText
{...props}
colProps={{ md: 21, xl: 21 }}
labelCol={{ span: 3 }}
wrapperCol={{ span: 20 }}
name="examinationName"
label="考试名称"
fieldProps={{
                maxLength: 40,
              }}
rules={[{ required: true }]}
addonAfter={
<div style={{ width: 600, color: 'red' }}> \*不同地区科目不一致，算2次考试，需录入2次；考试名称可根据建议套用之前配置数据；
</div>
}
/>
</ProForm.Group>
<ProFormDateRangePicker
{...props}
name="examinationTime"
label="考试时间"
fieldProps={{}}
transform={(values) => {
const [v1, v2] = values;
return {
examinationStartTime: v1,
examinationEndTime: v2,
};
}}
rules={[{ required: true }]}
/>
<ProFormDateRangePicker
{...props}
name="reserveTime"
label="预定时间"
fieldProps={{}}
convertValue={(value) => value}
transform={(values) => {
const [v1, v2] = values;
return {
reserveEndTime: v1,
reserveStartTime: v2,
};
}}
rules={[{ required: true }]}
/>
<ProFormDatePicker
{...props}
labelCol={{ span: 7 }}
wrapperCol={{ span: 15 }}
name="valetOrderLastTime"
label="代客下单最晚预订日"
fieldProps={{}}
rules={[{ required: true }]}
/>

          <ProFormCheckbox.Group
            {...props}
            colProps={{ md: 24, xl: 24 }}
            labelCol={{ span: 2 }}
            wrapperCol={{ span: 21 }}
            name="cityCode"
            label="考试区域"
            fieldProps={{}}
            request={async () => {
              const res = await areaList();
              return res;
            }}
            rules={[{ required: true }]}
          />
          <ProFormCheckbox.Group
            {...props}
            name="testPaperType"
            label="试卷规格"
            options={paperSpecsEnum.options}
            fieldProps={{}}
            rules={[{ required: true }]}
          />
          <ProFormDatePicker
            {...props}
            name="barCodeLastTime"
            label="条码收集截止日"
            fieldProps={{}}
            rules={[{ required: true }]}
          />
          <ProForm.Group title="定价">
            <ProFormText
              {...props}
              wrapperCol={{ span: 10 }}
              name="cardFixedPrice"
              label="答题卡码洋"
              fieldProps={{}}
              rules={[{ required: true }, { pattern: IntegerRegExp }]}
            />
            <ProFormText
              {...props}
              wrapperCol={{ span: 10 }}
              name="paperFixedPrice"
              label="答题纸码洋"
              fieldProps={{}}
              rules={[{ required: true }, { pattern: IntegerRegExp }]}
            />
            <ProFormText
              {...props}
              wrapperCol={{ span: 10 }}
              name="cardActualPayment"
              label="答题卡实洋"
              fieldProps={{}}
              rules={[{ required: true }, { pattern: IntegerRegExp }]}
            />
            <ProFormText
              {...props}
              wrapperCol={{ span: 10 }}
              name="paperActualPayment"
              label="答题纸实洋"
              fieldProps={{}}
              rules={[{ required: true }, { pattern: IntegerRegExp }]}
            />
          </ProForm.Group>

          <ProFormCheckbox.Group
            {...props}
            colProps={{ md: 20, xl: 20 }}
            labelCol={{ span: 3 }}
            wrapperCol={{ span: 17 }}
            name="subject"
            label="科目"
            options={[

{ value: 1, label: '语文' },
{ value: 2, label: '理综' },
{ value: 3, label: '物理' },
{ value: 4, label: '化学' },
{ value: 5, label: '数学' },
{ value: 6, label: '道法' },
{ value: 7, label: '英语' },
{ value: 8, label: '地理' },
{ value: 9, label: '生物' },
]}
fieldProps={{
              onChange: (value: any) => {
                console.log(value);
                formRef.current?.setFieldValue(
                  'subjectsList',
                  value?.map((_: any) => {
                    return {
                      subjectId: _,
                      subjectName: subjectTypeEnum.enums[_],
                      // cardTenWeight: '',
                      // cardThirtyWeight: '',
                      // deliveryTime: undefined,
                      // examTime: undefined,
                      // lateHairPickTime: undefined,
                      // paperTenWeight: '',
                      // paperThirtyWeight: '',
                      // pickTime: undefined,
                    };
                  }),
                );
                setEditableRowKeys([...value]);
              },
            }}
rules={[{ required: false }]}
/>
<ProFormDependency name={['subject']}>
{({ subject }) => {
return (
subject?.length && (
<ProForm.Item name="subjectsList" trigger="onValuesChange">
<EditableProTable<API.SubjectsItem>
editableFormRef={editorFormRef}
columns={columns.map((item) => ({ ...item, align: 'center' }))}
rowKey="subjectId"
recordCreatorProps={false}
editable={{
                        type: 'multiple',
                        editableKeys,
                        onChange: setEditableRowKeys,
                        onValuesChange: (record, recordList) => {
                          console.log(record, recordList);
                        },
                      }}
/>
</ProForm.Item>
)
);
}}
</ProFormDependency>
<ProForm.Group title="状态">
<ProFormSelect
{...props}
name="status"
fieldProps={{
                allowClear: false,
              }}
options={defaultStatusEnum.options}
rules={[{ required: true }]}
/>
</ProForm.Group>
</ProForm>
</ProCard>
</PageContainer>
);
};

export default Index;

<!--
如果你有解决方案，在这里清晰地阐述
-->

### 🚑 其他信息

<!--
如截图等其他信息可以贴在这里
-->

## yangyan123

版本号![image](https://user-images.githubusercontent.com/10812007/233846594-127e5a76-7f5f-4d3b-b64b-d63dac93577e.png)

## chenshuai2144

1.0 已经不维护了。

> 每新增一行页面焦点会直接定位到表单第一个输入框

当您新增一行页面时，焦点会直接定位到表单的第一个输入框。这个问题可能是由于组件在重新销毁过程中导致的。重新销毁组件意味着该组件被移除或销毁，并随后重新创建一个新的实例。在重新创建组件时，焦点自动定位到了表单的第一个输入框。

为了解决这个问题，您可以考虑以下步骤：

检查组件的生命周期，特别关注在新增一行页面时的处理过程。确保组件被正确销毁并重新创建。

检查相关的代码和事件处理程序，查看是否存在明确的逻辑导致焦点定位在表单的第一个输入框上。可能涉及事件绑定、聚焦方法或其他与焦点相关的代码。

检查组件的配置选项和属性，看是否存在可以控制焦点定位行为的设置。可能会有相关的选项可以进行调整或配置。

如果有可能，与其他开发人员或团队成员进行沟通和协作，了解是否有其他人遇到类似的问题，或者是否存在关于该组件的已知问题和解决方案。

通过仔细检查代码和组件的配置，您应该能够找到导致焦点定位在表单第一个输入框的原因，并采取相应的措施解决该问题。
