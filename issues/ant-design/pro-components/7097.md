# 🐛[BUG]使用ProFormDependency渲染组件，没有清除原数据

`AI Reply`

### 🐛 bug 描述

使用ProFormDependency渲染组件，上一次提交的数据没有完全被清除

### 🏞 期望结果

点击确定拿到的数据只有本次渲染出来的组件的值

### 💻 复现代码

    <DrawerForm
      drawerProps={{
        onClose: onCancel,
        destroyOnClose: true,
        getContainer: false,
      }}
      onFinish={async (fields) => {
        onSubmit(fields);
      }}
    >
      <ProFormList
        name="header"
        alwaysShowItemLabel
        creatorButtonProps={false}
        actionRender={() => {
          return [];
        }}
        initialValue={headerType}
      >
        <ProForm.Group key="group">
          <ProFormRadio.Group name="type" label="表头内容" options={dictEcho('markerHead')} />
          <ProFormTextArea
            width={250}
            name="text"
            label="表头名"
            disabled
            fieldProps={{
              autoSize: { minRows: 1, maxRows: 10 },
            }}
          />
          <ProFormDependency name={['type']}>
            {({ type }) => {
              switch (type) {
                case 'compound':
                  return null;
                case 'ri':
                  return (
                    <ProForm.Group>
                      <ProFormSelect
                        name="riColumn"
                        label="RI柱"
                        rules={[{ required: true }]}
                        options={dictEcho('riColumn')}
                      />
                      <ProFormSelect
                        name="riSource"
                        label="RI来源"
                        rules={[{ required: true }]}
                        options={dictEcho('riSource')}
                      />
                    </ProForm.Group>
                  );
              }
              return null;
            }}
          </ProFormDependency>
        </ProForm.Group>
      </ProFormList>
    </DrawerForm>

### © 版本信息

- ProComponents 版本: 2.3.57
- umi 版本 4.0.59
- 浏览器环境 google
- 开发环境 windows 10

### 🚑 其他信息

选择RI时才需要选择 RI柱 和 RI来源
![image](https://github.com/ant-design/pro-components/assets/110799511/00ee6b9e-f828-4e09-99e3-c78666f2aae7)

第一次选择RI
![image](https://github.com/ant-design/pro-components/assets/110799511/81b4b7c1-e286-412a-a795-7b2dfa1fd462)

第二次改为 香气描述，点击确定提交的数据中依然包含 RI柱 和 RI来源
![image](https://github.com/ant-design/pro-components/assets/110799511/cf572777-0f7b-4f3f-b297-9b2d5a5a1226)

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

你好！根据您的描述，问题可能出现在ProFormDependency的使用上。ProFormDependency用于根据依赖项的变化动态渲染表单项，但在您的代码中没有使用依赖项的字段值来控制是否渲染RI柱和RI来源的表单项。

为了解决这个问题，您可以使用ProFormDependency的prop `shouldUpdate` 来手动控制是否渲染依赖的表单项。您可以根据type字段的值来判断是否应该渲染RI柱和RI来源的表单项。

以下是修改后的代码示例：

```jsx
<ProFormDependency
  name={["type"]}
  shouldUpdate={(prevValues, curValues) => prevValues.type !== curValues.type}
>
  {({ type }) => {
    if (type === "ri") {
      return (
        <ProForm.Group>
          <ProFormSelect
            name="riColumn"
            label="RI柱"
            rules={[{ required: true }]}
            options={dictEcho("riColumn")}
          />
          <ProFormSelect
            name="riSource"
            label="RI来源"
            rules={[{ required: true }]}
            options={dictEcho("riSource")}
          />
        </ProForm.Group>
      );
    }
    return null;
  }}
</ProFormDependency>
```

这里通过传递一个 `shouldUpdate` 的函数，来决定是否更新依赖的表单项。在该函数中，我们比较了前后两次的type字段值，只有当它们不一样时才会重新渲染依赖的表单项。

这种方式可以确保每次渲染时清除先前提交的数据。

您可以尝试使用此代码并检查是否解决了您的问题。如果您需要更多帮助，请查阅[ProFormDependency的文档](https://procomponents.ant.design/components/form?#proformdependency)以获取更多信息。

## Eileen-v

> > TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> > 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。
>
> 你好！根据您的描述，问题可能出现在ProFormDependency的使用上。ProFormDependency用于根据依赖项的变化动态渲染表单项，但在您的代码中没有使用依赖项的字段值来控制是否渲染RI柱和RI来源的表单项。
>
> 为了解决这个问题，您可以使用ProFormDependency的prop `shouldUpdate` 来手动控制是否渲染依赖的表单项。您可以根据type字段的值来判断是否应该渲染RI柱和RI来源的表单项。
>
> 以下是修改后的代码示例：
>
> ```js
> <ProFormDependency
>   name={["type"]}
>   shouldUpdate={(prevValues, curValues) => prevValues.type !== curValues.type}
> >
>   {({ type }) => {
>     if (type === "ri") {
>       return (
>         <ProForm.Group>
>           <ProFormSelect
>             name="riColumn"
>             label="RI柱"
>             rules={[{ required: true }]}
>             options={dictEcho("riColumn")}
>           />
>           <ProFormSelect
>             name="riSource"
>             label="RI来源"
>             rules={[{ required: true }]}
>             options={dictEcho("riSource")}
>           />
>         </ProForm.Group>
>       );
>     }
>     return null;
>   }}
> </ProFormDependency>
> ```
>
> 这里通过传递一个 `shouldUpdate` 的函数，来决定是否更新依赖的表单项。在该函数中，我们比较了前后两次的type字段值，只有当它们不一样时才会重新渲染依赖的表单项。
>
> 这种方式可以确保每次渲染时清除先前提交的数据。
>
> 您可以尝试使用此代码并检查是否解决了您的问题。如果您需要更多帮助，请查阅[ProFormDependency的文档](https://procomponents.ant.design/components/form?#proformdependency)以获取更多信息。

你好，尝试了一下上面的方案，结果不可行
![image](https://github.com/ant-design/pro-components/assets/110799511/d5ef2089-c75b-4c8b-ace2-aa232fb6f1e4)
![image](https://github.com/ant-design/pro-components/assets/110799511/58b37e75-8114-45ec-b11f-e09720f2dc5e)
![image](https://github.com/ant-design/pro-components/assets/110799511/e938bf3b-6988-4cea-90e4-a6e81212b2d0)

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

非常抱歉，之前的解决方案没有解决您的问题。根据您的描述和截图，似乎确实出现了数据未完全清除的问题。

在这种情况下，您可以尝试通过手动重置表单字段的方式来解决。您可以使用`form.resetFields()`方法来清除表单中的所有字段。

以下是修改后的代码示例：

```jsx
import { useRef } from "react";
import { Form, Drawer, Button, Select } from "antd";

const { Option } = Select;

const MyForm = () => {
  const formRef = useRef();

  const onSubmit = (fields) => {
    console.log(fields);
  };

  const onCancel = () => {
    formRef.current.resetFields(); // 重置表单字段
  };

  return (
    <Form ref={formRef} onFinish={onSubmit}>
      <Form.Item name="type" label="类型">
        <Select>
          <Option value="compound">复合</Option>
          <Option value="ri">RI</Option>
        </Select>
      </Form.Item>

      <Form.Item
        noStyle
        shouldUpdate={(prevValues, curValues) =>
          prevValues.type !== curValues.type
        }
      >
        {({ getFieldValue }) => {
          const type = getFieldValue("type");
          if (type === "ri") {
            return (
              <>
                <Form.Item name="riColumn" label="RI柱">
                  <Select>
                    <Option value="column1">柱1</Option>
                    <Option value="column2">柱2</Option>
                  </Select>
                </Form.Item>
                <Form.Item name="riSource" label="RI来源">
                  <Select>
                    <Option value="source1">来源1</Option>
                    <Option value="source2">来源2</Option>
                  </Select>
                </Form.Item>
              </>
            );
          }
          return null;
        }}
      </Form.Item>

      <Form.Item>
        <Button type="primary" htmlType="submit">
          确定
        </Button>
        <Button onClick={onCancel}>取消</Button>
      </Form.Item>
    </Form>
  );
};

const MyDrawer = () => {
  return (
    <Drawer visible width={500}>
      <MyForm />
    </Drawer>
  );
};

export default MyDrawer;
```

在修改后的代码中，我们使用了`useRef`来创建一个表单引用`formRef`，然后在取消按钮点击时，调用`formRef.current.resetFields()`来重置表单字段。

请尝试使用这个修改后的代码，并检查是否解决了数据残留的问题。如果您还有任何疑问，请随时提问。

## Eileen-v

> > TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> > 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。
>
> 非常抱歉，之前的解决方案没有解决您的问题。根据您的描述和截图，似乎确实出现了数据未完全清除的问题。
>
> 在这种情况下，您可以尝试通过手动重置表单字段的方式来解决。您可以使用`form.resetFields()`方法来清除表单中的所有字段。
>
> 以下是修改后的代码示例：
>
> ```js
> import { useRef } from "react";
> import { Form, Drawer, Button, Select } from "antd";
>
> const { Option } = Select;
>
> const MyForm = () => {
>   const formRef = useRef();
>
>   const onSubmit = (fields) => {
>     console.log(fields);
>   };
>
>   const onCancel = () => {
>     formRef.current.resetFields(); // 重置表单字段
>   };
>
>   return (
>     <Form ref={formRef} onFinish={onSubmit}>
>       <Form.Item name="type" label="类型">
>         <Select>
>           <Option value="compound">复合</Option>
>           <Option value="ri">RI</Option>
>         </Select>
>       </Form.Item>
>
>       <Form.Item
>         noStyle
>         shouldUpdate={(prevValues, curValues) =>
>           prevValues.type !== curValues.type
>         }
>       >
>         {({ getFieldValue }) => {
>           const type = getFieldValue("type");
>           if (type === "ri") {
>             return (
>               <>
>                 <Form.Item name="riColumn" label="RI柱">
>                   <Select>
>                     <Option value="column1">柱1</Option>
>                     <Option value="column2">柱2</Option>
>                   </Select>
>                 </Form.Item>
>                 <Form.Item name="riSource" label="RI来源">
>                   <Select>
>                     <Option value="source1">来源1</Option>
>                     <Option value="source2">来源2</Option>
>                   </Select>
>                 </Form.Item>
>               </>
>             );
>           }
>           return null;
>         }}
>       </Form.Item>
>
>       <Form.Item>
>         <Button type="primary" htmlType="submit">
>           确定
>         </Button>
>         <Button onClick={onCancel}>取消</Button>
>       </Form.Item>
>     </Form>
>   );
> };
>
> const MyDrawer = () => {
>   return (
>     <Drawer visible width={500}>
>       <MyForm />
>     </Drawer>
>   );
> };
>
> export default MyDrawer;
> ```
>
> 在修改后的代码中，我们使用了`useRef`来创建一个表单引用`formRef`，然后在取消按钮点击时，调用`formRef.current.resetFields()`来重置表单字段。
>
> 请尝试使用这个修改后的代码，并检查是否解决了数据残留的问题。如果您还有任何疑问，请随时提问。

感谢您的回复~
我之前尝试过给DrawerForm和ProFormList添加formRef属性，点击取消的时候，用resetFields()清空，但是失败了。
用上述您提供的组件，会对页面结构和样式产生较大影响，请问有没有能够在我原有组件基础上，实现清空原数据的方法呢？

## chenshuai2144

| preserve | 当字段被删除时保留字段值 | boolean | true | 4.4. |
| -------- | ------------------------ | ------- | ---- | ---- |

试试是不是因为这个

## Eileen-v

>

> preserve 当字段被删除时保留字段值 boolean true 4.4.
> 试试是不是因为这个

试过了，设置为false之后，原数据确实被清空了，非常感谢🙇‍~
