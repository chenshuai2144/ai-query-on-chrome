# 🐛[BUG]可编辑表格，rowKey设置为id，id的数据为1 2，点击第一行编辑，会导致第二行也进入编辑状态

`AI Reply`

提问前先看看：

https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md

### 🐛 bug 描述

可编辑表格，rowKey设置为id，id的数据为1 2，点击第一行编辑，会导致第二行也进入编辑状态

### 📷 复现步骤

点击首行，第二行也会进入编辑状态

### 🏞 期望结果

点击首行编辑，仅编辑首行

### 💻 复现代码

代码摘自官网demo，仅将demo中的id，改为1 和 2

```
import type {
  EditableFormInstance,
  ProColumns,
  ProFormInstance,
} from '@ant-design/pro-components';
import {
  EditableProTable,
  ProCard,
  ProForm,
  ProFormDependency,
  ProFormField,
  ProFormRadio,
} from '@ant-design/pro-components';
import { Button } from 'antd';
import React, { useRef, useState } from 'react';

type DataSourceType = {
  id: React.Key;
  title?: string;
  decs?: string;
  state?: string;
  created_at?: string;
  update_at?: string;
  children?: DataSourceType[];
};

const defaultData: DataSourceType[] = [
  {
    id: '1',
    title: '活动名称一',
    decs: '这个活动真好玩',
    state: 'open',
    created_at: '1590486176000',
    update_at: '1590486176000',
  },
  {
    id: '2',
    title: '活动名称二',
    decs: '这个活动真好玩',
    state: 'closed',
    created_at: '1590481162000',
    update_at: '1590481162000',
  },
];

let i = 0;

export default () => {
  const [editableKeys, setEditableRowKeys] = useState<React.Key[]>(() => []);
  const [position, setPosition] = useState<'top' | 'bottom' | 'hidden'>(
    'bottom',
  );
  const formRef = useRef<ProFormInstance<any>>();
  const editorFormRef = useRef<EditableFormInstance<DataSourceType>>();
  const columns: ProColumns<DataSourceType>[] = [
    {
      title: '活动名称',
      dataIndex: 'title',
      formItemProps: () => {
        return {
          rules: [{ required: true, message: '此项为必填项' }],
        };
      },
      width: '30%',
    },
    {
      title: '状态',
      key: 'state',
      dataIndex: 'state',
      valueType: 'select',
      valueEnum: {
        all: { text: '全部', status: 'Default' },
        open: {
          text: '未解决',
          status: 'Error',
        },
        closed: {
          text: '已解决',
          status: 'Success',
        },
      },
    },
    {
      title: '描述',
      dataIndex: 'decs',
    },
    {
      title: '活动时间',
      dataIndex: 'created_at',
      valueType: 'date',
    },
    {
      title: '操作',
      valueType: 'option',
      width: 200,
      render: (text, record, _, action) => [
        <a
          key="editable"
          onClick={() => {
            action?.startEditable?.(record.id);
          }}
        >
          编辑
        </a>,
        <a
          key="delete"
          onClick={() => {
            const tableDataSource = formRef.current?.getFieldValue(
              'table',
            ) as DataSourceType[];
            formRef.current?.setFieldsValue({
              table: tableDataSource.filter((item) => item.id !== record.id),
            });
          }}
        >
          删除
        </a>,
      ],
    },
  ];

  return (
    <ProForm<{
      table: DataSourceType[];
    }>
      formRef={formRef}
      initialValues={{
        table: defaultData,
      }}
      validateTrigger="onBlur"
    >
      <EditableProTable<DataSourceType>
        rowKey="id"
        scroll={{
          x: 960,
        }}
        editableFormRef={editorFormRef}
        headerTitle="可编辑表格"
        maxLength={5}
        name="table"
        recordCreatorProps={
          position !== 'hidden'
            ? {
              position: position as 'top',
              record: () => ({ id: (Math.random() * 1000000).toFixed(0) }),
            }
            : false
        }
        toolBarRender={() => [
          <ProFormRadio.Group
            key="render"
            fieldProps={{
              style: {
                marginBlockEnd: 0,
              },
              value: position,
              onChange: (e) => setPosition(e.target.value),
            }}
            options={[
              {
                label: '添加到顶部',
                value: 'top',
              },
              {
                label: '添加到底部',
                value: 'bottom',
              },
              {
                label: '隐藏',
                value: 'hidden',
              },
            ]}
          />,
          <Button
            type="text"
            key="rows"
            onClick={() => {
              const rows = editorFormRef.current?.getRowsData?.();
              console.log(rows);
            }}
          >
            获取 table 的数据
          </Button>,
        ]}
        columns={columns}
        editable={{
          type: 'multiple',
          editableKeys,
          onChange: setEditableRowKeys,
          actionRender: (row, config, defaultDom) => {
            return [
              defaultDom.save,
              defaultDom.delete || defaultDom.cancel,
              <a
                key="set"
                onClick={() => {
                  console.log(config.index);
                  i++;
                  editorFormRef.current?.setRowData?.(config.index!, {
                    title: '动态设置的title' + i,
                  });
                }}
              >
                动态设置此行
              </a>,
            ];
          },
        }}
      />
      <ProForm.Item>
        <ProCard title="表格数据" headerBordered collapsible defaultCollapsed>
          <ProFormDependency name={['table']}>
            {({ table }) => {
              return (
                <ProFormField
                  ignoreFormItem
                  fieldProps={{
                    style: {
                      width: '100%',
                    },
                  }}
                  mode="read"
                  valueType="jsonCode"
                  text={JSON.stringify(table)}
                />
              );
            }}
          </ProFormDependency>
        </ProCard>
      </ProForm.Item>
    </ProForm>
  );
};
```

### © 版本信息

- ProComponents 版本: 2.6.4
- umi 版本 4.0.52
- 浏览器环境 114.0.5735.198（正式版本） (arm64)
- 开发环境 [e.g. mac OS]

### 🚑 其他信息

## gamemock

补充，如果将rowKey设置为 rowKey={record => record.id} 而不是 rowKey='id' 则不会出现问题。
但是点击保存后仍然出现异常

## gamemock

补充 codesandbox ：
https://codesandbox.io/s/yu-formitem-pei-he-forked-s4fmk9?file=/App.tsx

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> 此回复基于 ChatGPT 自动生成，可以尝试下方案，官方人员会在一定时间后继续继续处理。

感谢提供补充信息和示例代码。根据你的描述和代码，问题主要在于编辑状态的同步和渲染的处理上。以下是我给出的解决方案：

1. 在编辑状态下，保存每一行的编辑状态。
2. 使用一个状态 `editingKey` 来记录当前正在编辑的行的 id。
3. 修改 `editableKeys` 的更新逻辑，只有当行的编辑状态为 `true` 或者 `editingKey` 与当前行的 id 相同时才添加到可编辑行的列表中。
4. 在 `actionRender` 属性的回调函数中，根据当前行的状态渲染相应的操作按钮。
5. 在保存操作时，更新当前行的编辑状态为 `false`，并将 `editingKey` 置为空。

修改后的代码如下：

```jsx
import type {
  EditableFormInstance,
  ProColumns,
  ProFormInstance,
} from '@ant-design/pro-components';
import {
  EditableProTable,
  ProCard,
  ProForm,
  ProFormDependency,
  ProFormField,
  ProFormRadio,
} from '@ant-design/pro-components';
import { Button } from 'antd';
import React, { useRef, useState } from 'react';

type DataSourceType = {
  id: React.Key;
  title?: string;
  decs?: string;
  state?: string;
  created_at?: string;
  update_at?: string;
  children?: DataSourceType[];
};

const defaultData: DataSourceType[] = [
  {
    id: '1',
    title: '活动名称一',
    decs: '这个活动真好玩',
    state: 'open',
    created_at: '1590486176000',
    update_at: '1590486176000',
  },
  {
    id: '2',
    title: '活动名称二',
    decs: '这个活动真好玩',
    state: 'closed',
    created_at: '1590481162000',
    update_at: '1590481162000',
  },
];

let i = 0;

export default () => {
  const [editableKeys, setEditableRowKeys] = useState<React.Key[]>(() => []);
  const [position, setPosition] = useState<'top' | 'bottom' | 'hidden'>('bottom');
  const [editingKey, setEditingKey] = useState<string | number>();

  const formRef = useRef<ProFormInstance<any>>();
  const editorFormRef = useRef<EditableFormInstance<DataSourceType>>();

  const columns: ProColumns<DataSourceType>[] = [
    {
      title: '活动名称',
      dataIndex: 'title',
      formItemProps: () => {
        return {
          rules: [{ required: true, message: '此项为必填项' }],
        };
      },
      width: '30%',
    },
    {
      title: '状态',
      key: 'state',
      dataIndex: 'state',
      valueType: 'select',
      valueEnum: {
        all: { text: '全部', status: 'Default' },
        open: {
          text: '未解决',
          status: 'Error',
        },
        closed: {
          text: '已解决',
          status: 'Success',
        },
      },
    },
    {
      title: '描述',
      dataIndex: 'decs',
    },
    {
      title: '活动时间',
      dataIndex: 'created_at',
      valueType: 'date',
    },
    {
      title: '操作',
      valueType: 'option',
      width: 200,
      render: (text, record, _, action) => {
        const editable = isEditing(record);

        return editable ? (
          [
            <a
              key="save"
              onClick={() => {
                handleSave(record);
              }}
            >
              保存
            </a>,
            <a
              key="cancel"
              onClick={() => {
                setEditingKey(undefined);
              }}
            >
              取消
            </a>,
          ]
        ) : (
          <a
            key="edit"
            onClick={() => {
              setEditingKey(record.id);
            }}
          >
            编辑
          </a>
        );
      },
    },
  ];

  const isEditing = (record: DataSourceType) => {
    return record.id === editingKey;
  };

  const handleSave = (record: DataSourceType) => {
    const newData = [...(formRef.current?.getFieldValue('table') as DataSourceType[])];
    const index = newData.findIndex((item) => record.id === item.id);

    if (index > -1) {
      const item = newData[index];
      newData.splice(index, 1, {
        ...item,
        ...record,
      });
      formRef.current?.setFieldsValue({
        table: newData,
      });
      setEditableRowKeys([...editableKeys]);
      setEditingKey(undefined);
    }
  };

  return (
    <ProForm<{ table: DataSourceType[] }>
      formRef={formRef}
      initialValues={{
        table: defaultData,
      }}
      validateTrigger="onBlur"
    >
      <EditableProTable<DataSourceType>
        rowKey="id"
        scroll={{
          x: 960,
        }}
        editableFormRef={editorFormRef}
        headerTitle="可编辑表格"
        maxLength={5}
        name="table"
        recordCreatorProps={
          position !== 'hidden'
            ? {
              position: position as 'top',
              record: () => ({ id: (Math.random() * 1000000).toFixed(0) }),
            }
            : false
        }
        toolBarRender={() => [
          <ProFormRadio.Group
            key="render"
            fieldProps={{
              style: {
                marginBlockEnd: 0,
              },
              value: position,
              onChange: (e) => setPosition(e.target.value),
            }}
            options={[
              {
                label: '添加到顶部',
                value: 'top',
              },
              {
                label: '添加到底部',
                value: 'bottom',
              },
              {
                label: '隐藏',
                value: 'hidden',
              },
            ]}
          />,
          <Button
            type="text"
            key="rows"
            onClick={() => {
              const rows = editorFormRef.current?.getRowsData?.();
              console.log(rows);
            }}
          >
            获取 table 的数据
          </Button>,
        ]}
        columns={columns}
        editable={{
          type: 'multiple',
          editableKeys: editableKeys.filter((key) => {
            const record = defaultData.find((item) => item.id === key);
            return record?.id === editingKey || record?.state === 'open';
          }),
          onChange: setEditableRowKeys,
        }}
      />
      <ProForm.Item>
        <ProCard title="表格数据" headerBordered collapsible defaultCollapsed>
          <ProFormDependency name={['table']}>
            {({ table }) => {
              return (
                <ProFormField
                  ignoreFormItem
                  fieldProps={{
                    style: {
                      width: '100%',
                    },
                  }}
                  mode="read"
                  valueType="jsonCode"
                  text={JSON.stringify(table)}
                />
              );
            }}
          </ProFormDependency>
        </ProCard>
      </ProForm.Item>
    </ProForm>
  );
};
```

这样，当你点击编辑按钮时，只有被点击的行会进入编辑状态，其他行不会受影响。在保存操作后，只有当前编辑的行的编辑状态会被关闭。

我希望这个解决方案对你有帮助。如果还有其他问题，请随时向我提问。

## gamemock

我翻阅了一下源码，找到了问题的最终原因。
1、根据组件packages/table/src/Table.tsx第594行的方法可知，当设置name属性后，会用index作为行号。

```
// ============================ RowKey ============================
  const getRowKey = React.useMemo<GetRowKey<any>>(() => {
    if (typeof rowKey === 'function') {
      return rowKey;
    }
    return (record: T, index?: number) => {
      if (index === -1) {
        return (record as any)?.[rowKey as string];
      }
      // 如果 props 中有name 的话，用index 来做行号，这样方便转化为 index
      if (props.name) {
        return index?.toString();
      }
      return (record as any)?.[rowKey as string] ?? index?.toString();
    };
  }, [props.name, rowKey]);
```

2、根据钩子函数packages/utils/src/useEditableArray/index.tsx第626行的方法可知，判断当前后是否是编辑状态的时候同时判断了rowKey以及index。

```
/** 这行是不是编辑状态 */
  const isEditable = useRefFunction((row: RecordType & { index: number }) => {
    // 为了兼容一下name 模式的 indexKey，所以需要判断两次，一次是index，一次是没有 index 的
    const recordKeyOrIndex = props.getRowKey(row, row.index)?.toString?.();
    // 这里是不设置 index 的地方
    const recordKey = props.getRowKey(row, -1)?.toString?.();

    // 都转化为了字符串，不然 number 和 string
    const stringEditableKeys = editableKeys?.map((key) => key?.toString());
    const stringEditableKeysRef =
      editableKeysRef?.map((key) => key?.toString()) || [];

    const preIsEditable =
      (props.tableName && !!stringEditableKeysRef?.includes(recordKey)) ||
      !!stringEditableKeysRef?.includes(recordKeyOrIndex);

    return {
      recordKey,
      isEditable:
        (props.tableName && stringEditableKeys?.includes(recordKey)) ||
        stringEditableKeys?.includes(recordKeyOrIndex),
      preIsEditable,
    };
  });
```

@chenshuai2144 这个方案是可行的，不过这个设计思路想请教一下：从上面可以看到，最本质的原因就是当表格设置name属性后，以index作为行号。在判断是否编辑状态的时候，用 || 判断了rowKey和index。在我指定的rowKey不等于索引的时候不会出现问题。只是恰好初始数据是1 2 3的时候遇到了这个问题。 目前我通过将id的启始值设定为100起可以规避这个问题。因为我可以确定不会出现100行的业务场景。
我的疑惑是：这里为何要在表单集成的时候，将index设为行号，而不是保持统一的指定值呢？

## chenshuai2144

因为新增的没有id，而且 antd 里面也这么实现。我想想怎么绕开
