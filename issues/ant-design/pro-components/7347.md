# ğŸ›[BUG]å¯ç¼–è¾‘è¡¨æ ¼ï¼ŒrowKeyè®¾ç½®ä¸ºidï¼Œidçš„æ•°æ®ä¸º1 2ï¼Œç‚¹å‡»ç¬¬ä¸€è¡Œç¼–è¾‘ï¼Œä¼šå¯¼è‡´ç¬¬äºŒè¡Œä¹Ÿè¿›å…¥ç¼–è¾‘çŠ¶æ€

`AI Reply`

æé—®å‰å…ˆçœ‹çœ‹ï¼š

https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md

### ğŸ› bug æè¿°

å¯ç¼–è¾‘è¡¨æ ¼ï¼ŒrowKeyè®¾ç½®ä¸ºidï¼Œidçš„æ•°æ®ä¸º1 2ï¼Œç‚¹å‡»ç¬¬ä¸€è¡Œç¼–è¾‘ï¼Œä¼šå¯¼è‡´ç¬¬äºŒè¡Œä¹Ÿè¿›å…¥ç¼–è¾‘çŠ¶æ€

### ğŸ“· å¤ç°æ­¥éª¤

ç‚¹å‡»é¦–è¡Œï¼Œç¬¬äºŒè¡Œä¹Ÿä¼šè¿›å…¥ç¼–è¾‘çŠ¶æ€

### ğŸ æœŸæœ›ç»“æœ

ç‚¹å‡»é¦–è¡Œç¼–è¾‘ï¼Œä»…ç¼–è¾‘é¦–è¡Œ

### ğŸ’» å¤ç°ä»£ç 

ä»£ç æ‘˜è‡ªå®˜ç½‘demoï¼Œä»…å°†demoä¸­çš„idï¼Œæ”¹ä¸º1 å’Œ 2

```
import type {
  EditableFormInstance,
  ProColumns,
  ProFormInstance,
} from '@ant-design/pro-components';
import {
  EditableProTable,
  ProCard,
  ProForm,
  ProFormDependency,
  ProFormField,
  ProFormRadio,
} from '@ant-design/pro-components';
import { Button } from 'antd';
import React, { useRef, useState } from 'react';

type DataSourceType = {
  id: React.Key;
  title?: string;
  decs?: string;
  state?: string;
  created_at?: string;
  update_at?: string;
  children?: DataSourceType[];
};

const defaultData: DataSourceType[] = [
  {
    id: '1',
    title: 'æ´»åŠ¨åç§°ä¸€',
    decs: 'è¿™ä¸ªæ´»åŠ¨çœŸå¥½ç©',
    state: 'open',
    created_at: '1590486176000',
    update_at: '1590486176000',
  },
  {
    id: '2',
    title: 'æ´»åŠ¨åç§°äºŒ',
    decs: 'è¿™ä¸ªæ´»åŠ¨çœŸå¥½ç©',
    state: 'closed',
    created_at: '1590481162000',
    update_at: '1590481162000',
  },
];

let i = 0;

export default () => {
  const [editableKeys, setEditableRowKeys] = useState<React.Key[]>(() => []);
  const [position, setPosition] = useState<'top' | 'bottom' | 'hidden'>(
    'bottom',
  );
  const formRef = useRef<ProFormInstance<any>>();
  const editorFormRef = useRef<EditableFormInstance<DataSourceType>>();
  const columns: ProColumns<DataSourceType>[] = [
    {
      title: 'æ´»åŠ¨åç§°',
      dataIndex: 'title',
      formItemProps: () => {
        return {
          rules: [{ required: true, message: 'æ­¤é¡¹ä¸ºå¿…å¡«é¡¹' }],
        };
      },
      width: '30%',
    },
    {
      title: 'çŠ¶æ€',
      key: 'state',
      dataIndex: 'state',
      valueType: 'select',
      valueEnum: {
        all: { text: 'å…¨éƒ¨', status: 'Default' },
        open: {
          text: 'æœªè§£å†³',
          status: 'Error',
        },
        closed: {
          text: 'å·²è§£å†³',
          status: 'Success',
        },
      },
    },
    {
      title: 'æè¿°',
      dataIndex: 'decs',
    },
    {
      title: 'æ´»åŠ¨æ—¶é—´',
      dataIndex: 'created_at',
      valueType: 'date',
    },
    {
      title: 'æ“ä½œ',
      valueType: 'option',
      width: 200,
      render: (text, record, _, action) => [
        <a
          key="editable"
          onClick={() => {
            action?.startEditable?.(record.id);
          }}
        >
          ç¼–è¾‘
        </a>,
        <a
          key="delete"
          onClick={() => {
            const tableDataSource = formRef.current?.getFieldValue(
              'table',
            ) as DataSourceType[];
            formRef.current?.setFieldsValue({
              table: tableDataSource.filter((item) => item.id !== record.id),
            });
          }}
        >
          åˆ é™¤
        </a>,
      ],
    },
  ];

  return (
    <ProForm<{
      table: DataSourceType[];
    }>
      formRef={formRef}
      initialValues={{
        table: defaultData,
      }}
      validateTrigger="onBlur"
    >
      <EditableProTable<DataSourceType>
        rowKey="id"
        scroll={{
          x: 960,
        }}
        editableFormRef={editorFormRef}
        headerTitle="å¯ç¼–è¾‘è¡¨æ ¼"
        maxLength={5}
        name="table"
        recordCreatorProps={
          position !== 'hidden'
            ? {
              position: position as 'top',
              record: () => ({ id: (Math.random() * 1000000).toFixed(0) }),
            }
            : false
        }
        toolBarRender={() => [
          <ProFormRadio.Group
            key="render"
            fieldProps={{
              style: {
                marginBlockEnd: 0,
              },
              value: position,
              onChange: (e) => setPosition(e.target.value),
            }}
            options={[
              {
                label: 'æ·»åŠ åˆ°é¡¶éƒ¨',
                value: 'top',
              },
              {
                label: 'æ·»åŠ åˆ°åº•éƒ¨',
                value: 'bottom',
              },
              {
                label: 'éšè—',
                value: 'hidden',
              },
            ]}
          />,
          <Button
            type="text"
            key="rows"
            onClick={() => {
              const rows = editorFormRef.current?.getRowsData?.();
              console.log(rows);
            }}
          >
            è·å– table çš„æ•°æ®
          </Button>,
        ]}
        columns={columns}
        editable={{
          type: 'multiple',
          editableKeys,
          onChange: setEditableRowKeys,
          actionRender: (row, config, defaultDom) => {
            return [
              defaultDom.save,
              defaultDom.delete || defaultDom.cancel,
              <a
                key="set"
                onClick={() => {
                  console.log(config.index);
                  i++;
                  editorFormRef.current?.setRowData?.(config.index!, {
                    title: 'åŠ¨æ€è®¾ç½®çš„title' + i,
                  });
                }}
              >
                åŠ¨æ€è®¾ç½®æ­¤è¡Œ
              </a>,
            ];
          },
        }}
      />
      <ProForm.Item>
        <ProCard title="è¡¨æ ¼æ•°æ®" headerBordered collapsible defaultCollapsed>
          <ProFormDependency name={['table']}>
            {({ table }) => {
              return (
                <ProFormField
                  ignoreFormItem
                  fieldProps={{
                    style: {
                      width: '100%',
                    },
                  }}
                  mode="read"
                  valueType="jsonCode"
                  text={JSON.stringify(table)}
                />
              );
            }}
          </ProFormDependency>
        </ProCard>
      </ProForm.Item>
    </ProForm>
  );
};
```

### Â© ç‰ˆæœ¬ä¿¡æ¯

- ProComponents ç‰ˆæœ¬: 2.6.4
- umi ç‰ˆæœ¬ 4.0.52
- æµè§ˆå™¨ç¯å¢ƒ 114.0.5735.198ï¼ˆæ­£å¼ç‰ˆæœ¬ï¼‰ (arm64)
- å¼€å‘ç¯å¢ƒ [e.g. mac OS]

### ğŸš‘ å…¶ä»–ä¿¡æ¯

## gamemock

è¡¥å……ï¼Œå¦‚æœå°†rowKeyè®¾ç½®ä¸º rowKey={record => record.id} è€Œä¸æ˜¯ rowKey='id' åˆ™ä¸ä¼šå‡ºç°é—®é¢˜ã€‚
ä½†æ˜¯ç‚¹å‡»ä¿å­˜åä»ç„¶å‡ºç°å¼‚å¸¸

## gamemock

è¡¥å…… codesandbox ï¼š
https://codesandbox.io/s/yu-formitem-pei-he-forked-s4fmk9?file=/App.tsx

## chenshuai2144

> TAutomatically replying with ChatGPT can be attempted, but it cannot be guaranteed to be completely accurate and may not fully address all issues. Please feel free to reply if you have any further questions or concerns.
> æ­¤å›å¤åŸºäº ChatGPT è‡ªåŠ¨ç”Ÿæˆï¼Œå¯ä»¥å°è¯•ä¸‹æ–¹æ¡ˆï¼Œå®˜æ–¹äººå‘˜ä¼šåœ¨ä¸€å®šæ—¶é—´åç»§ç»­ç»§ç»­å¤„ç†ã€‚

æ„Ÿè°¢æä¾›è¡¥å……ä¿¡æ¯å’Œç¤ºä¾‹ä»£ç ã€‚æ ¹æ®ä½ çš„æè¿°å’Œä»£ç ï¼Œé—®é¢˜ä¸»è¦åœ¨äºç¼–è¾‘çŠ¶æ€çš„åŒæ­¥å’Œæ¸²æŸ“çš„å¤„ç†ä¸Šã€‚ä»¥ä¸‹æ˜¯æˆ‘ç»™å‡ºçš„è§£å†³æ–¹æ¡ˆï¼š

1. åœ¨ç¼–è¾‘çŠ¶æ€ä¸‹ï¼Œä¿å­˜æ¯ä¸€è¡Œçš„ç¼–è¾‘çŠ¶æ€ã€‚
2. ä½¿ç”¨ä¸€ä¸ªçŠ¶æ€ `editingKey` æ¥è®°å½•å½“å‰æ­£åœ¨ç¼–è¾‘çš„è¡Œçš„ idã€‚
3. ä¿®æ”¹ `editableKeys` çš„æ›´æ–°é€»è¾‘ï¼Œåªæœ‰å½“è¡Œçš„ç¼–è¾‘çŠ¶æ€ä¸º `true` æˆ–è€… `editingKey` ä¸å½“å‰è¡Œçš„ id ç›¸åŒæ—¶æ‰æ·»åŠ åˆ°å¯ç¼–è¾‘è¡Œçš„åˆ—è¡¨ä¸­ã€‚
4. åœ¨ `actionRender` å±æ€§çš„å›è°ƒå‡½æ•°ä¸­ï¼Œæ ¹æ®å½“å‰è¡Œçš„çŠ¶æ€æ¸²æŸ“ç›¸åº”çš„æ“ä½œæŒ‰é’®ã€‚
5. åœ¨ä¿å­˜æ“ä½œæ—¶ï¼Œæ›´æ–°å½“å‰è¡Œçš„ç¼–è¾‘çŠ¶æ€ä¸º `false`ï¼Œå¹¶å°† `editingKey` ç½®ä¸ºç©ºã€‚

ä¿®æ”¹åçš„ä»£ç å¦‚ä¸‹ï¼š

```jsx
import type {
  EditableFormInstance,
  ProColumns,
  ProFormInstance,
} from '@ant-design/pro-components';
import {
  EditableProTable,
  ProCard,
  ProForm,
  ProFormDependency,
  ProFormField,
  ProFormRadio,
} from '@ant-design/pro-components';
import { Button } from 'antd';
import React, { useRef, useState } from 'react';

type DataSourceType = {
  id: React.Key;
  title?: string;
  decs?: string;
  state?: string;
  created_at?: string;
  update_at?: string;
  children?: DataSourceType[];
};

const defaultData: DataSourceType[] = [
  {
    id: '1',
    title: 'æ´»åŠ¨åç§°ä¸€',
    decs: 'è¿™ä¸ªæ´»åŠ¨çœŸå¥½ç©',
    state: 'open',
    created_at: '1590486176000',
    update_at: '1590486176000',
  },
  {
    id: '2',
    title: 'æ´»åŠ¨åç§°äºŒ',
    decs: 'è¿™ä¸ªæ´»åŠ¨çœŸå¥½ç©',
    state: 'closed',
    created_at: '1590481162000',
    update_at: '1590481162000',
  },
];

let i = 0;

export default () => {
  const [editableKeys, setEditableRowKeys] = useState<React.Key[]>(() => []);
  const [position, setPosition] = useState<'top' | 'bottom' | 'hidden'>('bottom');
  const [editingKey, setEditingKey] = useState<string | number>();

  const formRef = useRef<ProFormInstance<any>>();
  const editorFormRef = useRef<EditableFormInstance<DataSourceType>>();

  const columns: ProColumns<DataSourceType>[] = [
    {
      title: 'æ´»åŠ¨åç§°',
      dataIndex: 'title',
      formItemProps: () => {
        return {
          rules: [{ required: true, message: 'æ­¤é¡¹ä¸ºå¿…å¡«é¡¹' }],
        };
      },
      width: '30%',
    },
    {
      title: 'çŠ¶æ€',
      key: 'state',
      dataIndex: 'state',
      valueType: 'select',
      valueEnum: {
        all: { text: 'å…¨éƒ¨', status: 'Default' },
        open: {
          text: 'æœªè§£å†³',
          status: 'Error',
        },
        closed: {
          text: 'å·²è§£å†³',
          status: 'Success',
        },
      },
    },
    {
      title: 'æè¿°',
      dataIndex: 'decs',
    },
    {
      title: 'æ´»åŠ¨æ—¶é—´',
      dataIndex: 'created_at',
      valueType: 'date',
    },
    {
      title: 'æ“ä½œ',
      valueType: 'option',
      width: 200,
      render: (text, record, _, action) => {
        const editable = isEditing(record);

        return editable ? (
          [
            <a
              key="save"
              onClick={() => {
                handleSave(record);
              }}
            >
              ä¿å­˜
            </a>,
            <a
              key="cancel"
              onClick={() => {
                setEditingKey(undefined);
              }}
            >
              å–æ¶ˆ
            </a>,
          ]
        ) : (
          <a
            key="edit"
            onClick={() => {
              setEditingKey(record.id);
            }}
          >
            ç¼–è¾‘
          </a>
        );
      },
    },
  ];

  const isEditing = (record: DataSourceType) => {
    return record.id === editingKey;
  };

  const handleSave = (record: DataSourceType) => {
    const newData = [...(formRef.current?.getFieldValue('table') as DataSourceType[])];
    const index = newData.findIndex((item) => record.id === item.id);

    if (index > -1) {
      const item = newData[index];
      newData.splice(index, 1, {
        ...item,
        ...record,
      });
      formRef.current?.setFieldsValue({
        table: newData,
      });
      setEditableRowKeys([...editableKeys]);
      setEditingKey(undefined);
    }
  };

  return (
    <ProForm<{ table: DataSourceType[] }>
      formRef={formRef}
      initialValues={{
        table: defaultData,
      }}
      validateTrigger="onBlur"
    >
      <EditableProTable<DataSourceType>
        rowKey="id"
        scroll={{
          x: 960,
        }}
        editableFormRef={editorFormRef}
        headerTitle="å¯ç¼–è¾‘è¡¨æ ¼"
        maxLength={5}
        name="table"
        recordCreatorProps={
          position !== 'hidden'
            ? {
              position: position as 'top',
              record: () => ({ id: (Math.random() * 1000000).toFixed(0) }),
            }
            : false
        }
        toolBarRender={() => [
          <ProFormRadio.Group
            key="render"
            fieldProps={{
              style: {
                marginBlockEnd: 0,
              },
              value: position,
              onChange: (e) => setPosition(e.target.value),
            }}
            options={[
              {
                label: 'æ·»åŠ åˆ°é¡¶éƒ¨',
                value: 'top',
              },
              {
                label: 'æ·»åŠ åˆ°åº•éƒ¨',
                value: 'bottom',
              },
              {
                label: 'éšè—',
                value: 'hidden',
              },
            ]}
          />,
          <Button
            type="text"
            key="rows"
            onClick={() => {
              const rows = editorFormRef.current?.getRowsData?.();
              console.log(rows);
            }}
          >
            è·å– table çš„æ•°æ®
          </Button>,
        ]}
        columns={columns}
        editable={{
          type: 'multiple',
          editableKeys: editableKeys.filter((key) => {
            const record = defaultData.find((item) => item.id === key);
            return record?.id === editingKey || record?.state === 'open';
          }),
          onChange: setEditableRowKeys,
        }}
      />
      <ProForm.Item>
        <ProCard title="è¡¨æ ¼æ•°æ®" headerBordered collapsible defaultCollapsed>
          <ProFormDependency name={['table']}>
            {({ table }) => {
              return (
                <ProFormField
                  ignoreFormItem
                  fieldProps={{
                    style: {
                      width: '100%',
                    },
                  }}
                  mode="read"
                  valueType="jsonCode"
                  text={JSON.stringify(table)}
                />
              );
            }}
          </ProFormDependency>
        </ProCard>
      </ProForm.Item>
    </ProForm>
  );
};
```

è¿™æ ·ï¼Œå½“ä½ ç‚¹å‡»ç¼–è¾‘æŒ‰é’®æ—¶ï¼Œåªæœ‰è¢«ç‚¹å‡»çš„è¡Œä¼šè¿›å…¥ç¼–è¾‘çŠ¶æ€ï¼Œå…¶ä»–è¡Œä¸ä¼šå—å½±å“ã€‚åœ¨ä¿å­˜æ“ä½œåï¼Œåªæœ‰å½“å‰ç¼–è¾‘çš„è¡Œçš„ç¼–è¾‘çŠ¶æ€ä¼šè¢«å…³é—­ã€‚

æˆ‘å¸Œæœ›è¿™ä¸ªè§£å†³æ–¹æ¡ˆå¯¹ä½ æœ‰å¸®åŠ©ã€‚å¦‚æœè¿˜æœ‰å…¶ä»–é—®é¢˜ï¼Œè¯·éšæ—¶å‘æˆ‘æé—®ã€‚

## gamemock

æˆ‘ç¿»é˜…äº†ä¸€ä¸‹æºç ï¼Œæ‰¾åˆ°äº†é—®é¢˜çš„æœ€ç»ˆåŸå› ã€‚
1ã€æ ¹æ®ç»„ä»¶packages/table/src/Table.tsxç¬¬594è¡Œçš„æ–¹æ³•å¯çŸ¥ï¼Œå½“è®¾ç½®nameå±æ€§åï¼Œä¼šç”¨indexä½œä¸ºè¡Œå·ã€‚

```
// ============================ RowKey ============================
  const getRowKey = React.useMemo<GetRowKey<any>>(() => {
    if (typeof rowKey === 'function') {
      return rowKey;
    }
    return (record: T, index?: number) => {
      if (index === -1) {
        return (record as any)?.[rowKey as string];
      }
      // å¦‚æœ props ä¸­æœ‰name çš„è¯ï¼Œç”¨index æ¥åšè¡Œå·ï¼Œè¿™æ ·æ–¹ä¾¿è½¬åŒ–ä¸º index
      if (props.name) {
        return index?.toString();
      }
      return (record as any)?.[rowKey as string] ?? index?.toString();
    };
  }, [props.name, rowKey]);
```

2ã€æ ¹æ®é’©å­å‡½æ•°packages/utils/src/useEditableArray/index.tsxç¬¬626è¡Œçš„æ–¹æ³•å¯çŸ¥ï¼Œåˆ¤æ–­å½“å‰åæ˜¯å¦æ˜¯ç¼–è¾‘çŠ¶æ€çš„æ—¶å€™åŒæ—¶åˆ¤æ–­äº†rowKeyä»¥åŠindexã€‚

```
/** è¿™è¡Œæ˜¯ä¸æ˜¯ç¼–è¾‘çŠ¶æ€ */
  const isEditable = useRefFunction((row: RecordType & { index: number }) => {
    // ä¸ºäº†å…¼å®¹ä¸€ä¸‹name æ¨¡å¼çš„ indexKeyï¼Œæ‰€ä»¥éœ€è¦åˆ¤æ–­ä¸¤æ¬¡ï¼Œä¸€æ¬¡æ˜¯indexï¼Œä¸€æ¬¡æ˜¯æ²¡æœ‰ index çš„
    const recordKeyOrIndex = props.getRowKey(row, row.index)?.toString?.();
    // è¿™é‡Œæ˜¯ä¸è®¾ç½® index çš„åœ°æ–¹
    const recordKey = props.getRowKey(row, -1)?.toString?.();

    // éƒ½è½¬åŒ–ä¸ºäº†å­—ç¬¦ä¸²ï¼Œä¸ç„¶ number å’Œ string
    const stringEditableKeys = editableKeys?.map((key) => key?.toString());
    const stringEditableKeysRef =
      editableKeysRef?.map((key) => key?.toString()) || [];

    const preIsEditable =
      (props.tableName && !!stringEditableKeysRef?.includes(recordKey)) ||
      !!stringEditableKeysRef?.includes(recordKeyOrIndex);

    return {
      recordKey,
      isEditable:
        (props.tableName && stringEditableKeys?.includes(recordKey)) ||
        stringEditableKeys?.includes(recordKeyOrIndex),
      preIsEditable,
    };
  });
```

@chenshuai2144 è¿™ä¸ªæ–¹æ¡ˆæ˜¯å¯è¡Œçš„ï¼Œä¸è¿‡è¿™ä¸ªè®¾è®¡æ€è·¯æƒ³è¯·æ•™ä¸€ä¸‹ï¼šä»ä¸Šé¢å¯ä»¥çœ‹åˆ°ï¼Œæœ€æœ¬è´¨çš„åŸå› å°±æ˜¯å½“è¡¨æ ¼è®¾ç½®nameå±æ€§åï¼Œä»¥indexä½œä¸ºè¡Œå·ã€‚åœ¨åˆ¤æ–­æ˜¯å¦ç¼–è¾‘çŠ¶æ€çš„æ—¶å€™ï¼Œç”¨ || åˆ¤æ–­äº†rowKeyå’Œindexã€‚åœ¨æˆ‘æŒ‡å®šçš„rowKeyä¸ç­‰äºç´¢å¼•çš„æ—¶å€™ä¸ä¼šå‡ºç°é—®é¢˜ã€‚åªæ˜¯æ°å¥½åˆå§‹æ•°æ®æ˜¯1 2 3çš„æ—¶å€™é‡åˆ°äº†è¿™ä¸ªé—®é¢˜ã€‚ ç›®å‰æˆ‘é€šè¿‡å°†idçš„å¯å§‹å€¼è®¾å®šä¸º100èµ·å¯ä»¥è§„é¿è¿™ä¸ªé—®é¢˜ã€‚å› ä¸ºæˆ‘å¯ä»¥ç¡®å®šä¸ä¼šå‡ºç°100è¡Œçš„ä¸šåŠ¡åœºæ™¯ã€‚
æˆ‘çš„ç–‘æƒ‘æ˜¯ï¼šè¿™é‡Œä¸ºä½•è¦åœ¨è¡¨å•é›†æˆçš„æ—¶å€™ï¼Œå°†indexè®¾ä¸ºè¡Œå·ï¼Œè€Œä¸æ˜¯ä¿æŒç»Ÿä¸€çš„æŒ‡å®šå€¼å‘¢ï¼Ÿ

## chenshuai2144

å› ä¸ºæ–°å¢çš„æ²¡æœ‰idï¼Œè€Œä¸” antd é‡Œé¢ä¹Ÿè¿™ä¹ˆå®ç°ã€‚æˆ‘æƒ³æƒ³æ€ä¹ˆç»•å¼€
