# [Feature Request] 动态子目录判别basename功能实现

## Background

如果能够将子目录部署动态区分就可以实现同一套代码接入多个项目的场景
或者在不需要重新打包的情况下实现修改子目录名称

## Additional context

以下是我使用pnpm patch 做的补丁 供参考，插件配置中可以开启一个选项标识子路径
这个补丁经测试功能正常可用，但是插件里面还没研究出来怎么实现这个PR ~
请大神帮忙看看了

```diff
diff --git a/templates/umi.tpl b/templates/umi.tpl
index 46761ff0d61ecce655d3724506619a7e820e5b40..da29c7dc2705e238820d38784ab036e74712cb05 100644
--- a/templates/umi.tpl
+++ b/templates/umi.tpl
@@ -33,13 +33,30 @@ async function render() {
     initialValue: {},
   });

-  const basename = contextOpts.basename || '{{{ basename }}}';
-  const historyType = contextOpts.historyType || '{{{ historyType }}}';
-
+// const basename = contextOpts.basename || '{{{ basename }}}';
+// const historyType = contextOpts.historyType || '{{{ historyType }}}';
+let basename = contextOpts.basename || '{{{ basename }}}';
+const historyType = contextOpts.historyType || '{{{ historyType }}}';
+//根据配置，和路由模式定义basename ，用来支持 动态 子站点 比如 http://localhost/[tenantName]
+if (IS_Cloud && historyType == 'browser') {
+  const cloudSettings: CloudSettings = JSON.parse(CLOUD_SETTINGS)
+  if (cloudSettings.clientUrlMode == "SubFolder") {
+    const urlflags = window.location.href.split('/')
+    if (urlflags.length > 3) {
+      basename = `/${urlflags[3]}/`
+    }
+  }
+}
+console.log("contextOpts.historyOpts",contextOpts.historyOpts)
+var localOpts = {
+  ...contextOpts.historyOpts,
+  basename
+}
   const history = createHistory({
     type: historyType,
     basename,
     ...contextOpts.historyOpts,
+    ...localOpts
   });

   return (pluginManager.applyPlugins({
```

## fz6m

```ts
// app.ts

export const modifyContextOpts = (pre) => {
  pre.basename = "/test"; // 自己根据需求改
  return pre;
};
```

## hyzx86

感谢，又学了一招~~
