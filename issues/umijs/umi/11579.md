# [Feature Request] plugin-request 插件在提供了 errorHandler 时终止 error 继续 reject

## Background

希望在 plugin-request 提供的 axios 拦截器中有能力阻止 error 的继续 throw。

虽然umi提供了错误边界来做最后兜底，但是在某些情况下仍然需要调用方做意义不明的 catch，比如 ant design 中 Upload 组件的 customRequest

```ts
// 无意义的 catch
const props: UploadProps = {
  name: "file",
  multiple: false,
  showUploadList: false,
  customRequest: async (opts) => {
    try {
      await request();
    } catch {}
  },
};
```

## Proposal

```ts
// 原始逻辑
...
...
.catch((error)=>{
  requestInterceptorsToEject?.forEach((interceptor) => {
    requestInstance.interceptors.request.eject(interceptor);
  });
  responseInterceptorsToEject?.forEach((interceptor) => {
    requestInstance.interceptors.response.eject(interceptor);
  });
  try {
    const handler =
      config?.errorConfig?.errorHandler;
    if(handler)
      handler(error, opts, config);
  } catch (e) {
    reject(e);
  }
  // 既然 errorHandler 已经处理了错误，为何还要 reject
  // 何况提供了 skipErrorHandler 参数来让 errorHandler 自主控制 error 是否 throw 到调用方
  reject(error);
})
```

这样会不会好一些

```ts
// 建议逻辑
...
...
.catch((error)=>{
  requestInterceptorsToEject?.forEach((interceptor) => {
    requestInstance.interceptors.request.eject(interceptor);
  });
  responseInterceptorsToEject?.forEach((interceptor) => {
    requestInstance.interceptors.response.eject(interceptor);
  });
  try {
    const handler =
      config?.errorConfig?.errorHandler;
    if(handler)
      handler(error, opts, config);
    else  // 加入这个分支来确保 error 被正确 reject
      reject(error)
  } catch (e) {
    reject(e);
  }
})

// 移除始终 reject 逻辑
// reject(error);
```

## fz6m

手动 try catch 下吧，antd Form 组件的 `form. validateFields` 也会自己拋错需要 try catch ，同时你上传也不一定成功的，失败了需要在 catch 里提示下，可以再对 request 封一层。
