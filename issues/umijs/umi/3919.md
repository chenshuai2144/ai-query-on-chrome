# history和single-spa冲突，单一回调会重复执行两次，导致umi和qiankun一起使用时行为异常

  <!--
感谢您向我们反馈问题，为了高效的解决问题，我们期望你能提供以下信息：
-->

## What happens?

![image](https://user-images.githubusercontent.com/3301995/72416996-db3aed80-37b2-11ea-8ede-cd6066547775.png)

<!-- 清晰的描述下遇到的问题。-->

## 最小可复现仓库

[History代码库错误行](https://github.com/ReactTraining/history/blob/3f69f9e07b0a739419704cffc3b3563133281548/modules/createBrowserHistory.js#L267)

[Single-SPA代码库错误行](https://github.com/CanopyTax/single-spa/blob/92efd71ace891d59eb1005d09dd5cf532fbba154/src/navigation/navigation-events.js#L100)

### 错误分析

single-spa改写了window.history.pushState方法，在每次pushState的时候会主动dispatch一个popState事件，被history checkDomListeners捕获，这样通过history.listen注册的监听函数都会被执行两次，如
[connected-react-router handleLocationChange方法](https://github.com/supasate/connected-react-router/blob/7af0ed011d6c1bbdfac822c951d68f750e8bada8/src/ConnectedRouter.js#L53)

### 解决方案

> 尝试自己写插件解决无效

```
# 插件代码
const fs = require('fs')
const path = require('path')

export default function(api, options) {
  api.modifyEntryHistory(memo => {
    const content = fs.readFileSync(path.resolve(__dirname, 'historyPatch.js'), {
      encoding: 'utf8'
    })
    return content
  })
}

# historyPatch.js
/**
 * fix history & single-spa bug, remove checkDOMListeners
 * https://github.com/ReactTraining/history/blob/3f69f9e07b0a739419704cffc3b3563133281548/modules/createBrowserHistory.js#L267
 * https://github.com/CanopyTax/single-spa/blob/92efd71ace891d59eb1005d09dd5cf532fbba154/src/navigation/navigation-events.js#L100
 */

require('@zstack/history').createBrowserHistory({ basename: window.routerBase })
```

运行后.umi/history生成如下

```
// create history
const history
/**
 * fix history & single-spa bug, remove checkDOMListeners
 * https://github.com/ReactTraining/history/blob/3f69f9e07b0a739419704cffc3b3563133281548/modules/createBrowserHistory.js#L267
 * https://github.com/CanopyTax/single-spa/blob/92efd71ace891d59eb1005d09dd5cf532fbba154/src/navigation/navigation-events.js#L100
 */ = require('@zstack/history').createBrowserHistory({
  basename: window.routerBase,
});
export default history;

```

但实际运行时，检查sourcemap，系统仍然选用umi-history，怀疑和alias有关

执行npx umi inspect > dev.log
有如下配置

```
history: '/Users/shengbeiniao/zstack/projects/cmp/node_modules/umi-history',
```

重写alias，无法覆盖

- **Umi 版本**：umi@2.12.4 umi-history@0.1.2 single-spa@4.4.2
- **Node 版本**：
- **操作系统**：

  ## shengbeiniao

  通过插件重写alias，并修改umi-history/createBrowserHistory Listener方法可以解决，临时方案，不推荐

```
export default function(api, options) {
  api.chainWebpackConfig(webpackConfig => {
    webpackConfig.resolve.alias
      .set('history','@zstack/history')
  })
}

#createBrowserHistory
  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    // checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      // unlisten();
    };
  };


  ## shengbeiniao

  关于路由跳转，这里还有个坑，子应用-->主应用-->登出，https://github.com/supasate/connected-react-router/blob/7af0ed011d6c1bbdfac822c951d68f750e8bada8/src/ConnectedRouter.js#L41

这里connected-react-router加了个判断，会判断location是否和redux的一致，不一致再执行一次push


  ## shengbeiniao

  这个bug修复了，通过改变history和connected-react-router库实现

1. 安装依赖
```

$ yarn add @zstack/history
$ yarn add @zstack/connected-react-router

```
2. 编写插件
```

# umi-plugin-history.js

export default function(api, options) {
api.chainWebpackConfig(webpackConfig => {
webpackConfig.resolve.alias
.set('history','@zstack/history')
webpackConfig.resolve.alias
.set('connected-react-router','@zstack/connected-react-router')  
 })
}

```
3. 配置umi
```

# .umirc

config.plugins.push([
path.resolve(__dirname, '../plugin/umi-plugin-history.js')
])

````

>history库移除了checkDomListeners
connected-react-router库移除了subscribe if判断，见上面的链接

经反复测试未发现bug


  ## drafish

  我在models的subscriptions里写了history.listen
```javascript
subscriptions: {
    setup({ history }) {
      return history.listen(({ pathname, search }) => {

      });
    },
  },
````

每次切换主应用路由的时候这个函数就会被执行两次，原因就是@shengbeiniao 前面描述的那样，我用的umi、qiankun、@umi/plugin-qiankun都是最新的，但问题还是存在。

图片里的两次LOCATION_CHANGE事件我这边倒是没有复现，[这个PR](https://github.com/umijs/plugins/pull/148)修复的是不是这个问题呀。

## esymeptoo

这个问题官方有修复吗

## yingjieg

@shengbeiniao 替换为zstack的实现后，的确解决了“每次pushState的时候会主动dispatch一个popState事件”的问题，但是发现router.goBack() 不工作了，在history.listen 中无法感知到POP action，请问这个有什么思路吗？

## yingjieg

```js
function handlePopState(event) {
  // Ignore extraneous popstate events in WebKit.
  if (isExtraneousPopstateEvent(event)) return;

  if (
    event.singleSpaTrigger === "replaceState" ||
    event.singleSpaTrigger === "pushState"
  )
    return;

  handlePop(getDOMLocation(event.state));
}
```

在umi-history中判断了一下popState事件是否来自与single-spa，现在问题算是解决了。

## swiftwind0405

>

感谢，解决了问题！
