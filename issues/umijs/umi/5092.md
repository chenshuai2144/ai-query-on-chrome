# 项目按照文档配置404.tsx，404功能没有生效

`type(enhancement)`

## What happens?

umi版本 3.2.10，配置在pages下使用404.tsx，404页面的功能没有实现

查看生成的文件下的router文件，并没有将404处理成文档描述的样子，而是作为普通路由处理了

错误的代码结构：
{
"path": "/404",
"exact": true,
"component": require('@/pages/404.tsx').default
},

期望生成 ：
{
"component": require('@/pages/404.tsx').default
},

因为我们的开发环境问题，我这边无法处理这个问题，希望官方帮忙解决一下，谢谢

## fengzhenfz

刚刚发现
{
"component": require('@/pages/404.tsx').default
},
这样也不能实现404的功能

## EiosH

一样的//。。。

## bluesaiz

遇到同样的问题，有解决办法吗？

## SuperHuangXu

+1

## handycode

一样的问题 线上环境也是

## handycode

我目前的解决方案, 在项目中增加自己的插件处理，
参考了 @xiaohuoni 的代码，https://github.com/umijs/umi/pull/4987 供大家参考

### 项目 config 配置

```
{
  ...
  plugins: [...其他的插件配置, './plugins/404'],
  ...
}
```

### 项目根目录下增加 plugins/404.ts 文件

```
import { IApi, IRoute } from 'umi'
import { IConfig } from '@umijs/types'

export function patchRoutes(routes: IRoute[], config: IConfig, _notFoundComponent?: string) {
  if (config.exportStatic) return routes
  let notFoundIndex = null
  let notFoundComponent = ''
  routes.forEach((route, index) => {
    if (route.path === '/404' && route.component) {
      notFoundIndex = index
      console.log(route)
      notFoundComponent = route.component
    }
    if (route.routes) {
      route.routes = patchRoutes(route.routes, config, notFoundComponent)
    }
  })
  if (notFoundIndex !== null) {
    const notFoundRoute = routes.slice(notFoundIndex, notFoundIndex + 1)[0]
    if (notFoundRoute.component) {
      routes.push({ component: notFoundRoute.component })
    } else if (notFoundRoute.redirect) {
      routes.push({ redirect: notFoundRoute.redirect })
    } else {
      throw new Error('Invalid route config for /404')
    }
  } else if (_notFoundComponent) {
    routes.push({ component: _notFoundComponent })
  }
  return routes
}

export default (api: IApi) => {
  api.modifyRoutes((routes: IRoute[]) => patchRoutes(routes, api.config))
}
```

## lxzxl

PR merge之前， 提供一个简单的解决方法：

1. 把`404.jsx` 改成 `[any].jsx`, 保证在生成的路由在最后一项

2. 覆盖页面属性的 `path` 为 `undefined`, 达到生成的routes里没有path的目的

```javascript
// [any].jsx

const NoFoundPage = () => <div>not found</div>;

// !!!这里覆盖掉 path 的值!!!
NoFoundPage.path = undefined;

export default NoFoundPage;
```

## CantFindItAnymore

> PR merge之前， 提供一个简单的解决方法：
>
> 1. 把`404.jsx` 改成 `[any].jsx`, 保证在生成的路由在最后一项
> 2. 覆盖页面属性的 `path` 为 `undefined`, 达到生成的routes里没有path的目的
>
> ```js
> // [any].jsx
>
> const NoFoundPage = () => <div>not found</div>;
>
> // !!!这里覆盖掉 path 的值!!!
> NoFoundPage.path = undefined;
>
> export default NoFoundPage;
> ```

这样只对一级不存在的路由生效，二级或多级不存在的路由还是会渲染出空白页

## handycode

@CantFindItAnymore 参考我上边的步骤， 改进过的 可以对多级做处理

## neekey

这种级别的bug为什么快8个月了都还没fix？

## godkun

> 这种级别的bug为什么快8个月了都还没fix？

这处理速度扎心了，这种重要的问题拖了八个月不解决，是为啥呢

## jasonHzq

还是没解决吗

## linzhiyuan00

多级路由下的404好像还是不行？
