# 页面级测试方案

## 问题

目前 umi 的测试方案仅支持单测和组件测试，无法进行页面级测试。业务部分需要页面级测试以保证稳定性。

## 方案

### 使用

```js
import Page from "index.tsx";
import { TestBrowser } from "@umijs/max";

it("test page", () => {
  const html = render(
    <TestBrowser>
      <Page />
    </TestBrowser>,
  );
  const logo = html.find("logo");
  expect(logo).tobe(true);
});
```

### 实现

1. 新增一个 test 插件（preset-umi/src/features/test/test.ts）
2. 写文件到 core/testBrowser.tsx 里，export `TestBrowser` 方法
3. `TestBrowser` 里的基本思路是

```js
// 初始化 pluginManager
import { createPluginManager } from './plugin';
const pluginManager = createPluginManager();

import { createHistory } from './history';
import { renderClients } from './exports';
export function TestBrowser(props) {
  return renderClients({
    routes: { 'test': { path: '/', files: '', id: 'test' } },
    routeComponents: { 'test': props.children },
    history: createHistory({ type: 'memory', basename: '/', ... }),
  });
}
```

## 参考

- https://github.com/umijs/umi/pull/8493

## chenshuai2144

- routes 也需要注入一下。layout 的配置有一部分在菜单里面，我需要mock pathname 来让 router 获取到当前路由的layout 配置
- initalvalues 和 modal 需要提供一个mock的方式来进行数据的更新
- 额外的一些 utils 要放到哪里？

## chenshuai2144

```tsx
it("test page", () => {
  const modelRef = React.createRef();
  const html = render(
    <TestBrowser modelRef={modelRef}>
      <Page />
    </TestBrowser>,
  );
  const logo = html.find("logo");
  expect(logo).tobe(true);

  modelRef.current.initialValues.setInitialValues({ ...newData });
  expect(!!html.find("logo")).tobe(false);
});
```

我想的操作方式是这样的

## sorrycc

1. 全量的 routes ，比如我在 pathname ===
