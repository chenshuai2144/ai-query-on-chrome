[
  {
    "path": "playground/pro-form",
    "key": "docs/playground/pro-form",
    "text": "ProForm 的主要功能是预设了很多 layout，如果需要切换只需要改变外面包裹的 Layout 即可，以下是个 demo。"
  },
  {
    "path": "playground",
    "key": "docs/playground/index",
    "text": "ProTable，ProDescriptions，ProForm 都是基于 ProField 来进行封装。ProTable 和 ProDescriptions 根据 valueType 来渲染不同的 ProField，Form 则是通过不同的 FormField 来实现封装。使用同样的底层实现为 ProTable，ProDescriptions，ProForm 打通带来了便利。ProForm 可以很方便的实现只读模式，ProTable 可以快速实现查询表单和可编辑表格。ProDescriptions 可以实现节点编辑，以下有个例子可以切换三个组件。"
  },
  {
    "path": "components",
    "key": "docs/components",
    "text": "ProComponents 是基于 Ant Design 而开发的模板组件，提供了更高级别的抽象支持，开箱即用。可以显著的提升制作 CRUD 页面的效率，更加专注于页面。ProLayout解决布局的问题，提供开箱即用的菜单和面包屑功能ProTable表格模板组件，抽象网络请求和表格格式化ProForm表单模板组件，预设常见布局和行为ProCard提供卡片切分以及栅格布局能力ProDescriptions定义列表模板组件，ProTable 的配套组件ProSkeleton页面级别的骨架屏如果您是阿里内网用户，欢迎尝试使用TechUI。TechUI 在封装 ProComponents 的基础上还提供了丰富的 Ant Design 扩展组件。ProTable，ProList 使用了新的数据结构，如果你使用了我们约定的参数使用起来会非常简单。const msg: {  data: T[];  page: number;  success: boolean;  total: number;} = {  data: [],  page: 1,  success: true,  total: 0,};如果你的后端数据使用了自己熟悉的 url，虽然我们可以用 umi 的 request 来转化，但是每个 table 都需要配置就比较麻烦。如果你使用 umi 的 request，我们可以定义一个全局的转化器。我们需要在 app.tsx 中配置import { request, RequestConfig } from 'umi';export const request: RequestConfig = {  errorConfig: {    adaptor: (resData) => {      // resData 是我们自己的数据      return {        ...resData,        total: resData.sum,        success: resData.ok,        errorMessage: resData.message,      };    },  },};<ProTable request={request('/list')} />;如果使用了 fetch ，可以对 fetch 进行自定义。const request = (url, options) => {  return fetch(url, options)    .then((res) => res.json())    .then((resData) => {      return Promise.resolve({        ...resData,        total: resData.sum,        success: resData.ok,        errorMessage: resData.message,      });    });};// 使用时<ProTable request={request('/list')} />;"
  },
  {
    "path": "components/schema",
    "key": "docs/components/schema",
    "text": "在 ProComponents 我们在组件使用了与 table 的相同的定义，同时扩展了部分字段。让其可以满足更多需求。字段名称类型说明keyReact.key确定这个列的唯一值,一般用于 dataIndex 重复的情况dataIndexReact.key|React.key[]与实体映射的 key，数组会被转化[a,b] => Entity.a.bvalueTypeProFieldValueType数据的渲渲染方式，我们自带了一部分，你也可以自定义 valueTypetitleReactNode|(props,type,dom)=> ReactNode标题的内容，在 form 中是 labeltooltipstring会在 title 旁边展示一个 icon，鼠标浮动之后展示valueEnum(Entity)=> ValueEnum|ValueEnum支持 object 和 Map，Map 是支持其他基础类型作为 keyfieldProps(form,config)=>fieldProps|fieldProps传给渲染的组件的 props，自定义的时候也会传递formItemProps(form,config)=>formItemProps|formItemProps传递给 Form.Item 的配置renderText(text: any, record: Entity, index: number, action: ProCoreActionType) => any修改的数据是会被 valueType 定义的渲染组件消费render(dom,entity,index, action, schema) => React.ReactNode自定义只读模式的 dom,render方法只管理的只读模式，编辑模式需要使用renderFormItemrenderFormItem(schema,config,form) => React.ReactNode自定义编辑模式,返回一个 ReactNode，会自动包裹 value 和 onChangerequest(params,props) => Promise<{label,value}[]>从远程请求网络数据，一般用于选择类组件paramsRecord<string, any>额外传递给request的参数，组件不做处理,但是变化会引起request重新请求数据hideInFormboolean在 Form 中隐藏hideInTableboolean在 Table 中隐藏hideInSearchboolean在 Table 的查询表单中隐藏hideInDescriptionsboolean在 descriptions 中隐藏rowPropsRowProps在开启grid模式时传递给 Row，仅在ProFormGroup,ProFormList,ProFormFieldSet中有效colPropsColProps在开启grid模式时传递给 Colexport type ProSchema<T = unknown, U = string, Extra = unknown> = {  /** @name 确定这个列的唯一值 */  key?: string | number;  /**   * 支持一个数组，[a,b] 会转化为 obj.a.b   *   * @name 与实体映射的key   */  dataIndex?: string | number | (string | number)[];  /** 选择如何渲染相应的模式 */  valueType?: ((entity: T, type: ProSchemaComponentTypes) => U) | U;  /**   * 支持 ReactNode 和 方法   *   * @name 标题   */  title?:    | ((        schema: ProSchema<T, U, Extra>,        type: ProSchemaComponentTypes,        dom: React.ReactNode,      ) => React.ReactNode)    | React.ReactNode;  /** @name 展示一个 icon，hover 是展示一些提示信息 */  tooltip?: string | LabelTooltipType;  /** @deprecated 你可以使用 tooltip，这个更改是为了与 antd 统一 */  tip?: string;  render?: (    dom: React.ReactNode,    entity: T,    index: number,    action: ProCoreActionType,    schema: ProSchema<T, U, Extra>,  ) => React.ReactNode;  /**   * 返回一个node，会自动包裹 value 和 onChange   *   * @name 自定义编辑模式   */  renderFormItem?: (    item: ProSchema<T, U, Extra>,    config: {      index?: number;      value?: any;      onSelect?: (value: any) => void;      type: ProSchemaComponentTypes;      defaultRender: (newItem: ProSchema<T, U, Extra>) => JSX.Element | null;    },    form: FormInstance,  ) => React.ReactNode;  /**   * 必须要返回 string   *   * @name 自定义 render   */  renderText?: (    text: any,    record: T,    index: number,    action: ProCoreActionType,  ) => any;  fieldProps?: any;  /** @name 映射值的类型 */  valueEnum?: ProSchemaValueEnumObj | ProSchemaValueEnumMap;  /** @name 从服务器请求枚举 */  request?: ProFieldRequestData<ProSchema>;  /** @name 从服务器请求的参数，改变了会触发 reload */  params?: {    [key: string]: any;  };  /** @name 隐藏在 descriptions */  hideInDescriptions?: boolean;} & Extra;valueType 是 ProComponents 的灵魂，ProComponents 会根据 valueType 来映射成不同的表单项。以下是支持的常见表单项：valueType说明password密码输入框money金额输入框textarea文本域date日期dateTime日期时间dateWeek周dateMonth月dateQuarter季度输入dateYear年份输入dateRange日期区间dateTimeRange日期时间区间time时间timeRange时间区间text文本框select下拉框treeSelect树形下拉框checkbox多选框rate星级组件radio单选框radioButton按钮单选框progress进度条percent百分比组件digit数字输入框second秒格式化avatar头像code代码框switch开关fromNow相对于当前时间image图片jsonCode代码框，但是带了 json 格式化color颜色选择器cascader级联选择器segmented分段器group分组formList表单列表formSet表单集合divider分割线dependency依赖项这里 demo 可以来了解一下各个 valueType 的展示效果。只有一个值并不能表现很多类型，progress就是一个很好的例子。所以我们支持传入一个 function。你可以这样使用：const columns = {  title: '进度',  key: 'progress',  dataIndex: 'progress',  valueType: (item: T) => ({    type: 'progress',    status: item.status !== 'error' ? 'active' : 'exception',  }),};return {  type: 'progress',  status: 'success' | 'exception' | 'normal' | 'active',};return { type: 'money', locale: 'en-Us' };return { type: 'percent', showSymbol: true | false, precision: 2 };如果我们带的 valueType 不能满足需求，我们可以用自定义 valueType 来自定义业务组件。valueEnum 需要传入一个枚举，ProTable 会自动根据值获取响应的枚举，并且在 form 中生成一个下拉框。看起来是这样的：const valueEnum = {  open: {    text: '未解决',    status: 'Error',  },  closed: {    text: '已解决',    status: 'Success',  },};// 也可以设置为一个functionconst valueEnum = (row) =>  row.isMe    ? {        open: {          text: '未解决',          status: 'Error',        },        closed: {          text: '已解决',          status: 'Success',        },      }    : {        open: {          text: '等待解决',          status: 'Error',        },        closed: {          text: '已回应',          status: 'Success',        },      };这里值得注意的是在 form 中并没有 row，所以 row 的值为 null，你可以根据这个来判断要在 form 中显示什么选项。当前列值的枚举interface IValueEnum {  [key: string]:    | ReactNode    | {        text: ReactNode;        status: 'Success' | 'Error' | 'Processing' | 'Warning' | 'Default';      };}使用 Map 来让 valueEnum 更灵活，某些场景会用到 number 类型或者 boolean 类型，例如：支持组件Select,TreeSelect,Cascader,Checkbox,Radio,RadioButton支持参数request,params,fieldProps.options,valueEnum来支持远程数据，这几个属性分别有不同的用法。valueEnumvalueEnum 是最基础的用法， 它支持传入一个Object或者是Map，相比于 options 支持更加丰富的定义，比如在表格中常见的各种badge。const valueEnum = {  all: { text: '全部', status: 'Default' },  open: {    text: '未解决',    status: 'Error',  },  closed: {    text: '已解决',    status: 'Success',  },};import { ProFormSelect } from '@ant-design/pro-components';const valueEnum = {  all: { text: '全部', status: 'Default' },  open: {    text: '未解决',    status: 'Error',  },  closed: {    text: '已解决',    status: 'Success',  },};export default () => (  <ProFormSelect    name=\"select2\"    label=\"Select\"    params={{}}    valueType=\"select\"    valueEnum={valueEnum}    placeholder=\"Please select a country\"  />);fieldProps.optionsoptions 是 antd 定义的标准，但是只有部分组件支持， ProComponents 扩展了组件，使得select,checkbox,radio,radioButton都支持了options, 他们的用法是相同的。const options = [  { label: '全部', value: 'all' },  { label: '未解决', value: 'open' },  { label: '已解决', value: 'closed' },  { label: '解决中', value: 'processing' },  {    label: '特殊选项',    value: 'optGroup',    optionType: 'optGroup',    options: [      { label: '不解决', value: 'no' },      { label: '已废弃', value: 'clear' },    ],  },];// 或者不需要 labelconst options = ['chapter', 'chapter2'];// 列中定义const columns = [  {    title: '创建者',    width: 120,    dataIndex: 'creator',    valueType: 'select',    fieldProps: {      options: [        {          label: 'item 1',          value: 'a',        },        {          label: 'item 2',          value: 'b',        },        {          label: 'item 3',          value: 'c',        },      ],    },  },];import { ProFormSelect } from '@ant-design/pro-components';const options = [  {    label: 'item 1',    value: 'a',  },  {    label: 'item 2',    value: 'b',  },  {    label: 'item 3',    value: 'c',  },];export default () => (  <ProFormSelect    name=\"select2\"    label=\"Select\"    valueType=\"select\"    fieldProps={{ options }}    placeholder=\"Please select a country\"  />);requestparams可以使用 debounceTime 调整请求防抖时间，默认为 10ms大部分时候我们是从网络中获取数据，但是获取写一个 hooks 来请求数据还是比较繁琐的，同时还要定义一系列状态，所以我们提供了request和params来获取数据。request是一个 promise,需要返回一个 options 相同的数据params一般而言request是惰性的，params 修改会触发request的重新请求。const request = async () => [  { label: '全部', value: 'all' },  { label: '未解决', value: 'open' },  { label: '已解决', value: 'closed' },  { label: '解决中', value: 'processing' },];<ProFormSelect  name=\"select2\"  label=\"Select\"  params={{}}  valueType=\"select\"  debounceTime={1000}  request={request}  placeholder=\"Please select a country\"/>;// 列中定义const columns = [  {    title: '创建者',    width: 120,    dataIndex: 'creator',    valueType: 'select',    request,    params: {},  },];import {  ProForm,  ProFormSelect,  ProFormText,} from '@ant-design/pro-components';const request = async (params) => {  console.log(params);  return [    { label: params.text, value: 'all' },    { label: '未解决', value: 'open' },    { label: '已解决', value: 'closed' },    { label: '解决中', value: 'processing' },  ];};export default () => (  <ProForm>    <ProFormText label=\"相互依赖的\" initialValue=\"所有的\" name=\"text\" />    <ProFormSelect      name=\"select2\"      label=\"Select\"      valueType=\"select\"      dependencies={['text']}      request={request}      placeholder=\"Please select a country\"    />  </ProForm>);在实际的使用中request增加了一个 5s 缓存，可能会导致数据更新不及时，如果需要频繁更新，建议使用state+fieldProps.options。"
  },
  {
    "path": "docs",
    "key": "docs/docs/index",
    "text": "ProComponents 是基于 Ant Design 而开发的模板组件，提供了更高级别的抽象支持，开箱即用。可以显著的提升制作 CRUD 页面的效率，更加专注于页面。ProLayout解决布局的问题，提供开箱即用的菜单和面包屑功能ProTable表格模板组件，抽象网络请求和表格格式化ProForm表单模板组件，预设常见布局和行为ProCard提供卡片切分以及栅格布局能力ProDescriptions定义列表模板组件，ProTable 的配套组件ProSkeleton页面级别的骨架屏在使用之前可以查看一下典型的 Demo 来判断组件是否适合你们的业务。ProComponents 专注于中后台的 CRUD, 预设了相当多的样式和行为。这些行为和样式更改起来会比较困难，如果你的业务需要丰富的自定义建议直接使用 Ant Design。当前 ProComponents 每一个组件都是一个独立的包，你需要在你的项目中安装对应的 npm 包并使用。$ npm i @ant-design/pro-components --save当前 ProComponents 提供了如下组件可直接使用：npm i @ant-design/pro-components --save每一个包都是一个独立的组件包，使用示例如下 ：我们所有的包都使用 css in js 管理样式，只需引入 js 即可。"
  },
  {
    "path": "docs/intro",
    "key": "docs/docs/intro",
    "text": "Ant Design 定义了基础的设计规范，对应也提供了大量的基础组件。但是对于中后台类应用，我们希望提供更高程度的抽象，提供更上层的设计规范，并且对应提供相应的组件使得开发者可以快速搭建出高质量的页面。在 ProComponents 中我们内置了一系列的设计规范，预设了常用的逻辑。在这个基础上我们同样提供了灵活的支持，比如对于 ProTable 来说你也可以把它完全当做 Ant Design 的 Table 来用，对于 ProForm 来说你也可以直接使用 Ant Design 的基础组件或者你的自定义组件。我们希望通过 Pro 系列组件提供快速高效搭建高质量中后台应用的能力，进一步扩展 Ant Design 的能力，欢迎使用并提出宝贵的意见。对于几乎所有的业务来说，我们做的其实就是根据一个状态定义一系列的行为，以上面的 table 为例，首先我们需要一个状态dataSource用于存储从服务器请求的数据，为了优化体验，我们还需要一个loading。于是我们就有了一系列的行为，我们需要先设置loading=true，然后发起网络请求，网络请求完成之后就 设置dataSource为请求回来的数据，loading=false，一个网络请求就完成了，虽然非常简单，但是一个业务系统有相当多的表格，每个表格都定义这么一次，这个工作量就非常大了。如果要重新请求网络，我们就需要封装一下行为，将以上的行为封装成一个方法，点击一下重新加载数据，如果你有分页，那么就需要新的变量 page，我们在重新请求之前需要去根据需要来判断一下是否将页面重置为第一页，这又引入了一个变量。如果你的表格还要控制每页的数量，那么将会更加繁杂。这种重复性的劳动会浪费掉我们的很多时间。以上的逻辑几乎存在于所有中后台开发中，每增加一个状态我们就需要一系列的行为来进行管理，每个行为如果耦合了太多的状态也会复杂到无以复加。碰上这种情况，几乎所有程序员都会想办法进行分层，基于同样的思路，ProTable 希望抽象出一层来解决掉复杂状态的问题，table 中最常用的状态就是loading和dataSource，包括扩展的page,pageSize其实都是服务于网络状态，于是 table 抽象出了一个request的 api，在其中封装了 loading 和 dataSource 状态以及他们所有的行为，上一页，下一页，重新刷新，修改每页大小等行为。这种封装模式可以让前端从各种状态管理中脱身出来，专注于业务开发，也不需要 dva，redux 等数据流的方案，更加符合直觉。开发者只需要定义一个状态，重型组件会自动生成一系列行为。为了渐进式使用我们也提供了与 Ant Design 相同的 api，完全可以降级成为一个 Ant Design 的 table 使用。重型组件区别于传统组件有个很大的不同，重型组件在抽象时是将其当成一个页面来进行处理，所以 ProTable 会支持网络请求和自动生成查询表单，而 ProLayout 会支持自动生成菜单，两者都基于同样的思想也就是提供页面级别的抽象。一个列表页应该可以用 ProLayout + ProTable 完成，一个编辑页应该使用 ProLayout + ProForm 完成，详情页可以用 ProLayout + ProDescriptions 完成。 一个页面在开发过程中只需要关注几个重型组件，降低心智负担，专注于更核心的业务逻辑。在实际开发中我们也经常会碰到一些设计问题，比如经典的按钮应该放在左面还是右面，查询表单怎么布局，日期怎么格式化，数字的对齐问题，在重型组件中都进行了抽象，对于各种行为与样式我们都经过了设计师的讨论与设计可以达到默认好看及好用。如果你还是想自定义相关渲染可以通过自定义 valueType 的方式来实现。默认的不一定是最好的，但是一定不差，如果你要自定义最好考虑一下投入产出比，毛坯房里雕花真的好吗？我们非常欢迎你的贡献，你可以通过以下方式和我们一起共建 😊 ：在你的公司或个人项目中使用 Ant Design Pro，umi 和 ProComponents。通过Issue报告 bug 或进行咨询。提交Pull Request改进 ProComponents 的代码。当我们 clone 完项目之后会看到如下的目录结构。- .dumi              * dumi 的相关配置，主要是主题等- .github            * github 的 action 和相关的 issue 配置- docs               * 存放公用的文档- packages           * 我们维护的包, 如果你想贡献代码，这里是你最需要关注的- README.md          * 展示在 github 主页的代码- tests              * 编写测试用例的地方- public             * 部署官网所用的静态文件- scripts            * 开发或者部署所用的脚本- .prettierrc.js     * prettier 的相关配置- .eslintrc.js       * eslint 的配置- .fatherrc.ts       * 编译脚手架的配置- .umirc.js          * dumi 的核心配置- webpack.config.js  * 编译 umd 包的配置文件- jest.config.js     * 测试环境的配置- lerna.json         * 多包的配置- package.json       * 项目的配置- tsconfig.json      * typescript 的配置- pnpm-lock.yaml     * 依赖 lock 文件coverage和.umi这两个文件夹比较特殊，coverage是测试覆盖率文件，在跑完测试覆盖率后才会出现，.umi是运行时的一些临时文件，在执行npm run start时生成。在 packages 文件夹中包含了我们所有的组件，每个组件一般都有一个src，package.json和README.md。package.json和README.md可以在新建文件夹后通过执行npm run bootstrap来生成。src中就是我们真正的源码，我们约定src下会有 demos 文件夹里面会存储所有的 demo，并且${包名}.md的文件用于介绍这个组件，同时引入 demo 和 API 文档。我们使用了 dumi 的语法，要求全部使用外置组件，用 code 引入，调试起来会更加方便。我们使用自动化代码格式化软件Prettier。 对代码做出更改后，运行npm run prettier。当然我们更推荐 prettier 的插件，随时格式化代码。我们的 CI 会检查代码是否被 prettier，在提交代码前最好执行一下npm run prettier。之后，linter会捕获代码中可能出现的多数问题。 你可以运行npm run lint来检查代码风格状态。不过，linter也有不能搞定的一些风格。如果有些东西不确定，请查看Airbnb’s Style Guide来指导自己。我们使用了monorepo的方式来管理我们的仓库，仓库中包含多个独立的包，以便于更改可以一起联调，这样可以一起跑测试用例，如果变更出现问题，我们可以很快的定位到问题。pnpm-workspace.yaml可以帮助我们在多个包中共享依赖。安装完成后你可以使用以下命令：pnpm start预览你的改动pnpm lint检查代码风格pnpm tsc检查 TypeScript 是否符合规范pnpm test测试代码是否可以通过测试用例pnpm test:coverage测试仓库的测试覆盖率pnpm build编译当前组件库我们建议运行pnpm test或前文提及的 linter 以确保你的代码变更有没有影响原有功能，同时保证你写的每行代码都被正确的测试到，不管怎样这样都会提升组件库的整体质量。如果你增加了一个新功能，请添加测试后再提交 pr，这样我们能确保以后你的代码不出问题。ProComponents 基于 antd 之上来开发，为了与 antd 的生态保持兼容性，我们要求覆盖 antd 的样式必须要使用${token.antCls}变量来生成类名，在 js 中使用如下代码来配置实现。const { getPrefixCls } = useContext(ConfigProvider.ConfigContext);const prefixCls = getPrefixCls('pro-${包名}');"
  },
  {
    "path": "docs/faq",
    "key": "docs/docs/faq",
    "text": "以下整理了一些 ProComponents 社区常见的问题和官方答复，在提问之前建议找找有没有类似的问题。此外我们也维护了一个反馈较多how to use 标签亦可参考。不行的，你可以在 request 中转化一下，或者写个拦截器。示例columns 的 title 支持 function 的，你可以这样写title: (_, type) => {  if (type === 'table') {    return '标题';  }  return null;};ProComponentsProComponents那啥，试试cnpm和yarn。ForminitialValuesProComponents底层也是封装的antd，所以用法也是和antd相同。注意initialValues不能被setState动态更新，你需要用setFieldsValue来更新。initialValues只在form初始化时生效且只生效一次，如果你需要异步加载推荐使用request，或者initialValues ? <Form/> : null因为ProComponent使用了较新的 css 属性，会导致在低版本浏览器无法达到预设的兼容效果（即使项目配置了 polyfill）。因此，需要进行一些额外的兼容性配置：按这个文档配置https://ant.design/docs/react/compatible-style-cn如果是 umi 项目，可以在 app.ts 中配置：import {  StyleProvider,  legacyLogicalPropertiesTransformer,} from '@ant-design/cssinjs';export function rootContainer(container: React.ReactElement) {  return React.createElement(    StyleProvider,    {      hashPriority: 'high',      transformers: [legacyLogicalPropertiesTransformer],    },    container,  );}这里是一些你在使用 ProComponents 的过程中可能会遇到的错误和警告，但是其中一些并不是 ProComponents 的 bug。请确保 antd 的版本 >=4.11.1"
  },
  {
    "path": "",
    "key": "docs/index",
    "text": "ProComponents 是一个基于 React 的企业级 UI 组件库，它具有以下优点：丰富的组件库：ProComponents 提供了大量的 UI 组件，包括表格、表单、图表、地图、树形控件等，能够满足大多数企业应用的需求。功能强大：ProComponents 的组件不仅提供了基本的 UI 展示功能，还具备了复杂的数据操作和业务逻辑处理能力，能够快速构建出功能强大的企业应用。易于使用：ProComponents 提供了简单易用的 API 和完善的文档，使得开发者能够快速上手并使用其中的组件。支持可视化配置：ProComponents 提供了一些组件的可视化配置工具，能够使开发者更快速地完成一些简单的组件配置工作。高度可定制：ProComponents 的组件支持多种配置和样式自定义，能够满足不同项目的需求。总之，ProComponents 是一个功能丰富、易于使用、支持可视化配置和高度可定制的企业级 UI 组件库，适用于各种规模和类型的企业应用开发。ProComponents 是一个基于 React 和 Ant Design 的组件库，它提供了很多常用的 UI 组件和业务组件，可以方便地帮助开发者快速搭建前端页面。虽然 ProComponents 具有很多优点，但是也有以下一些缺点：学习成本高：ProComponents 的组件库非常庞大，学习所有组件可能需要花费较长时间。因此，对于新手开发者来说，学习成本可能会比较高。样式定制难度大：ProComponents 组件库提供了很多可定制的属性，但是如果需要修改样式的话，可能需要较高的 CSS 技能水平，因为 Ant Design 的样式风格非常复杂，需要深入了解其样式系统才能进行定制。依赖项过多：ProComponents 依赖了很多第三方库和组件，这可能会增加项目的体积和加载时间。不支持 IE8 及以下浏览器：由于 ProComponents 采用了现代化的技术栈，所以不支持 IE8 及以下的浏览器，这可能会影响一些用户的体验。组件更新不够及时：虽然 ProComponents 提供了很多常用组件，但是一些新的 UI 组件可能不会及时添加到组件库中。总之，ProComponents 是一个非常优秀的组件库，但是也有一些缺点，开发者需要根据自己的具体情况权衡其利弊。组件下载量版本pro-components现代浏览器ElectronEdgelast 2 versionslast 2 versionslast 2 versionslast 2 versions"
  },
  {
    "path": "components/card",
    "key": "components/card",
    "text": "页内容器卡片，提供标准卡片样式，卡片切分以及栅格布局能力。ProCard 创造性地将Col,Row,Card,Tabs等组件实现结合在一起，让你仅用一个组件就能够完成卡片相关的各种布局。如果你还需要结合图表一起使用，可以参考StatisticCard指标卡组件，他是 ProCard 的进一步封装。若您也需要封装ProCard，注意需要透出isProCard=true的静态属性让 ProCard 可以识别为同一个元素。需要一个标准卡片容纳内容时。需要多个卡片栅格，gutter 布局时。需要进行卡片内切分布局时。需要卡片可折叠时。布局模式下通过配置split可以方便地切分卡片，可以进行任意的分栏，不管是横切还是竖切都非常便利，切分出来的分栏仍然保有卡片的特性，高度自动撑满。注意：切分时父卡片的内容padding会被设置为 0。切分时子卡片的border-radius会被设置为 0。通过卡片切分能力我们很容易实现左右分栏的效果，很适合左侧是列表，右侧是详情的结构。通过卡片切分能力我们可以实现更加复杂的数据展现形式。栅格常常需要和间隔进行配合，你可以使用gutter属性，我们推荐使用(16+8n)px作为栅格间隔(n 是自然数)，如果要支持响应式，可以写成{ xs: 8, sm: 16, md: 24, lg: 32 }。如果需要垂直间距，可以写成数组形式[水平间距, 垂直间距][16, { xs: 8, sm: 16, md: 24, lg: 32 }]。默认卡片布局不可换行，你可以配置wrap为true来让多个卡片之间可以换行，适用于多个卡片排版的情况。你可以嵌套卡片组件来将内容分组, 以及Divider子组件来分隔这些内容。当添加分隔线时会自动增加标题的高度与内容区域分开。你可以使用collapsible来配置卡片是否可折叠，通过defaultCollapsed属性配置是否默认折叠。或者你可以通过collapsed属性受控进行自定义。配合ghost幽灵模式和可折叠能力可以实现卡片组展开。配置layout属性为center控制内容垂直居中，设置居中时内容部分转为flex布局，可以使用direction控制flex方向。配置loading属性为true控制卡片加载中，也可以传入 DOM 给loading来自定义 loading 展示。配置actions属性来配置卡片操作项。头部没有内容时会自动隐藏。配置bordered属性控制是否卡片带边框。配置tabs属性配合ProCard.TabPane子组件可以配置卡片的标签栏。配置tab的type为card来配置卡片式页签。可以放在卡片内部，展示多层级结构的信息。Steps组件结合ProCard组件完成竖向步骤示例。参数说明类型默认值版本title标题React.ReactNode-subTitle副标题React.ReactNode-tooltip标题右侧图标 hover 提示信息string-headStyle标题的 style 样式CSSProperties-bodyStyle内容区的 style 样式CSSProperties-extra右上角自定义区域React.ReactNode-layout内容布局，支持垂直居中default|centerdefaultloading加载中，支持自定义 loading 样式boolean|ReactNodefalsecolSpan栅格布局宽度，24 栅格，支持指定宽度 px 或百分比, 支持响应式的对象写法{ xs: 8, sm: 16, md: 24}, 仅在嵌套的子卡片上设置有效。number|string24gutter数字或使用数组形式同时设置 [水平间距, 垂直间距], 支持响应式的对象写法{ xs: 8, sm: 16, md: 24}number|array0split拆分卡片的方向vertical|horizontal-type卡片类型inner|default-size卡片尺寸default|small-actions卡片操作组，位置在卡片底部Array&lt;ReactNode>-direction指定 Flex 方向，仅在嵌套子卡片时有效，默认方向为 row 横向column-wrap是否支持换行，仅在嵌套子卡片时有效false-1.12.0bordered是否有边框booleanfalseghost幽灵模式，即是否取消卡片内容区域的 padding 和 卡片的背景颜色。booleanfalseheaderBordered页头是否有分割线booleanfalsecollapsed受控属性，是否折叠booleanfalsecollapsible配置是否可折叠，受控时无效booleanfalsecollapsibleIconRender替换默认折叠图标({ collapsed }: { collapsed: boolean }) => React.ReactNode-defaultCollapsed默认折叠, 受控时无效booleanfalseonCollapse收起卡片的事件，受控时无效(collapsed: boolean) => void-tabs标签页配置见下面 ProCardTabs-参数说明类型默认值activeKey当前选中项string-type页签的基本样式，可选line、card、editable-card类型stringinlineonChange回调(activeKey: string) => void;-items基于 antd 拓展的页签的基本配置，必填ItemsProps-更多属性见 antdTabAPI 描述。支持Tabs下页签的所有属性。参数说明类型默认值cardPropsProCard 卡片属性透传ProCard-该参数即将被 Items 所平替，请及时更新使用 ItemsProps 配置新的内容参数说明类型默认值key对应 activeKey，用于标定是否选中和 dom 更新，一定不要重复，不然会造成表现异常string-tab选项卡头显示文字ReactNode-disabled不可用booleanfalsecardPropsProCard 卡片属性透传ProCard-用于在将内容进行分组时进行分隔。参数说明类型默认值type分隔类型horizontal | vertical-属性同 ProCard，会取消卡片内容边距，用于将多个卡片进行分组。"
  },
  {
    "path": "components/check-card",
    "key": "components/CheckCard/index",
    "text": "集合多种相关联说明信息，并且可被选择的卡片。特点：① 可容纳多种相关联说明信息，如标题、描述、图片、标签等② 有明显边界③ 有明显选中态需要展示被选择对象的多种说明信息时被选择对象的数量不多时最常用的选项卡示例，包括头像，标题，描述等部分，可被选择。配置size尺寸大小，当前可选large，default，small，不同尺寸仅宽度不同。当然你也可以通过style或className自定义卡片大小。CheckCard 可以和表单组件一起使用，这里给出演示示例。头像，标题，描述区域可以自由组合或者单独呈现，组件会为你调整为最合适的对齐方式。你可以通过avatar属性自定义头像区域。你可以通过title属性自定义标题区域。描述区域可通过description自定义 React 节点。通过配置defaultChecked属性为true来配置选项默认被选中。配置extra为卡片添加操作栏。通过配置loading属性为true来配置内容在加载中。通过仅仅配置cover属性可以让你的选项成为一个纯图片选项。通过配置disabled属性配置选项不可用。CheckCard.Group支持通过options属性配置化来列表展示多个选项。这里展示在实际 AiDesk 中图像算法选择的使用示例。CheckCard.Group内嵌CheckCard并与Grid组件一起使用，可以实现更灵活的布局。参数说明类型默认值版本checked指定当前是否选中booleanfalsebordered是否显示边框booleantrue1.20.0value选项值string-defaultChecked初始是否选中booleanfalsedisabled失效状态booleanfalsesize选择框大小，可选largesmallstringdefaultonChange变化时回调函数Function(checked)-loading当卡片内容还在加载中时，可以用 loading 展示一个占位booleanfalsetitle标题string | ReactNode-description描述ReactNode-avatar选项元素的图片地址link | ReactNode-extra动作区域卡片右上角的操作区域-cover卡片背景图片, 注意使用该选项后title，description和avatar失效ReactNode-参数说明类型默认值版本multiple多选booleanfalsebordered是否显示边框booleantrue1.20.0defaultValue默认选中的选项string | string[]-disabled整组失效booleanfalseloading当卡片组内容还在加载中时，可以用 loading 展示一个占位booleanfalseoptions指定可选项string[] | Array<{ title: ReactNode, value: string, description?: ReactNode, avatar?: link or ReactNode, cover?:ReactNode, disabled?: boolean }>[]value指定选中的选项string | string[]-size选择框大小，可选largesmallstringdefaultonChange变化时回调函数Function(checkedValue)-"
  },
  {
    "path": "components/statistic-card",
    "key": "components/StatisticCard/index",
    "text": "指标卡结合统计数值用于展示某主题的核心指标，结合Ant Design Charts图表库丰富数值内容，满足大多数数值展示的场景。注意 demo 中的所有图表示例可以到 charts 的官网中找到，这里不再给出实际代码示例，仅以图片进行代替，所以相关交互是没有的。若有内容撑开卡片的情况请设置内容宽度为 100% 或设置定宽。1）在页面内的重要位置，展示重要信息；2）在概览页面展示系统功能。使用数值统计配置statistic和chart完成基本的指标卡。当图表单独展示在卡片中时。footer用于设置额外的指标展示区域。你可以设置Statistic组件的布局方式layout为horizontal来展示横向指标。你可以嵌套指标卡组件来将指标分组, 以及Divider子组件来分隔这些指标。Operation可以接受子元素，借此可以实现各种各样的公式计算指标。你可以给每个数值统计配置status展示其状态。你可以给每个数值统计配置icon展示其图标。配合ProCard的卡片切分能力可以实现复杂的卡片布局。配置chartPlacement为right可以指定图表在数值统计的右边。默认为上下结构。配置chartPlacement为left可以指定图表在数值统计的左边。结合Statistic可以实现带指标统计的页签。你可以使用Statistic组件配置布局layout为inline以及trend来展示环比趋势。参数说明类型默认值title卡片标题string|ReactNode-extra卡片右上角的操作区域string|ReactNode-loading当卡片内容还在加载中时，可以用 loading 展示一个占位booleanfalsebordered是否有边框booleantruechart图表卡片ReactNode-statistic数值统计配置，布局默认为vertical参数见下 Statistic-chartPlacement图表位置，相对于 statistic 的位置left | right | bottom-footer额外指标展示ReactNode-更多参考ProCard，支持ProCard的所有 API。参数说明类型默认值prefix设置数值的前缀string | ReactNode-suffix设置数值的后缀string | ReactNode-title数值的标题string | ReactNode-tip标题提示string| ReactNode-value数值内容string | number-icon图标ReactNode-status设置状态点, 同 Badge 组件Enum{ 'success', 'processing, 'default', 'error', 'warning' }-valueStyle设置数值的样式style-description描述性标签React.ReactNode | () => React.ReactNode-layout布局horizontal | vertical | inlineinlinetrend趋势up | down |-更多 API 参考Statistic，支持Statistic的所有 API。用于在将数值统计进行分组时进行分隔。参数说明类型默认值type分隔类型horizontal | vertical-用于操作符渲染。属性同StatisticCard，会取消卡片内容边距，用于将多个卡片进行分组。"
  },
  {
    "path": "components/descriptions",
    "key": "components/descriptions",
    "text": "高级描述列表组件，提供一个更加方便快速的方案来构建描述列表。ProDescriptions 的诞生是为了解决项目中需要写很多 Descriptions 的样板代码的问题，所以在其中做了封装了很多常用的逻辑。在 React 中写一个 Descriptions 免不了需要定义一些雷同的属性。所以 ProDescriptions 默认封装了请求网络，columns 列展示的逻辑。比如 ProDescriptions 封装了请求网络的行为，ProDescriptions 会将 props.params 中的数据默认带入到请求中，如果接口恰好与我们的定义相同，实现一个查询会非常简单。import request from 'umi-request';const fetchData = (params) =>  request<{    data: T{};  }>('https://proapi.azurewebsites.net/github/issues', {    params,  });const keyWords = \"Ant Design\"<ProDescriptions<T,U> request={fetchData} />;我们约定 request 拥有一个参数，params会自带 props 中的params。类型如下:(params: U) => RequestData;对与请求回来的结果的 ProDescriptions 也有一些约定，类型如下：interface RequestData {  data: Datum{};  success: boolean;}根据配置格式化日期通过请求接口数据来展示定义列表通过请求接口数据和 columns 来展示定义列表ProDescriptions 支持了和 Table 相同的 dataSourceAPI 与 ProTable 相同更多功能查看 antd 的Descriptions参数说明类型默认值title描述列表的标题，显示在最顶部ReactNode-tooltip内容的补充描述，hover 后显示string-loading展示一个加载的骨架屏，骨架屏和 dom 不会一一对应boolean-extra描述列表的操作区域，显示在右上方string|ReactNode-bordered是否展示边框booleanfalsecolumn一行的ProDescriptionsItems数量，可以写成像素值或支持响应式的对象写法{ xs: 1, sm: 2, md: 3}number3size设置列表的大小。可以设置为middle、small, 或不填（只有设置bordered={true}生效）default|middle|small-layout描述布局horizontal|verticalhorizontalcolon配置ProDescriptions.Item的colon的默认值booleantruerequest请求数据，不设置 columns 时 ProDescriptions.Item 需设置对应的 dataIndex--onRequestError处理 request 的错误，默认会直接抛出错误--columns列定义，与 request 配合使用columns--editable编辑的相关配置EditableConfig-属性描述类型默认值form可编辑表格的 form 实例，使用Form.useForm生成后使用FormInstance-formProps可以配置 form 的属性，但是不支持 onFinishFormProps-editableKeys正在编辑的行，受控属性。 默认key会使用rowKey的配置，如果没有配置会使用index，建议使用 rowKeyKey[]-onChange行数据被修改的时候触发(editableKeys: Key[], editableRows: T[]) => void-onSave保存一行的时候触发(key: Key, row: T,originRow:T,newLine?:newLineConfig) => Promise<any>-saveText保存一行的文字React.ReactNode保存onDelete删除一行的时候触发(key: Key, row: T) => Promise<any>-deleteText删除一行的文字React.ReactNode删除onCancel取消编辑一行时触发(key: Key, row: T,originRow:T,newLine?:newLineConfig) => Promise<any>-cancelText取消编辑一行的文字React.ReactNode取消actionRender自定义编辑模式的操作栏(row: T, config: ActionRenderConfig,defaultDom) => ReactNode[]-deletePopconfirmMessage删除时弹出的确认框提示消息ReactNode删除此行？onlyOneLineEditorAlertMessage只能编辑一行的的提示ReactNode只能同时编辑一行onlyAddOneLineAlertMessage只能同时新增一行的提示ReactNode只能新增一行参数说明类型默认值label内容的描述ReactNode-tooltip内容的补充描述，hover 后显示string-ellipsis是否自动缩略boolean-copyable是否支持复制boolean-span包含列的数量number1valueType格式化的类型ValueType-valueEnum当前列值的枚举valueEnumRecord-request从网络请求枚举数据()=>Promise<{[key:string|number]:any}>-dataIndex返回数据的 key 与 ProDescriptions 的 request 配合使用，用于配置式的定义列表React.Text|React.Text[]-editable在编辑表格中是否可编辑的，函数的参数和 table 的 render 一样false|(text: any, record: T,index: number) => booleantruespan 是 Description.Item 的数量。 span={2} 会占用两个 DescriptionItem 的宽度。在进行了操作，或者 tab 切换等时候我们需要手动触发一下描述列表的更新，纯粹的 props 很难解决这个问题，所以我们提供一个 ref 来支持一些默认的操作。const ref = useRef<ActionType>();// 两秒刷新一次useEffect(() => {  setInterval(() => {    ref.current.reload();  }, 2000);}, []);// hooks 绑定<ProDescriptions actionRef={ref} />;// class<ProDescriptions actionRef={(ref) => (this.ref = ref)} />;ActionRef还支持了一些别的行为,某些时候会减少的你的编码成本，但是 ref 会脱离 react 的生命周期，所以这些 action 都是不受控的。// 刷新ref.current.reload();"
  },
  {
    "path": "components/field",
    "key": "components/field",
    "text": "该组件为内部组件，请勿直接使用。原子信息组件，统一 ProForm、ProTable、ProList、Filter 等组件里面的字段定义。import Field from '@ant-design/pro-field';return <Field text=\"100\" valueType=\"money\" mode={state} />;参数说明类型默认值text需要格式化的值any-valueType格式化的类型ValueType-mode组件的模式--plain精简模式--renderFormItem自定义mode=update | edit下的 dom 表现，一般用于渲染编辑框--render自定义mode=read下的 dom 表现，只是单纯的表现形式--"
  },
  {
    "path": "components/dependency",
    "key": "components/Dependency/index",
    "text": "Form 中的数据联动非常常见，所以我们封装了一个组件来进行数据处理。ProFormDependency 是一个简化版本的 Form.Item，它默认内置了 noStyle 与 shouldUpdate，我们只需要配置 name 来确定我们依赖哪个数据，ProFormDependency 会自动处理 diff 和并且从表单中提取相应的值。name 参数必须要是一个数组，如果是嵌套的结构可以这样配置name={['name', ['name2', 'text']]}。配置的 name 的值会在 renderProps 中传入。name={['name', ['name2', 'text']]}传入的 values 的值 为{ name: string,name2: { text:string } }。<ProFormDependency name={['name']}>  {({ name }) => {    return (      <ProFormSelect        options={[          {            value: 'chapter',            label: '盖章后生效',          },        ]}        width=\"md\"        name=\"useMode\"        label={`与《${name}》合同约定生效方式`}      />    );  }}</ProFormDependency>下面例子演示了不同情形下的依赖取值顺序：<ProFormDependency>不在<ProFormList>中：根据name声明的依赖项，从全局取值（情形 1）<ProFormDependency>在<ProFormList>中<ProFormDependency>的ignoreFormListField为true：根据name声明的依赖项，从全局取值（情形 2）<ProFormDependency>的ignoreFormListField为false：根据name声明的依赖项，从局部取值（情形 3）"
  },
  {
    "path": "components/field-set",
    "key": "components/FieldSet/index",
    "text": "一个表单除了 Form 之外还是需要一系列的表单项，ProForm 自带了数量可观的表单项, 这些组件本质上是 Form.Item 和 组件的结合，我们可以把他们当成一个 FormItem 来使用，并且支持各种props。每个表单项都支持fieldProps属性来支持设置输入组件的props。 我们支持了placeholder的透传，你可以直接在组件上设置placeholder。每个表单项同时也支持了readonly，不同的组件会有不同的只读样式，与disable相比readonly展示更加友好。生成的 dom 也更小，比如 ProFormDigit 会自动格式化小数位数。ProFormText 是 FormItem + Input 的产物，可以类比于以下的代码：const ProFormText = (props) => {  return (    <ProForm.Item {...props}>      <Input placeholder={props.placeholder} {...props.fieldProps} />    </ProForm.Item>  );};所以我们给 ProFormText 设置的 props 其实是 Form.Item 的，fieldProps 才是包含的组件的，要切记。组件使用场景ProFormText用于输入各类文本ProFormDigit用于输入数字，它自带了一个格式化(保留 2 位小数，最小值为 0)，有需要你可以关掉它。ProFormText.Password用于输入密码ProFormTextArea用于输入多行文本ProFormCaptcha用于输入验证码， 一般需要与发送验证码接口一起使用ProFormDatePicker日期选择器用于输入日期ProFormDateTimePicker日期+时间选择器，用于输入日期和时间ProFormDateRangePicker日期区间选择器用于输入一个日期区间ProFormDateTimeRangePicker日期+时间区间选择器，用于输入一个日期+时间的区间ProFormSelect支持request和valueEnum两种方式来生成子项，用于从两项以上中选择一项ProFormTreeSelect支持request和valueEnum两种方式来生成子项，用于从两项以上中选择一项ProFormCheckbox在 Checkbox 基础上支持了 layout，也支持request和valueEnum两种方式来生成子项ProFormRadio.Group在 Radio 基础上也支持request和valueEnum两种方式来生成子项，用于单选某项，但是可以展示出来所有选项。ProFormSlider当用户需要在数值区间/自定义区间内进行选择时，可为连续或离散值。ProFormSwitch用于输入互斥的两个选项，一般是 true 和 falseProFormUploadButton按钮样式的上传文件ProFormUploadDragger区域的上传文件，一般用于突出上传文件的表单中ProFormMoney通用金额输入组件ProFormSegmented分段控制器ProForm 自带的 Filed ,与 valueType 基本上一一对应。参数说明类型默认值widthField 的长度，我们归纳了常用的 Field 长度以及适合的场景，支持了一些枚举 \"xs\" , \"sm\" , \"md\" ,\"lg\" , \"xl\"number | \"xs\" | \"sm\" | \"md\" | \"lg\" | \"xl\"-rowPropsRowProps开启grid模式时传递给 Row, 仅在ProFormGroup,ProFormList,ProFormFieldSet中有效{ gutter: 8 }colPropsColProps开启grid模式时传递给 Col{ xs: 24 }tooltip会在 label 旁增加一个 icon，悬浮后展示配置的信息string | tooltipProps-secondary是否是次要控件，只针对 LightFilter 下有效booleanfalseallowClear支持清除，针对 LightFilter 下有效，主动设置情况下同时也会透传给fieldPropsbooleantrue在某些场景下，我们需要根据页面展示效果对输入框进行自适应处理，除此以外一个表单区域应默认使用定宽规则。XS=104px适用于短数字、短文本或选项。SM=216px适用于较短字段录入、如姓名、电话、ID 等。MD=328px标准宽度，适用于大部分字段长度。LG=440px适用于较长字段录入，如长网址、标签组、文件路径等。XL=552px适用于长文本录入，如长链接、描述、备注等，通常搭配自适应多行输入框或定高文本域使用。与Input相同。<ProFormText  name=\"text\"  label=\"名称\"  placeholder=\"请输入名称\"  fieldProps={inputProps}/>ProFormCaptcha 是为了支持中后台中常见的验证码功能开发的组件。<ProFormCaptcha  fieldProps={{    size: 'large',    prefix: <MailTwoTone />,  }}  captchaProps={{    size: 'large',  }}  // 手机号的 name，onGetCaptcha 会注入这个值  phoneName=\"phone\"  name=\"captcha\"  rules={[    {      required: true,      message: '请输入验证码',    },  ]}  placeholder=\"请输入验证码\"  // 如果需要失败可以 throw 一个错误出来，onGetCaptcha 会自动停止  // throw new Error(\"获取验证码错误\")  onGetCaptcha={async (phone) => {    await waitTime(1000);    message.success(`手机号 ${phone} 验证码发送成功!`);  }}/>参数说明类型默认值onGetCaptcha点击获取验证码的事件，如果配置了 phoneName 会自动注入(phone)=>Promise<any>-captchaProps获取验证码按钮的 props，与 antd 的 props 相同ButtonProps-countDown倒计时的秒数number60captchaTextRender渲染计时的文案(timing: boolean, count: number) => React.ReactNode-与Input.Password相同。<ProFormText.Password label=\"InputPassword\" name=\"input-password\" />与Input.TextArea相同。<ProFormTextArea  name=\"text\"  label=\"名称\"  placeholder=\"请输入名称\"  fieldProps={inputTextAreaProps}/>与inputNumber相同。它自带了一个格式化(保留 2 位小数，最小值为 0)，有需要你可以关掉它。<ProFormDigit label=\"InputNumber\" name=\"input-number\" min={1} max={10} />如果要修改小数位数：<ProFormDigit  label=\"InputNumber\"  name=\"input-number\"  min={1}  max={10}  fieldProps={{ precision: 0 }}/>与inputNumber类似。 它提供输入数字范围。<ProFormDigitRange label=\"InputNumberRange\" name=\"input-number-range\" />与DatePicker相同。<ProFormDatePicker name=\"date\" label=\"日期\" />与DatePicker相同。<ProFormDateTimePicker name=\"datetime\" label=\"日期时间\" />与DatePicker.RangePicker相同。<ProFormDateRangePicker name=\"dateRange\" label=\"日期\" />与DatePicker.RangePicker相同。<ProFormDateTimeRangePicker name=\"datetimeRange\" label=\"日期时间\" />与DatePicker相同<ProFormTimePicker name=\"time\" label=\"时间\" /><ProFormTimePicker.RangePicker name=\"timeRange\" label=\"时间区间\" />与select相同。支持了 request 和 valueEnum 两种方式来生成 options。请求远程数据比较复杂，详细可以看这里。参数说明类型默认值valueEnum当前列值的枚举valueEnumRecord-request从网络请求枚举数据()=>Promise<{label,value}>-debounceTime防抖动时间，与 request 配合使用number-params发起网络请求的参数,与 request 配合使用Record-fieldPropsantd 组件的 propsSelectProps-有了 options 为什么要支持 valueEnum 呢？ valueEnum 可以与 table，descriptions 共用，在工程化上有优势。<>  <ProFormSelect    name=\"select\"    label=\"Select\"    valueEnum={{      open: '未解决',      closed: '已解决',    }}    placeholder=\"Please select a country\"    rules={[{ required: true, message: 'Please select your country!' }]}  />  <ProFormSelect    name=\"select2\"    label=\"Select\"    request={async () => [      { label: '全部', value: 'all' },      { label: '未解决', value: 'open' },      { label: '已解决', value: 'closed' },      { label: '解决中', value: 'processing' },    ]}    placeholder=\"Please select a country\"    rules={[{ required: true, message: 'Please select your country!' }]}  /></>联动的 ProFormSelect<ProFormText name=\"name\" label=\"姓名\" />  <ProFormSelect    name=\"addr\"    width=\"md\"    label=\"与 name 联动的选择器\"    // dependencies 的内容会注入 request 中    dependencies={['name']}    request={async (params) => [      { label: params.name, value: 'all' },      { label: 'Unresolved', value: 'open' },      { label: 'Resolved', value: 'closed' },      { label: 'Resolving', value: 'processing' },    ]}  />```自定义选项：```tsx | pure<ProFormSelect  name=\"select\"  label=\"Select\"  options={[    { label: '全部', value: 'all' },    { label: '未解决', value: 'open' },    { label: '已解决', value: 'closed' },    { label: '解决中', value: 'processing' },  ]}  fieldProps={{    optionItemRender(item) {      return item.label + ' - ' + item.value;    },  }}  placeholder=\"Please select a country\"  rules={[{ required: true, message: 'Please select your country!' }]}/>与tree-select相同。支持了 request 和 valueEnum 两种方式来生成 options。请求远程数据比较复杂，详细可以看这里。参数说明类型默认值valueEnum当前列值的枚举valueEnumRecord-request从网络请求枚举数据()=>Promise<{label,value}>-debounceTime防抖动时间，与 request 配合使用number-params发起网络请求的参数,与 request 配合使用Record-fieldPropsantd 组件的 propsTreeSelectProps-有了 options 为什么要支持 valueEnum 呢？ valueEnum 可以与 table，descriptions 共用，在工程化上有优势。<ProFormTreeSelect  name=\"name\"  placeholder=\"Please select\"  allowClear  width={330}  secondary  request={async () => {    return [      {        title: 'Node1',        value: '0-0',        children: [          {            title: 'Child Node1',            value: '0-0-0',          },        ],      },      {        title: 'Node2',        value: '0-1',        children: [          {            title: 'Child Node3',            value: '0-1-0',          },          {            title: 'Child Node4',            value: '0-1-1',          },          {            title: 'Child Node5',            value: '0-1-2',          },        ],      },    ];  }}  // tree-select args  fieldProps={{    showArrow: false,    filterTreeNode: true,    showSearch: true,    popupMatchSelectWidth: false,    labelInValue: true,    autoClearSearchValue: true,    multiple: true,    treeNodeFilterProp: 'title',    fieldNames: {      label: 'title',    },  }}/>请求远程数据比较复杂，详细可以看这里。与checkbox相同，但是支持了options与layout。参数说明类型默认值options与 select 相同，根据 options 生成子节点，推荐使用。string[]|{label:ReactNode,value:string}[]-layout配置 checkbox 的样子，支持垂直vertical和horizontalhorizontal|vertical-request从网络请求枚举数据()=>Promise<{label,value}>-params发起网络请求的参数,与 request 配合使用Record-fieldPropsantd 组件的 propsCheckboxProps-<ProFormCheckbox.Group  name=\"checkbox\"  layout=\"vertical\"  label=\"行业分布\"  options={['农业', '制造业', '互联网']}/>请求远程数据比较复杂，详细可以看这里。与radio相同，但是支持了options。参数说明类型默认值options与 select 相同，根据 options 生成子节点，推荐使用。string[]|{label:ReactNode,value:string}[]-request从网络请求枚举数据()=>Promise<{label,value}>-radioType设置是按钮模式还是 radio 模式default|buttondefaultparams发起网络请求的参数,与 request 配合使用Record-fieldPropsantd 组件的 propsRadioProps-<ProFormRadio.Group  name=\"radio-group\"  label=\"Radio.Group\"  options={[    {      label: 'item 1',      value: 'a',    },    {      label: 'item 2',      value: 'b',    },    {      label: 'item 3',      value: 'c',    },  ]}/>与cascader相同，通过 filedProps 配置 cascader 的数据。请求远程数据比较复杂，详细可以看这里。<ProFormCascader  name=\"area\"  label=\"区域\"  fieldProps={{    options: [      {        value: 'zhejiang',        label: 'Zhejiang',        children: [          {            value: 'hangzhou',            label: 'Hangzhou',            children: [              {                value: 'xihu',                label: 'West Lake',              },            ],          },        ],      },    ],  }}/>参数说明类型默认值options与 cascader 相同，根据 options 生成子节点，推荐使用。string[]|{label:ReactNode,value:string}[]-request从网络请求枚举数据()=>Promise<{label,value}>-params发起网络请求的参数,与 request 配合使用Record-fieldPropsantd 组件的 propsCascaderProps-与switch相同，通过 filedProps 配置 switch 的数据。参数说明类型默认值fieldPropsantd 组件的 propsSwitchProps-<ProFormSwitch name=\"switch\" label=\"Switch\" />参数说明类型默认值fieldPropsantd 组件的 propsRateProps-与rate相同，通过 filedProps 配置 rate 的数据。<ProFormRate name=\"rate\" label=\"Rate\" />与slider相同，通过 filedProps 配置 slider 的数据。参数说明类型默认值fieldPropsantd 组件的 propsSliderProps-<ProFormSlider  name=\"slider\"  label=\"Slider\"  marks={{    0: 'A',    20: 'B',    40: 'C',    60: 'D',    80: 'E',    100: 'F',  }}/>与upload相同。预设了 Dragger 的样式，其他与 Upload 相同。参数说明类型默认值iconDragger 的图标ReactNodeInboxOutlinedtitleDragger 的标题ReactNode'单击或拖动文件到此区域进行上传'descriptionDragger 的描述ReactNode'支持单次或批量上传'<ProFormUploadDragger label=\"Dragger\" name=\"dragger\" action=\"upload.do\" />与upload相同。预设了 Button 的样式，其他与 Upload 相同。参数说明类型默认值iconButton 的图标ReactNodeUploadOutlinedtitleButton 的标题ReactNode单击上传max最大上传数量, 超过最大数量就会隐藏上传按钮number-<ProFormUploadButton label=\"upload\" name=\"upload\" action=\"upload.do\" />ProFormMoney 用于输入金额的输入框，支持根据全局国际化显示货币符号，支持输入负数、支持自定义货币符号等<ProFormMoney  label=\"限制金额最小为0\"  name=\"amount1\"  locale=\"en-US\"  initialValue={22.22}  min={0}/><ProFormMoney  label=\"不限制金额大小\"  name=\"amount2\"  locale=\"en-GB\"  initialValue={22.22}/><ProFormMoney  label=\"货币符号跟随全局国际化\"  name=\"amount3\"  initialValue={22.22}/><ProFormMoney  label=\"自定义货币符号\"  name=\"amount4\"  initialValue={22.22}  customSymbol=\"💰\"/>参数说明类型默认值locale单独设置的国际化地区值，根据不同的地区显示不同的货币符号，支持地区详见下面的地区目录stringzh-Hans-CNcustomSymbol自定义金额符号string-numberPopoverRender自定义 Popover 的值，false 可以关闭他((props: InputNumberProps, defaultText: string) => React.ReactNode)|booleanfalsenumberFormatOptionsNumberFormat 的配置，文档可以查看mdnNumberFormatOptions-min最小值number-max最大值number-{\"ar-EG\": \"$\",\"zh-CN\": \"¥\",\"en-US\": \"$\",\"en-GB\": \"£\",\"vi-VN\": \"₫\",\"it-IT\": \"€\",\"ja-JP\": \"¥\",\"es-ES\": \"€\",\"ru-RU\": \"₽\",\"sr-RS\": \"RSD\",\"ms-MY\": \"RM\",\"zh-TW\": \"NT$\"\"fr-FR\": \"€\",\"pt-BR\": \"R$\",\"ko-KR\": \"₩\",\"id-ID\": \"RP\",\"de-DE\": \"€\",\"fa-IR\": \"تومان\",\"tr-TR\": \"₺\",\"pl-PL\": \"zł\",\"hr-HR\": \"kn\",}antd 版本需要 >= antd@4.20.0与Segmented相同。支持了 request 和 valueEnum 两种方式来生成 options。请求远程数据比较复杂，详细可以看这里。参数说明类型默认值valueEnum当前列值的枚举valueEnumRecord-request从网络请求枚举数据()=>Promise<{label,value}>-debounceTime防抖动时间，与 request 配合使用number-params发起网络请求的参数,与 request 配合使用Record-fieldPropsantd 组件的 propsSegmented-有了 options 为什么要支持 valueEnum 呢？ valueEnum 可以与 table，descriptions 共用，在工程化上有优势。<>  <ProFormSegmented    name=\"segmented\"    label=\"segmented\"    valueEnum={{      open: '未解决',      closed: '已解决',    }}    rules={[{ required: true, message: 'Please select your country!' }]}  />  <ProFormSegmented    name=\"segmented\"    label=\"segmented\"    request={async () => [      { label: '全部', value: 'all' },      { label: '未解决', value: 'open' },      { label: '已解决', value: 'closed' },      { label: '解决中', value: 'processing' },    ]}    rules={[{ required: true, message: 'Please select your country!' }]}  /></>"
  },
  {
    "path": "components/form",
    "key": "components/form",
    "text": "ProForm 在原来的 Form 的基础上增加一些语法糖和更多的布局设置，帮助我们快速的开发一个表单。同时添加一些默认行为，让我们的表单默认好用。分步表单，Modal 表单，Drawer 表单，查询表单，轻量筛选等多种 layout 可以覆盖大部分的使用场景，脱离复杂而且繁琐的表单布局工作，更少的代码完成更多的功能。如果你想要设置默认值，请使用initialValues,任何直接使用组件value和onChange的方式都有可能导致值绑定失效。如果想要表单联动或者做一些依赖，可以使用 render props 模式, ProFormDependency 绝对是最好的选择ProForm 的 onFinish 与 antd 的 Form 不同，是个 Promise，如果你正常返回会自动为你设置按钮的加载效果如果想要监听某个值，建议使用onValuesChange。保持单向的数据流无论对开发者还是维护者都大有裨益ProForm 没有黑科技，只是 antd 的 Form 的封装，如果要使用自定义的组件可以用 Form.Item 包裹后使用，支持混用// 设置整体默认值<ProForm initialValues={obj} />// 设置单个控件的<ProForm onValuesChange={(changeValues) => console.log(changeValues)}>  <ProFormText initialValue=\"prop\"/></ProForm>// 相互依赖的组件联动<ProForm>  <Form.Item noStyle shouldUpdate>    {(form) => {      return (        <ProFormSelect          options={[            {              value: \"chapter\",              label: \"盖章后生效\",            },          ]}          width=\"md\"          name=\"useMode\"          label={`与${form.getFieldValue(\"name\")}合同约定生效方式`}        />      );    }}  </Form.Item></ProForm>;// 使用自定义组件<ProForm>  <Form.Item name=\"switch\" label=\"Switch\" valuePropName=\"checked\">    <Switch />  </Form.Item></ProForm>当你想快速实现一个表单但不想花太多时间去布局时 ProForm 是最好的选择。ProForm 是基于 antd Form 的可降级封装，与 antd 功能完全对齐，但是在其之上还增加一些预设行为和多种布局。这些布局之间可以无缝切换，并且拥有公共的 API。布局使用场景ProForm标准 Form，增加了onFinish中自动loading和 根据request自动获取默认值的功能。ModalForm|DrawerForm在 ProForm 的基础上增加了trigger，无需维护visible状态QueryFilter一般用于作为筛选表单，需要配合其他数据展示组件使用LightFilter一般用于作为行内内置的筛选，比如卡片操作栏和 表格操作栏。StepsForm分步表单，需要配置 StepForm 使用。很多时候组件需要的数据和后端需要的数据之间不能完全匹配，ProForm 为了解决这个问题提供了transform和convertValue两个 API 来处理这种情况。convertValue 发生在组件获得数据之前，一般是后端直接给前端的数据，有时需要精加工一下。export type SearchConvertKeyFn =    (value: any, field: NamePath)=>string | boolean | Record<string, any>;  /**   * @name 获取时转化值，一般用于将数据格式化为组件接收的格式   * @param value 字段的值   * @param namePath 字段的name   * @returns 字段新的值   *   * @example a,b => [a,b]   * convertValue:(value,namePath)=>value.split(\",\")   * @example string =>json   * convertValue:(value,namePath)=>JSON.parse(value)   * @example number =>date   * convertValue:(value,namePath)=>Moment(value)   * @example YYYY-MM-DD => date   * convertValue:(value,namePath)=>Moment(value,\"YYYY-MM-DD\")   * @example  string => object   * convertValue:(value,namePath)=>({value,label:value})   */  convertValue?: SearchConvertKeyFn;transform 发生在提交的时候，一般来说都是吐给后端的存在数据库里的数据。为了方便大家使用，ProFormDependency和formRef都支持了transform，可以获取到被转化后的值。<ProFormDependency>  {(value, form) => {    // value 被 transform转化之后的值    // form 当前的formRef，可以获取未转化的值    return ReactNode;  }}</ProFormDependency>formRef 内置了几个方法来获取转化之后的值，这也是相比 antd 的 Form 多的功能，详细可以看 ProFormInstance 的类型定义。/** 获取被 ProForm 格式化后的所有数据  */  getFieldsFormatValue?: (nameList?: true) => T;  /** 获取格式化之后的单个数据 */  getFieldFormatValue?: (nameList?: NamePath) => T;  /** 获取格式化之后的单个数据 */  getFieldFormatValueObject?: (nameList?: NamePath) => T;  /** 验字段后返回格式化之后的所有数据*/  validateFieldsReturnFormatValue?: (nameList?: NamePath[]) => Promise<T>;export type SearchTransformKeyFn = (    value: any,    namePath: string,    allValues: any,  ) => string | Record<string, any>;  /**   * @name 提交时转化值，一般用于将值转化为提交的数据   * @param value 字段的值   * @param namePath 字段的name   * @param allValues 所有的字段   * @returns 字段新的值，如果返回对象，会和所有值深度 merge 一次   *   * @example {name:[a,b] => {name:a,b }   * transform: (value,namePath,allValues)=> value.join(\",\")   * @example {name: string => { newName:string }   * transform: (value,namePath,allValues)=> { newName:value }   * @example {name:moment} => {name:string   * transform: (value,namePath,allValues)=> value.format(\"YYYY-MM-DD\")   * @example {name:moment}=> {name:时间戳}   * transform: (value,namePath,allValues)=> value.valueOf()   * @example {name:{value,label}} => { name:string}   * transform: (value,namePath,allValues)=> value.value   * @example {name:{value,label}} => { valueName,labelName  }   * transform: (value)=>{valueName:value.value,labelName:value.name}   */  transform?: SearchTransformKeyFn;除了LightFilter和QueryFilter这样固定布局的表单样式，其他表单布局支持配置与antd一致的三种布局方式。同时支持在ProForm,SchemaForm,ModalForm,DrawerForm,StepsForm中使用打开时也会把 url 的参数设置为默认值，支持 transform, 但是要注意字段的映射。ProForm 是 antd Form 的再封装，如果你想要自定义表单元素，ProForm 与 antd 的方法是相同的，你仍然可以用 FormItem + 自定义组件的方式来自定义。当然这样不会影响到别的组件，QueryFilter 等组件同理。antd 的 Form api 查看这里initialValues 相关知识查看这里参数说明类型默认值onFinish提交表单且数据验证成功后回调事件，同 antd 4Form组件 API(values)=>Promise<void>-onReset点击重置按钮的回调(e)=>void-submitter提交按钮相关配置boolean|SubmitterPropstruesyncToUrl同步参数到 url 上,url 只支持 string，在使用之前最好读一下url 中的参数类型true|(values,type)=>values-syncToInitialValues同步结果到 initialValues,默认为 true 如果为 false，form.reset 的时将会忽略从 url 上获取的数据booleantruedateFormatter自动格式数据,主要是 moment 的表单,支持 string 和 number 两种模式，此外还支持指定函数进行格式化。string| number | ((value: Moment, valueType: string) => string | number) | falsestringomitNilProForm 会自动清空 null 和 undefined 的数数据，如果你约定了 nil 代表某种数据，可以设置为 false 关闭此功能booleantrueparams发起网络请求的参数,与 request 配合使用Record-request发起网络请求的参数,返回值会覆盖给 initialValues(params)=>Promise<data>-isKeyPressSubmit是否使用回车提交boolean-formRef获取表单所使用的 formMutableRefObject<Instance<T>>-autoFocusFirstInput自动 focus 表单第一个输入框boolean-grid开启栅格化模式，宽度默认百分比，请使用colProps控制宽度查看示例boolean-rowProps开启grid模式时传递给Row, 仅在ProFormGroup,ProFormList,ProFormFieldSet中有效RowProps{ gutter: 8 }(...)注意LightFilter和QueryFilter仅支持除wrapperCol|labelCol|layout外的其他 antdForm组件参数--ProFormInstance 与 antd 的 form 相比增加了一些能力。/**   * 获取被 ProForm 格式化后的所有数据   * @param nameList boolean   * @returns T   *   * @example  getFieldsFormatValue() ->返回所有数据   * @example  getFieldsFormatValue(true) ->返回所有数据，即使没有被 form 托管的   */  getFieldsFormatValue?: (nameList?: true) => T;  /**   * 获取被 ProForm 格式化后的单个数据   * @param nameList (string|number)[]   * @returns T   * @example {a:{b:value}} -> getFieldFormatValue(['a', 'b']) -> value   */  /** 获取格式化之后的单个数据 */  getFieldFormatValue?: (nameList?: NamePath) => T;  /**   * 获取被 ProForm 格式化后的单个数据, 包含他的 name   * @param nameList (string|number)[]   * @returns T   * @example   * {a:{b:value}} -> getFieldFormatValueObject(['a', 'b']) -> {a:{b:value}}   */  getFieldFormatValueObject?: (nameList?: NamePath) => T;  /**   *验字段后返回格式化之后的所有数据   * @param nameList (string|number)[]   * @returns T   *   * @example validateFieldsReturnFormatValue -> {a:{b:value}}   */  validateFieldsReturnFormatValue?: (nameList?: NamePath[]) => Promise<T>;参数说明类型默认值title标题string-children表单控件或者其他元素React.ReactNode-虽然我们希望不要对 submitter 进行修改，但在使用中修改是很常见的需求，ProForm 的各个组件都使用了同样的 API 来支持需求。参数说明类型默认值onSubmit提交方法()=>void-onReset重置方法()=>void-searchConfig搜索的配置，一般用来配置文本{resetText,submitText}-submitButtonProps提交按钮的 propsButtonProps-resetButtonProps重置按钮的 propsButtonProps-render自定义操作的渲染false|(props,dom:JSX[])=>ReactNode[]-render 的第二个参数是默认的 dom 数组，第一个是重置按钮，第二个是提交按钮。<ProForm  submitter={{    // 配置按钮文本    searchConfig: {      resetText: '重置',      submitText: '提交',    },    // 配置按钮的属性    resetButtonProps: {      style: {        // 隐藏重置按钮        display: 'none',      },    },    submitButtonProps: {},    // 完全自定义整个区域    render: (props, doms) => {      console.log(props);      return [        <button          type=\"button\"          key=\"rest\"          onClick={() => props.form?.resetFields()}        >          重置        </button>,        <button          type=\"button\"          key=\"submit\"          onClick={() => props.form?.submit?.()}        >          提交        </button>,      ];    },  }}/>该属性是 ProForm 在原有的 Antd 的FormInstance的基础上做的一个上层分装，增加了一些更加便捷的方法。使用方式如下：import type { ProFormInstance } from '@ant-design/pro-components';import {  ProForm,  ProFormDatePicker,  ProFormText,} from '@ant-design/pro-components';import { Button, message } from 'antd';import moment from 'dayjs';import { useRef } from 'react';const waitTime = (time: number = 100) => {  return new Promise((resolve) => {    setTimeout(() => {      resolve(true);    }, time);  });};export default () => {  const formRef = useRef<ProFormInstance>();  const onFill = () => {    formRef?.current?.setFieldsValue({      name: '张三',      company: '蚂蚁金服',    });  };  const getCompanyName = () => {    message.info(`公司名称为 \"${formRef?.current?.getFieldValue('company')}\"`);  };  const getFormatValues = () => {    console.log(      '格式化后的所有数据：',      formRef.current?.getFieldsFormatValue?.(),    );  };  const validateAndGetFormatValue = async () => {    const values = await formRef.current?.validateFieldsReturnFormatValue?.();    console.log('校验表单并返回格式化后的所有数据：', values);  };  return (    <ProForm      title=\"新建表单\"      formRef={formRef}      submitter={{        render: (props, doms) => {          return [            ...doms,            <Button htmlType=\"button\" onClick={onFill} key=\"edit\">              一键填写            </Button>,            <Button htmlType=\"button\" onClick={getCompanyName} key=\"read\">              读取公司            </Button>,            <Button.Group key=\"refs\" style={{ display: 'block' }}>              <Button htmlType=\"button\" onClick={getFormatValues} key=\"format\">                获取格式化后的所有数据              </Button>              <Button                htmlType=\"button\"                onClick={validateAndGetFormatValue}                key=\"format2\"              >                校验表单并返回格式化后的所有数据              </Button>            </Button.Group>,          ];        },      }}      onFinish={async (values) => {        await waitTime(2000);        console.log(values);        message.success('提交成功');        return true;      }}    >      <ProFormText        width=\"md\"        name=\"name\"        label=\"签约客户名称\"        tooltip=\"最长为 24 位\"        placeholder=\"请输入名称\"      />      <ProFormText        width=\"md\"        name=\"company\"        label=\"我方公司名称\"        placeholder=\"请输入名称\"      />      <ProFormDatePicker name=\"date\" initialValue={moment('2021-08-09')} />    </ProForm>  );};ProFormInstance在原先FormInstance的基础上增加了如下方法：方法名使用描述备注getFieldsFormatValue使用方法与FormInstance的getFieldsValue方法相同，将返回格式化后的所有数据getFieldFormatValue使用方法与FormInstance的getFieldValue方法相同，将返回格式化后的指定数据validateFieldsReturnFormatValue使用方法与FormInstance的validateFields方法相同，验证通过后将返回格式化后的所有数据"
  },
  {
    "path": "components/group",
    "key": "components/Group/index",
    "text": "我们还提供了用来进行结构化数据的录入:ProFormList 录入结构化的多维数组数据。ProFormFieldSet 录入结构化的一维数组数据。ProFormDependency 数据依赖的相关组件ProFormList 与Form.ListAPI 基本相同，增加了自带的操作按钮：删除和复制，并且自带了了一个新建一行按钮。<ProFormList  name=\"users\"  initialValue={[    {      useMode: 'chapter',    },  ]}  creatorButtonProps={{    position: 'top',    creatorButtonText: '再建一行',  }}  creatorRecord={{    useMode: 'none',  }}>  <ProFormSelect    key=\"useMode\"    options={[      {        value: 'chapter',        label: '盖章后生效',      },      {        value: 'none',        label: '不生效',      },    ]}    width=\"md\"    name=\"useMode\"    label=\"合同约定生效方式\"  /></ProFormList>参数说明类型默认值itemRender自定义 Item，可以用来将 action 放到别的地方(doms,listMeta)=> ReactNode-creatorRecord新建一行的默认值Record<string, any> | () => Record<string, any>-creatorButtonProps新建一行按钮的配置buttonProps & { creatorButtonText:string,position:\"top\"|\"bottom\" }{creatorButtonText:\"新建一行\"}label与 From.Item 相同ReactNode-namelist 在 form 中的值，必填项NamePath-alwaysShowItemLabelItem 中总是展示 labelboolean-actionRef当前 List 的自带操作，可以增删改查列表项{add,remove,move,get}-actionGuardFormItem 的拦截器，包含删除和添加的拦截，可以用 actionRef 拿到当前行的值{beforeAddRow:(index)=>boolean,beforeRemoveRow:(index)=>boolean}-min最少条目，删除时如果当前数据条目少于该数则无法删除number-max最多条目，新增或复制时如果当前数据条目多于该数则无法新增或复制number-copyIconProps复制按钮的配置，false 可以取消{ Icon?: React.FC<any>; tooltipText?: string; } | false-deleteIconProps删除按钮的配置，false 可以取消{ Icon?: React.FC<any>; tooltipText?: string; } | false-actionRender自定义操作按钮(field,action,defaultActionDom,count)=>React.ReactNode[]-onAfterAdd新增数据后的钩子(defaultValue: StoreValue, insertIndex: number, count: number) => void-onAfterRemove删除数据后的钩子(index: number, count: number) => void-const actionRef = useRef<  FormListActionType<{    name: string;  }>>();return (  /**   * @name 获取到 list 操作实例   * @description 可用删除，新增，移动等操作   *   * @example  actionRef?.current.add?.({},1);   * @example  actionRef?.current.remove?.(1);   * @example  actionRef?.current.move?.(1,2);   * @example  actionRef?.current.get?.(1);   */  <>    <Space>      <Button        type=\"primary\"        onClick={() => {          const list = actionRef.current?.getList();          actionRef.current?.add({            name: '新增' + list?.length,          });        }}      >        增加一行      </Button>      <Button        danger        onClick={() => {          actionRef.current?.remove(1);        }}      >        删除一行      </Button>      <Button        onClick={() => {          actionRef.current?.move(1, 0);        }}      >        移动到第一行      </Button>      <Button        type=\"dashed\"        onClick={() => {          const row = actionRef.current?.get(1);          console.log(row);        }}      >        获取一行数据      </Button>      <Button        type=\"dashed\"        onClick={() => {          const row = actionRef.current?.getList();          console.log(row);        }}      >        获取所有数据      </Button>    </Space>    <ProFormList actionGuard={actionGuard} actionRef={actionRef}>      <ProFormText key=\"useMode\" name=\"name\" label=\"姓名\" />    </ProFormList>  </>);actionGuard 可以拦截 list 的操作，现在有beforeAddRow和beforeRemoveRow两个事件。const actionRef = useRef<  FormListActionType<{    name: string;  }>>();const actionGuard = {  beforeAddRow: async (defaultValue, insertIndex, count) => {    return new Promise((resolve) => {      console.log(defaultValue?.name, insertIndex, count);      setTimeout(() => resolve(true), 1000);    });  },  beforeRemoveRow: async (index, count) => {    const row = actionRef.current?.get(index as number);    console.log('--->', index, count, row);    return new Promise((resolve) => {      if (index === 0) {        resolve(false);        return;      }      setTimeout(() => resolve(true), 1000);    });  },};return (  <ProFormList actionGuard={actionGuard} actionRef={actionRef}>    <ProFormText key=\"useMode\" name=\"name\" label=\"姓名\" />  </ProFormList>);/**   * @name 自定义操作按钮   *   * @example 删除按钮   * actionRender:(field,action)=><a onClick={()=>action.remove(field.name)}>删除</a>   * @example 最多只能新增三行   * actionRender:(f,action,_,count)=><a onClick={()=>   *   count>2?alert(\"最多三行！\"):action.add({id:\"xx\"})}>删除   * </a>   */  actionRender?: (    field: FormListFieldData,    /**     * 操作能力     * @example  action.add(data) 新增一行     * @example  action.remove(index) 删除一行     * @example  action.move(formIndex,targetIndex) 移动一行     */    action: FormListOperation,    /**     * 默认的操作dom     * [复制，删除]     */    defaultActionDom: ReactNode[],    /**     * 当前共有几个列表项     */    count: number,  ) => ReactNode[];ProFormList 支持传入一个方法来获取到当前行的信息和快捷操作，这对于复杂的联动来说是很方便的。<ProFormList>  {(    // 当前行的基本信息 {name: number; key: number}    meta,    // 当前的行号    index,    /**     * action     * @name 用于操作行的一些快捷方法     * @example 给第二行增加数据 action.add?.({},1);     * @example 删除第二行 action.remove?.(1);     * @example 从 1 移到 2: action.move?.(2,1);     * @example 获取当前行的数据: action.getCurrentRowData() -> {id:\"xxx\",name:'123',age:18}     * @example 设置当前行的数据: {id:\"123\",name:'123'} -> action.setCurrentRowData({name:'xxx'}) -> {id:\"123\",name:'xxx'}     * @example 清空当前行的数据：{id:\"123\",name:'123'} -> action.setCurrentRowData({name:undefined}) -> {id:\"123\"}     */    action,    // 总行数    count,  ) => {    return (      <div key=\"row\">        <ProFormText name=\"id\" />        <ProFormText name=\"name\" />      </div>    );  }}</ProFormList>这四个参数的类型定义如下：type RenderActionParams = {  /**   * @name 当前行的meta信息   * @example {name: number; key: number}   */  meta: FormListFieldData;  /**   * @name 当前行的行号   */  index: number;  /**   * @name 用于操作行的一些快捷方法   * @example 给第二行增加数据 action.add?.({},1);   * @example 删除第二行 action.remove?.(1);   * @example 从 1 移到 2: action.move?.(2,1);   * @example 获取当前行的数据: action.getCurrentRowData() -> {id:\"xxx\",name:'123',age:18}   * @example 设置当前行的数据: {id:\"123\",name:'123'} -> action.setCurrentRowData({name:'xxx'}) -> {id:\"123\",name:'xxx'}   * @example 清空当前行的数据：{id:\"123\",name:'123'} -> action.setCurrentRowData({name:undefined}) -> {id:\"123\"}   */  action: FormListOperation & {    /**     * @name 获取当前行的数据     * @example getCurrentRowData -> {id:\"xxx\",name:'123',age:18}     */    getCurrentRowData: () => any;    /**     * @name 设置当前行的数据     * @example {id:\"123\",name:'123'} -> setCurrentRowData({name:'xxx'}) -> {id:\"123\",name:'123'}     * @example {id:\"123\",name:'123'} -> setCurrentRowData({name:undefined}) -> {id:\"123\"}     */    setCurrentRowData: (data: any) => void;  };  /**   * @name 总行数   */  count: number;};ProFormFieldSet 可以将内部的多个 children 的值组合并且存储在 ProForm 中，并且可以通过transform在提交时转化。下面是一个简单的用法,可以方便的组合多个输入框，并且格式化为想要的数据。<ProFormFieldSet  name=\"list\"  label=\"组件列表\"  // 支持 两种方式，type=\"group\" 会用input.group 包裹  // 如果不配置 默认使用 space  type=\"group\"  transform={(value: any) => ({ startTime: value[0], endTime: value[1] })}>  <ProFormText width=\"md\" />  <ProFormText width=\"md\" />  <ProFormText width=\"md\" /></ProFormFieldSet>ProFormDependency 是一个简化版本的 Form.Item，它默认内置了 noStyle 与 shouldUpdate，我们只需要配置 name 来确定我们依赖哪个数据，ProFormDependency 会自动处理 diff 和并且从表单中提取相应的值。name 参数必须要是一个数组，如果是嵌套的结构可以这样配置name={['name', ['name2', 'text']]}。配置的 name 的值会在 renderProps 中传入。name={['name', ['name2', 'text']]}传入的 values 的值 为{ name: string,name2: { text:string } }。<ProFormDependency name={['name']}>  {({ name }) => {    return (      <ProFormSelect        options={[          {            value: 'chapter',            label: '盖章后生效',          },        ]}        width=\"md\"        name=\"useMode\"        label={`与《${name}》合同约定生效方式`}      />    );  }}</ProFormDependency>"
  },
  {
    "path": "components/login-form",
    "key": "components/LoginForm/index",
    "text": "LoginForm 和 LoginFormPage 是 ProForm 的变体，两者是为了适应常见的登录表单布局来专门实现，适用于各类登录场景，降低布局的压力。LoginForm 代表了比较常见的居中布局样式。参数说明类型默认值logologo 的配置，支持 ReactNode 和 stringReactNode | url-title标题，可以配置为空ReactNode-subTitle二级标题，可以配置为空ReactNode-actions自定义额外的登录功能ReactNodemessageform 顶部的一个提示配置，可以配置一些错误的提示信息ReactNode-LoginFormPage 使用了左右布局，并且增加了一些广告位的配置。参数说明类型默认值logologo 的配置，支持 ReactNode 和 stringReactNode | url-title标题，可以配置为空ReactNode-subTitle二级标题，可以配置为空ReactNode-actions自定义额外的登录功能ReactNodemessageform 顶部的一个提示配置，可以配置一些错误的提示信息ReactNode-backgroundImageUrl整个区域的背景图片配置，手机端不会展示url-activityConfig活动的配置，包含 title，subTitle，action，分别代表标题，次标题和行动按钮，也可配置 style 来控制区域的样式{title,subTitle,action,style}-"
  },
  {
    "path": "components/modal-form",
    "key": "components/ModalForm/index",
    "text": "ModalForm 和 DrawerForm 是 ProForm 的一个变体，本质上仍然是个表单。所以无法通过footer来自定义页脚,如果要定义页脚需要使用submitter.render来进行自定义。这两个表单的表现与 ProForm 相同，可以从 ProForm 直接修改而来。ModalForm 和 DrawerForm 都提供了 trigger 来减少 state 的使用，如果你需要使用 state 来控制可以使用open和onOpenChange来控制打开与关闭。ModalForm 组合了 Modal 和 ProForm 可以减少繁琐的状态管理。参数说明类型默认值trigger用于触发 Modal 打开的 dom，一般是 buttonReactNode-open是否打开open-onOpenChangevisible 改变时触发(open:boolean)=>void-modalPropsModal 的 props，使用方式与antd相同。注意：不支持 'visible'，请使用全局的 visibleprops-title弹框的标题ReactNode-width弹框的宽度Number-onFinish提交数据时触发，如果返回一个 true。会关掉抽屉,如果配置了destroyOnClose还会重置表单。async (values)=>boolean-submitTimeout提交数据时，禁用取消按钮的超时时间（毫秒）。Number-submitter提交按钮相关配置，使用方式与ProForm相同。ProForm-DrawerForm 组合了 Drawer 和 ProForm 可以减少繁琐的状态管理。参数说明类型默认值trigger用于触发 Modal 打开的 dom，一般是 buttonReactNode-resize是否调整大小{onResize,maxWidth,minWidth}-isResizable是否调整大小boolean-onOpenChangeopen 改变时触发(open:boolean)=>void-drawerPropsDrawer 的 props，使用方式与antd相同。注意：不支持 'visible'，请使用全局的 visibleprops-title抽屉的标题ReactNode-width抽屉的宽度Number-onFinish提交数据时触发，如果返回一个 true。会关掉抽屉,如果配置了destroyOnClose还会重置表单。async (values)=>boolean-submitTimeout提交数据时，禁用取消按钮的超时时间（毫秒）。Number-"
  },
  {
    "path": "components/query-filter",
    "key": "components/QueryFilter/index",
    "text": "有些是时候表单要与别的组件组合使用，常见的有 Table ，List 等，这时候就需要一些特殊形态的表单。QueryFilter 和 LightFilter 解决了配合组件使用的问题，避免了复杂的样式设置。ProTable 中默认 支持了 QueryFilter 和 LightFilter 作为自己的筛选表单。折叠模式下所有的选项都会默认折叠，不管是否有值，控件的secondary将不再有效。手动设置轻量筛选的弹出框，默认为bottomLeftQueryFilter 除了继承 ProForm 的 API 以外还支持下面的属性。参数说明类型默认值collapsed是否折叠超出的表单项，用于受控模式boolean-defaultCollapsed默认状态下是否折叠超出的表单项booleantrueonCollapse切换表单折叠状态时的回调(collapsed)=>void-hideRequiredMark隐藏所有表单项的必选标记，默认隐藏booleantruesubmitterColSpanProps提交按钮所在 col 的 propsColProps-defaultColsNumber自定义折叠状态下默认显示的表单控件数量，没有设置或小于 0，则显示一行控件; 数量大于等于控件数量则隐藏展开按钮number-labelWidthlabel 宽度number|'auto'80span表单项宽度number[0 - 24]-split每一行是否有分割线boolean-preserve是否能够查询收起的数据，如果设置为 false，收起后的表单数据将会丢失booleantrue注意，断点的值均为表单容器的大小而非视口大小。容器宽度断点单行展示表单列数（包含操作区域）默认布局≧ 1352px4 列horizontal≧ 1062px3 列horizontal≧ 701px && < 1063px3 列horizontal≧ 513px && < 701px2 列vertical< 513px1 列vertical容器宽度断点单行展示表单列数（包含操作区域）≧ 1057px4 列≧ 785px && < 1057px3 列≧ 513px && < 785px2 列< 513px1 列LightFilter 除了继承 ProForm 的 API 以外还支持下面的属性。参数说明类型默认值collapse是否默认折叠全部字段booleanfalsecollapseLabel折叠区域的标签ReactNode更多筛选 <DownOutlined/>footerRender底部内容，当不需要默认底部按钮时，可以设为 footer={false}(onClear?: () => void, onConfirm: () => void) => JSX.Element | false)|false-placement选择框弹出的位置 ：bottomLeftbottomRighttopLefttopRightstringbottomLeft"
  },
  {
    "path": "components/steps-form",
    "key": "components/StepsForm/index",
    "text": "StepsForm 通过 Provider 来管理子表单的数据，每个子表单都是完整的数据，在 StepsForm 组合成最后的数据。同时自带了一个进度条，和管理进度条的相关 API.StepsForm 继承了 Form.Provider ，相关文档可以看这里,转化 moment 的值是 ProForm 提供的功能，所以onFormFinish和onFormChange其中的值都是未经转化的。参数说明类型默认值current当前表单的步骤数，从0开始number0onCurrentChangecurrent 发生改变的事件(current:number)=>void-onFinish表单最后一步提交成功触发，如果返回true就会自动重置表单(包括StepForm变回第一步)(values:T)=>void | boolean-stepsPropsStepsForm 自带的 Steps 的 props，使用方式与antd相同，但是去掉了 current 和 onChangeprops-stepFormRender自定义当前展示的表单，返回 dom 在表单内部(form) => ReactNode-stepsFormRender自定义整个表单区域，返回的 dom 在表单的外部(form,submitter) => ReactNode-stepsRender自定义步骤器(steps,dom)=>ReactNode-formRefStepForm action 的引用，便于自定义触发MutableRefObject<FormInstance>-与ProForm完全相同，只是 onFinish 支持了 Promise，如果返回false, 就不会跳转下一步。| onFinish | 表单提交成功触发 |(values:T)=>Promise<false>| - |"
  },
  {
    "path": "components/page-container",
    "key": "components/PageContainer/index",
    "text": "PageContainer 是为了减少繁杂的面包屑配置和标题，很多页面都需要面包屑和标题的配置。当然也可以关掉自动生成的，而使用自己的配置。PageContainer 封装了 antd 的 PageHeader 组件，增加了 tabList 和 content。 根据当前的路由填入 title 和 breadcrumb。它依赖 Layout 的 route 属性。当然你可以传入参数来复写默认值。 PageContainer 支持 Tabs 和 PageHeader 的所有属性。为了方便进行表单等操作我们增加了一个 footer 属性，可以获得一个一直悬浮在底部的操作栏。如果觉得不方便也可以直接使用 FooterToolbar 来承载操作，两者表现基本相同，但是 FooterToolbar 拥有更多自定义的配置。<PageContainer  content=\"欢迎使用 ProLayout 组件\"  tabList={[    {      tab: '基本信息',      key: 'base',    },    {      tab: '详细信息',      key: 'info',    },  ]}  extra={[    <Button key=\"3\">操作</Button>,    <Button key=\"2\">操作</Button>,    <Button key=\"1\" type=\"primary\">      主操作    </Button>,  ]}  footer={[    <Button key=\"rest\">重置</Button>,    <Button key=\"submit\" type=\"primary\">      提交    </Button>,  ]}>  {children}</PageContainer>PageContainer 封装了 ant design 的 PageHeader 组件，增加了 tabList 和 content。 根据当前的路由填入 title 和 breadcrumb。它依赖 Layout 的 route 属性。当然你可以传入参数来复写默认值。 PageContainer 支持Tabs和PageHeader的所有属性。参数说明类型默认值content内容区ReactNode-extraContent额外内容区，位于 content 的右侧ReactNode-tabListtab 标题列表{key: string, tab: ReactNode}[]-tabActiveKey当前高亮的 tab 项string-onTabChange切换面板的回调(key) => void-tabBarExtraContenttab bar 上额外的元素React.ReactNode-headerPageHeader的所有属性PageHeaderProps-ghost配置头部区域的背景颜色为透明booleanfalsefixedHeader固定 pageHeader 的内容到顶部，如果页面内容较少，最好不要使用，会有严重的遮挡问题boolean-affixProps固钉的配置，与 antd 完全相同AffixProps-footer悬浮在底部的操作栏，传入一个数组，会自动加空格ReactNode[]-waterMarkProps配置水印，Layout 会透传给 PageContainer，但是以 PageContainer 的配置优先WaterMarkProps-tabPropsTabs 的相关属性，只有卡片样式的页签支持新增和关闭选项。使用closable={false}禁止关闭TabsProps-fixedHeader 使用了 antd 的 Affix 实现，默认监听 body，如果你的滚动条不在 body 上需要人肉设置一下。参数说明类型默认值extra额外内容区，位于 content 的右侧ReactNode-children内容区域ReactNode|ReactNode[]-FooterToolbar api 比较简单，主要功能是实现了在 layout 中自动控制浮动，使其不会挡住菜单。如果你没有使用 ProLayout 需要通过 style 来自定义宽度和浮动。<FooterToolbar  style={{    left: 208,    width: `calc(100% - 208px)`,  }}>  <Button>提交</Button></FooterToolbar>配置与面包屑相同，只是增加了自动根据路由计算面包屑的功能。此功能必须要在 ProLayout 中使用。import { ProBreadcrumb, ProLayout } from '@ant-design/pro-components';return (props) => (  <ProLayout    {...props}    // 将面包屑显示在顶部    headerContentRender={() => {      return <ProBreadcrumb />;    }}  />);"
  },
  {
    "path": "components/page-header",
    "key": "components/PageHeader/index",
    "text": "页头位于页容器中，页容器顶部，起到了内容概览和引导页级操作的作用。包括由面包屑、标题、页面内容简介、页面级操作等、页面级导航组成。当需要使用户快速理解当前页是什么以及方便用户使用页面功能时使用，通常也可被用作页面间导航。参数说明类型默认值版本avatar标题栏旁的头像AvatarProps-backIcon自定义 back icon ，如果为 false 不渲染 back iconReactNode | boolean<ArrowLeft />breadcrumb面包屑的配置Breadcrumb-breadcrumbRender自定义面包屑区域的内容(props, originBreadcrumb) => ReactNode-4.11.0extra操作区，位于 title 行的行尾ReactNode-footerPageHeader 的页脚，一般用于渲染 TabBarReactNode-ghostpageHeader 的类型，将会改变背景颜色booleantruesubTitle自定义的二级标题文字ReactNode-tagstitle 旁的 tag 列表Tag[] |Tag-title自定义标题文字ReactNode-onBack返回按钮的点击事件() => void-"
  },
  {
    "path": "components/water-mark",
    "key": "components/WaterMark/index",
    "text": "给页面的某个区域加上水印。页面需要添加水印标识版权时使用。水印组件默认实现为前置水印，即设想水印会显示在内容的上方，zIndex 默认设置为 9，如果你不希望水印遮挡上层内容，可以调整该值到小于上层内容的 zIndex。通过content指定文字水印内容。通过content设置 字符串数组 指定多行文字水印内容。通过image指定图片地址。为保证图片高清且不被拉伸，请传入水印图片的宽高 width 和 height, 并上传至少两倍的宽高的 logo 图片地址。这里给出一些通用配置项。如需进一步配置请联系我们。参数说明类型默认值版本width水印的宽度number1202.2.0height水印的高度number642.2.0rotate水印绘制时，旋转的角度，单位 °number-222.2.0image图片源，建议导出 2 倍或 3 倍图，优先使用图片渲染水印string-2.2.0zIndex追加的水印元素的 z-indexnumber92.2.0content水印文字内容string|string[]-2.2.0fontColor水印文字颜色stringrgba(0,0,0,.15)2.2.0fontSize文字大小string|number162.2.0参数说明类型默认值版本markStyle水印层的样式React.CSSProperties-2.3.0markClassName水印层的类名string-2.3.0gapX水印之间的水平间距number2122.4.0gapY水印之间的垂直间距number2222.4.0offsetLeft水印在 canvas 画布上绘制的水平偏移量, 正常情况下，水印绘制在中间位置, 即offsetLeft = gapX / 2numberoffsetLeft = gapX / 22.4.0offsetTop水印在 canvas 画布上绘制的垂直偏移量，正常情况下，水印绘制在中间位置, 即offsetTop = gapY / 2numberoffsetTop = gapY / 22.4.0"
  },
  {
    "path": "components/list",
    "key": "components/list",
    "text": "基于 ProTable 实现，可以认为是 ProTable 的一个特例，在完成一个标准的列表时即可使用。ProList 与 antd 的List相比，API 设计上更像 Table，使得可以通过配置化的方式快速定义数据项的展现形式。也使得 Table 和 List 的切换变得更加容易。另外 ProList 基于 ProTable 实现，除了 Table 相关的 API 以外 ProList 支持大部分 ProTable 的 API。参数说明类型默认值dataSource与 antd 相同的配置any[]falseactionRefTable action 的引用，便于自定义触发MutableRefObject<ActionType>-metas列表项配置，类似 Table 中的 columnsMetas-rowKey行的 key，一般是行 idstring|(row,index)=>string'id'headerTitle列表头部主标题React.ReactNode-loading是否加载中boolean|(item: any) => booleanfalsesplit是否有分割线booleanfalserowSelection与 antd 相同的配置object|booleanfalseexpandable与 antd 相同的配置object|false-showActions何时展示 actions，CardList 模式下不生效'hover'|'always''always'showExtra何时展示 extra'hover'|'always''always'onRow与 antd 相同的配置，用户传入grid属性时，列表将会以卡片模式进行渲染，此事件将不会触发，请使用onItemfunction(record, index)-onItem与 antd 相同的配置，在所有类型点击某个项目都会触发该事件。function(record, index)-rowClassName自定义列表行的类名string|(row, index) => string-itemHeaderRender自定义每一列的 header，与 itemRender 不同的时，它会保留多选和展开收起--itemCardProps自定义卡片列表的 proCard props，只在卡片列表下生效--与 ProTable 相同的配置。参数说明类型默认值dataIndex数据在数据项中对应的路径，支持通过数组查询嵌套路径string|string[]-valueType值的类型，和 ProTable 一致'text'|'date'...'text'render自定义渲染函数(text: React.ReactNode,record: T,index: number) => React.ReactNode | React.ReactNode[]-对应 dataSource 的字段类型为'new'|'top'|'inline'。参数说明类型默认值dataIndex--'type'参数说明类型默认值dataIndex--'title'参数说明类型默认值dataIndex--'subTitle'参数说明类型默认值dataIndex--'description'参数说明类型默认值dataIndex--'avatar'参数说明类型默认值dataIndex--'actions'cardActionProps设置卡片列表把 action 渲染到哪里｜extra｜'actions' | 'extra'参数说明类型默认值dataIndex--'content'参数说明类型默认值dataIndex--'extra'"
  },
  {
    "path": "components/skeleton",
    "key": "components/skeleton",
    "text": "该组件为内部组件，请勿直接使用。页面级别的骨架屏，不支持自定义import Skeleton from '@ant-design/pro-skeleton';return <Skeleton type=\"list\" />;参数说明类型默认值type不同类型的骨架屏'list' | 'result' | 'descriptions'listactive是否显示动态booleantruepageHeader是否显示 pageHeader 的骨架屏 descriptions 和 list 有效--statistic统计信息骨架屏的数量number|false-list列表的骨架屏，可以控制数量number|false-toolbar列表的操作栏骨架屏boolean-renderFormItem自定义mode=update 或 edit下的 dom 表现，一般用于渲染编辑框--render自定义mode=read下的 dom 表现，只是单纯的表现形式--"
  },
  {
    "path": "components/drag-sort-table",
    "key": "components/DragSortTable/index",
    "text": "DragSortTable排序采用的dnd-kit，需要提供rowKey来确定数据的唯一值，否则不能正常工作。属性描述类型默认值dragSortKey如配置此参数，则会在该 key 对应的行显示拖拽排序把手，允许拖拽排序string-dragSortHandlerRender渲染自定义拖动排序把手的函数 如配置了 dragSortKey 但未配置此参数，则使用默认把手图标(rowData: T, idx: number) => React.ReactNode<MenuOutlined className=\"dragSortDefaultHandle\" style={{ cursor: 'grab', color: '#999' }} />onDragSortEnd拖动排序完成回调(newDataSource: T[]) => Promise<void> | void-"
  },
  {
    "path": "components/editable-table",
    "key": "components/EditableTable/index",
    "text": "可编辑表格 EditableProTable 与 ProTable 的功能基本相同，为了方便使用 EditableProTable 增加了一些预设，关掉了查询表单和操作栏，同时修改了 value 和 onChange 使其可以方便的继承到 antd 的 Form 中。属性描述类型默认值value同 dataSource，传入一个数组,是 table 渲染的元数据T[]undefinedonChangedataSource 修改时触发，删除和修改都会触发,如果设置了 value，Table 会成为一个受控组件。(value:T[])=>voidundefinedrecordCreatorProps新建一行数据的相关配置RecordCreatorProps&ButtonProps-maxLength最大的行数，到达最大行数新建按钮会自动消失number-editable可编辑表格的相关配置TableRowEditable-controlled是否受控, 如果受控每次编辑都会触发 onChange，并且会修改 dataSourcebooleanfalseeditableFormReftable 所有的 form，带了一些表格特有的操作React.Ref<EditableFormInstance<T>>undefined别的 API 与 ProTable 相同。新增一行的时候要保证recordCreatorProps.recordkey 唯一，不然会导致编辑出错。<EditableTable  rowKey=\"id\"  recordCreatorProps={{    position: position as 'top',    // 每次新增的时候需要Key    record: () => ({ id: getNewId() }),  }}/>相比于 ProForm 的表单，可编辑表格增加了以下的三个方法。/**   * 获取一行数据的   * @param rowIndex   * @returns T | undefined   *   * @example getRowData(1)  可以传入第几行的数据   * @example getRowData(\"id\")  也可以传入 rowKey，根据你列的唯一key 来获得。   */  getRowData?: (rowIndex: string | number) => T | undefined;  /**   * 获取整个 table 的数据   * @returns T[] | undefined   */  getRowsData?: () => T[] | undefined;  /**   * 设置一行的数据，会将数据进行简单的 merge   *   * {title:\"old\", decs:\"old\",id:\"old\"} -> set {title:\"new\"} -> {title:\"new\", decs:\"old\",id:\"old\"}   *   * @description 只会做最第一层对象的 merge 哦。   * {title:\"old\", decs:{name:\"old\",key:\"old\"},id:\"old\"} -> set {decs:{name:\"new\"}} -> {title:\"old\", decs:{name:\"new\"},id:\"old\"} -> set {decs:{name:\"old\"}}   *   * @param rowIndex   * @param data   * @returns void   *   * 根据行号设置   * @example setRowData(1, { title:\"new\" })  可以传入修改第几行   *   * 根据行 id 设置   * @example setRowData(\"id\", { title:\"new\" })  也可以传入 rowKey，根据你列的唯一 key 来设置。   *   * 清空原有数据   * @example setRowData(1, { title:undefined })   *   */  setRowData?: (rowIndex: string | number, data: Partial<T>) => void;属性描述类型默认值type可编辑表格的类型，单行编辑或者多行编辑single|multiple-form可编辑表格的 form 实例，使用Form.useForm生成后使用FormInstance-formProps可以配置 form 的属性，但是不支持 onFinishFormProps-editableKeys正在编辑的行，受控属性。 默认key会使用rowKey的配置，如果没有配置会使用index，建议使用 rowKeyKey[]-onChange行数据被修改的时候触发(editableKeys: Key[], editableRows: T[]) => void-onSave保存一行的时候触发(key: Key, row: T,originRow:T,newLine?:newLineConfig) => Promise<any>-saveText保存一行的文字React.ReactNode保存onDelete删除一行的时候触发(key: Key, row: T) => Promise<any>-deleteText删除一行的文字React.ReactNode删除onCancel取消编辑一行时触发(key: Key, row: T,originRow:T,newLine?:newLineConfig) => Promise<any>-cancelText取消编辑一行的文字React.ReactNode取消actionRender自定义编辑模式的操作栏(row: T, config: ActionRenderConfig<T>) => ReactNode[]-deletePopconfirmMessage删除时弹出的确认框提示消息ReactNode删除此行？onlyOneLineEditorAlertMessage只能编辑一行的的提示ReactNode只能同时编辑一行onlyAddOneLineAlertMessage只能同时新增一行的提示ReactNode只能新增一行为了使用，我们预设了一个新建的功能，大多数情况下已经可以满足大部分新建的需求，但是很多时候需求总是千奇百怪。我们也准备了recordCreatorProps来控制生成按钮。与 Pro 系列组件的 API 相同，recordCreatorProps={false}就可以关掉按钮，同时使用actionRef.current?.addEditRecord(row)来控制新建行。recordCreatorProps也支持自定义一些样式，position='top'|'bottom'可以配置增加在表格头还是表格尾部。record可以配置新增行的默认数据。以下是一个列举recordCreatorProps = {  // 要增加到哪个节点下，一般用于多重嵌套表格  parentKey: React.key,  // 顶部添加还是末尾添加  position: 'bottom',  // 新增一行的方式，默认是缓存，取消后就会消失  // 如果设置为 dataSource 会触发 onchange，取消后也不会消失，只能删除  newRecordType: 'dataSource',  // 不写 key ，会使用 index 当行 id  record: {},  // 设置按钮文案  creatorButtonText: '新增一行',  // 按钮的样式设置，可以设置按钮是否显示  // 这样可以做最大行限制和最小行限制之类的功能  style: {    display: 'none',  },  // https://ant.design/components/button-cn/#API  ...antButtonProps,};虽然我们很希望默认的 valueType 可以满足所有的需求，但是现实往往不尽如人意。所以我们也提供了renderFormItem来自定义编辑输入组件。renderFormItem可以理解为在 Form.Item 下面加入一个元素， 伪代码实现是下面这样的：const dom = renderFormItem();<Form.Item>{dom}</Form.Item>;所以与 Form.Item 相同，我们认为renderFormItem返回的组件都是拥有的value和onChange的，我们接下来将看到用renderFormItem将一个简单的 TagList 组件放入可编辑表格中。没有value将会无法注入值，没有onChange会无法修改行数据首先我们定义一个 TagList 组件。const TagList: React.FC<{  value?: {    key: string;    label: string;  }[];  onChange?: (    value: {      key: string;      label: string;    }[],  ) => void;}> = ({ value, onChange }) => {  const ref = useRef<Input | null>(null);  const [newTags, setNewTags] = useState<    {      key: string;      label: string;    }[]  >([]);  const [inputValue, setInputValue] = useState<string>('');  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {    setInputValue(e.target.value);  };  const handleInputConfirm = () => {    let tempsTags = [...(value || [])];    if (      inputValue &&      tempsTags.filter((tag) => tag.label === inputValue).length === 0    ) {      tempsTags = [        ...tempsTags,        { key: `new-${tempsTags.length}`, label: inputValue },      ];    }    onChange?.(tempsTags);    setNewTags([]);    setInputValue('');  };  return (    <Space>      {(value || []).concat(newTags).map((item) => (        <Tag key={item.key}>{item.label}</Tag>      ))}      <Input        ref={ref}        type=\"text\"        size=\"small\"        style={{ width: 78 }}        value={inputValue}        onChange={handleInputChange}        onBlur={handleInputConfirm}        onPressEnter={handleInputConfirm}      />    </Space>  );};在列中我们可以这样配置它。{    title: '标签',    dataIndex: 'labels',    width: '40%',    renderFormItem: () => <TagList />,    render: (_, row) => row?.labels?.map((item) => <Tag key={item.key}>{item.label}</Tag>),  },转化成的编辑表格效果如下 ：value 和 onChange 会自动注入，我们不需要显式的注入。数据绑定也是由编辑表格自己注入的，我们在onSave中可以拿到处理完成的数据。虽然我们可以行内的写很复杂的逻辑甚至网路请求，但是我们推荐使用拆分组件，这样不仅性能更好，逻辑也可以拆分的很简单。renderFormItem同时也用来生成查询表单，如果我们需要区分这两种情况，可以使用renderFormItem: (_, { isEditable }) => (isEditable ? <TagList /> : <Input /> )这样的方式来进行分别渲染。可编辑表格默认提供了三大金刚， 保存，删除 和 取消，如果我们要实现复制一行，或者需求只需要的 保存和取消，不需要删除按钮就需要自定义了。可编辑表格提供了 API 来进行自定义，以下会直接展示代码:render: (text, record, _, action) => [  <a    key=\"editable\"    onClick={() => {      action?.startEditable?.(record.id);    }}  >    编辑  </a>,  <EditableProTable.RecordCreator    record={{      ...record,      id: (Math.random() * 1000000).toFixed(0),    }}  >    <a>复制此行到末尾</a>  </EditableProTable.RecordCreator>,];const editable = {  // defaultDom = {save,cancel,delete} 可以酌情添加和使用  actionRender: (row, config, defaultDom) => [    defaultDom.save,    defaultDom.cancel,  ],};"
  },
  {
    "path": "components/table",
    "key": "components/table",
    "text": "ProTable 的诞生是为了解决项目中需要写很多 table 的样板代码的问题，所以在其中做了封装了很多常用的逻辑。这些封装可以简单的分类为预设行为与预设逻辑。依托于 ProForm 的能力，ProForm 拥有多种形态，可以切换查询表单类型，设置变形成为一个简单的 Form 表单，执行新建等功能。若您是内网用户，欢迎使用我们的TechUI Studio可视化配置生成初始代码。当你的表格需要与服务端进行交互或者需要多种单元格样式时，ProTable 是不二选择。ProTable 在 antd 的 Table 上进行了一层封装，支持了一些预设，并且封装了一些行为。这里只列出与 antd Table 不同的 api。request是 ProTable 最重要的 API，request会接收一个对象。对象中必须要有data和success，如果需要手动分页total也是必需的。request会接管loading的设置，同时在查询表单查询和params参数发生修改时重新执行。同时 查询表单的值和params参数也会带入。以下是一个例子：<ProTable<DataType, Params>  // params 是需要自带的参数  // 这个参数优先级更高，会覆盖查询表单的参数  params={params}  request={async (    // 第一个参数 params 查询表单和 params 参数的结合    // 第一个参数中一定会有 pageSize 和  current ，这两个参数是 antd 的规范    params: T & {      pageSize: number;      current: number;    },    sort,    filter,  ) => {    // 这里需要返回一个 Promise,在返回之前你可以进行数据转化    // 如果需要转化参数可以在这里进行修改    const msg = await myQuery({      page: params.current,      pageSize: params.pageSize,    });    return {      data: msg.result,      // success 请返回 true，      // 不然 table 会停止解析数据，即使有数据      success: boolean,      // 不传会使用 data 的长度，如果是分页一定要传      total: number,    };  }}/>列配置中也支持 request，但是只有几种valueType支持。属性描述类型默认值request获取dataSource的方法(params?: {pageSize,current},sort,filter) => {data,success,total}-params用于request查询的额外参数，一旦变化会触发重新加载object-postData对通过request获取的数据进行处理(data: T[]) => T[]-defaultData默认的数据T[]-dataSourceTable 的数据，protable 推荐使用 request 来加载T[]-onDataSourceChangeTable 的数据发生改变时触发(dataSource: T[]) => void-actionRefTable action 的引用，便于自定义触发MutableRefObject<ActionType>-formRef可以获取到查询表单的 form 实例，用于一些灵活的配置MutableRefObject<FormInstance>-toolBarRender渲染工具栏，支持返回一个 dom 数组，会自动增加 margin-right(action) => ReactNode[]-onLoad数据加载完成后触发,会多次触发(dataSource: T[]) => void-onLoadingChangeloading 被修改时触发，一般是网络请求导致的(loading:boolean)=>void-onRequestError数据加载失败时触发(error) => void-tableClassName封装的 table 的 classNamestring-tableStyle封装的 table 的 styleCSSProperties-optionstable 工具栏，设为 false 时不显示.传入 function 会点击时触发{{ density?: boolean, fullScreen?: boolean | function, reload?: boolean | function, reloadIcon?: React.ReactNode, densityIcon?: React.ReactNode, setting?: boolean |SettingOptionType}}{ fullScreen: false, reload: true, setting: true }search是否显示搜索表单，传入对象时为搜索表单的配置false|SearchConfig-defaultSize默认的 sizeSizeType-dateFormatter转化 moment 格式数据为特定类型，false 不做转化\"string\"|\"number\"| ((value: Moment, valueType: string) => string | number) |false\"string\"beforeSearchSubmit搜索之前进行一些修改(params:T)=>T-onSizeChangetable 尺寸发生改变(size: 'default' | 'middle' | 'small') => void-typepro-table 类型\"form\"-formantd form 的配置FormProps-onSubmit提交表单时触发(params: U) => void-onReset重置表单时触发() => void-columnEmptyText空值时的显示，不设置时显示-， false 可以关闭此功能string|falsefalsetableRender自定义渲染表格函数(props,dom,domList:{ toolbar,alert,table}) => ReactNode-toolbar透传ListToolBar配置项ListToolBarProps-tableExtraRender自定义表格的主体函数(props: ProTableProps<T, U>, dataSource: T[]) => ReactNode;-manualRequest是否需要手动触发首次请求, 配置为true时不可隐藏搜索表单booleanfalseeditable可编辑表格的相关配置TableRowEditable-cardBorderedTable 和 Search 外围 Card 组件的边框boolean | {search?: boolean, table?: boolean}falseghost幽灵模式，即是否取消表格区域的 paddingbooleanfalsedebounceTime防抖时间number10revalidateOnFocus窗口聚焦时自动重新请求booleantruecolumnsState受控的列状态，可以操作显示隐藏ColumnStateType-ErrorBoundary自带了错误处理功能，防止白屏，ErrorBoundary=false关闭默认错误边界ReactNode内置 ErrorBoundary属性描述类型默认值record需要新增的行数据，一般来说包含唯一 keyT{}position行增加在哪里，开始或者末尾top|bottombottom(...buttonProps)antd 的ButtonPropsButtonProps—属性描述类型默认值defaultValue列状态的默认值，只有初次生效，並用于重置使用Record<string, ColumnsState>;-value列状态的值，支持受控模式Record<string, ColumnsState>;-onChange列状态的值发生改变之后触发(value:Record<string, ColumnsState>)=>void-persistenceKey持久化列的 key，用于判断是否是同一个 tablestring | number-persistenceType持久化列的类类型， localStorage 设置在关闭浏览器后也是存在的，sessionStorage 关闭浏览器后会丢失localStorage | sessionStorage-属性描述类型默认值filterType过滤表单类型'query'|'light''query'searchText查询按钮的文本string查询resetText重置按钮的文本string重置submitText提交按钮的文本string提交labelWidth标签的宽度'number'|'auto'80span配置查询表单的列数'number'|'ColConfig'defaultColConfigclassName封装的搜索 Form 的 classNamestring-collapseRender收起按钮的 render(collapsed: boolean,showCollapseButton?: boolean,) => ReactNode-defaultCollapsed默认是否收起booleantruecollapsed是否收起boolean-onCollapse收起按钮的事件(collapsed: boolean) => void;-optionRender自定义操作栏((searchConfig,formProps,dom) => ReactNode[])|false-showHiddenNum是否显示收起之后显示隐藏个数booleanfalseconst defaultColConfig = {  xs: 24,  sm: 24,  md: 12,  lg: 12,  xl: 8,  xxl: 6,};export type OptionsType =  | ((e: React.MouseEvent<HTMLSpanElement>, action?: ActionType) => void)  | boolean;export type OptionConfig = {  density?: boolean;  fullScreen?: OptionsType;  reload?: OptionsType;  setting?: boolean | SettingOptionType;  search?: (OptionSearchProps & { name?: string }) | boolean;  reloadIcon?: React.ReactNode;  densityIcon?: React.ReactNode;};export type SettingOptionType = {  draggable?: boolean;  checkable?: boolean;  checkedReset?: boolean;  listsHeight?: number;  extra?: React.ReactNode;  children?: React.ReactNode;  settingIcon?: React.ReactNode;};有时我们要手动触发 table 的 reload 等操作，可以使用 actionRef，可编辑表格也提供了一些操作来帮助我们更快的实现需求。interface ActionType {  reload: (resetPageIndex?: boolean) => void;  reloadAndRest: () => void;  reset: () => void;  clearSelected?: () => void;  startEditable: (rowKey: Key) => boolean;  cancelEditable: (rowKey: Key) => boolean;}const ref = useRef<ActionType>();<ProTable actionRef={ref} />;// 刷新ref.current.reload();// 刷新并清空,页码也会重置，不包括表单ref.current.reloadAndRest();// 重置到默认值，包括表单ref.current.reset();// 清空选中项ref.current.clearSelected();// 开始编辑ref.current.startEditable(rowKey);// 结束编辑ref.current.cancelEditable(rowKey);请求远程数据比较复杂，详细可以看这里。属性描述类型默认值title与 antd 中基本相同，但是支持通过传入一个方法ReactNode | ((config: ProColumnType<T>, type: ProTableTypes) => ReactNode)-tooltip会在 title 之后展示一个 icon，hover 之后提示一些信息string-ellipsis是否自动缩略boolean|{showTitle?: boolean}-copyable是否支持复制boolean-valueEnum值的枚举，会自动转化把值当成 key 来取出要显示的内容valueEnum-valueType值的类型,会生成不同的渲染器valueTypetextorder查询表单中的权重，权重大排序靠前number-fieldProps查询表单的 props，会透传给表单项,如果渲染出来是 Input,就支持 input 的所有 props，同理如果是 select，也支持 select 的所有 props。也支持方法传入(form,config)=>Record | Record-formItemProps传递给 Form.Item 的配置,可以配置 rules，但是默认的查询表单 rules 是不生效的。需要配置ignoreRules(form,config)=>formItemProps|formItemProps-renderText类似 table 的 render，但是必须返回 string，如果只是希望转化枚举，可以使用valueEnum(text: any,record: T,index: number,action: UseFetchDataAction<T>) => string-render类似 table 的 render，第一个参数变成了 dom,增加了第四个参数 action(text: ReactNode,record: T,index: number,action: UseFetchDataAction<T>) => ReactNode | ReactNode[]-renderFormItem渲染查询表单的输入组件(item,{ type, defaultRender, formItemProps, fieldProps, ...rest },form) => ReactNode-search配置列的搜索相关，false 为隐藏false|{ transform: (value: any) => any }truesearch.transform转化值的 key, 一般用于时间区间的转化(value: any) => any-editable在编辑表格中是否可编辑的，函数的参数和 table 的 render 一样false|(text: any, record: T,index: number) => booleantruecolSize一个表单项占用的格子数量,占比= colSize*span，colSize默认为 1 ，span为 8，span是form={{span:8}}全局设置的number-hideInSearch在查询表单中不展示此项boolean-hideInTable在 Table 中不展示此列boolean-hideInForm在 Form 中不展示此列boolean-hideInDescriptions在 Descriptions 中不展示此列boolean-filters表头的筛选菜单项，当值为 true 时，自动使用 valueEnum 生成boolean|object[]falseonFilter筛选表单，为 true 时使用 ProTable 自带的，为 false 时关闭本地筛选(value, record) => boolean|falsefalserequest从服务器请求枚举request-initialValue查询表单项初始值any-disable列设置中disabled的状态boolean|{ checkbox: boolean; }-ProTable 封装了一些常用的值类型来减少重复的render操作，配置一个valueType即可展示格式化响应的数据。与 antd 相同，批量操作需要设置rowSelection来开启，与 antd 不同的是，pro-table 提供了一个 alert 用于承载一些信息。你可以通过tableAlertRender和tableAlertOptionRender来对它进行自定义。设置或者返回 false 即可关闭。属性描述类型默认值alwaysShowAlert总是展示 alert，默认无选择不展示（rowSelection内置属性）boolean-tableAlertRender自定义批量操作工具栏左侧信息区域, false 时不显示({ selectedRowKeys: Key[], selectedRows: T[], onCleanSelected: ()=>void }) => ReactNode)|false-tableAlertOptionRender自定义批量操作工具栏右侧选项区域, false 时不显示({ selectedRowKeys: Key[], selectedRows: T[], onCleanSelected: ()=>void }) => ReactNode)|false-ProTable 会根据列来生成一个 Form，用于筛选列表数据，最后的值会根据通过request的第一个参数返回，看起来就像。<ProTable request={(params,sort,filter)=>{ all params}}>按照规范，table 的表单不需要任何的必选参数，所有点击搜索和重置都会触发request来发起一次查询。Form 的列是根据valueType来生成不同的类型,详细的值类型请查看通用配置。valueType 为 index indexBorder option 和没有 dataIndex 和 key 的列将会忽略。用于自定义表格的工具栏部分。列表和表格的工具栏配置属性参数说明类型默认值title标题ReactNode-subTitle子标题ReactNode-description描述ReactNode-search查询区ReactNode|SearchProps-actions操作区ReactNode[]-settings设置区(ReactNode | Setting)[]-filter过滤区，通常配合LightFilter使用ReactNode-multipleLine是否多行展示booleanfalsemenu菜单配置ListToolBarMenu-tabs标签页配置，仅当multipleLine为 true 时有效ListToolBarTabs-SearchProps 为 antd 的Input.Search的属性。参数说明类型默认值icon图标ReactNode-tooltiptooltip 描述string-key操作唯一标识string-onClick设置被触发(key: string)=>void-参数说明类型默认值type类型inline|dropdown|tabinlineactiveKey当前值string-items菜单项{ key: string; label: ReactNode }[]-onChange切换菜单的回调(activeKey)=>void-参数说明类型默认值activeKey当前选中项string-items菜单项{ key: string; tab: ReactNode }[]-onChange切换菜单的回调(activeKey)=>void-参数说明类型默认值key唯一标志string-name内容ReactNode-(...Menu.Item)antd 的Menu.ItemMenu.Item-"
  }
]
